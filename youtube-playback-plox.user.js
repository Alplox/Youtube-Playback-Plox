// ==UserScript==
// @name         YouTube Playback Plox
// @name:en      YouTube Playback Plox
// @name:es      YouTube Reproducci√≥n Plox
// @name:fr      YouTube Lecture Plox
// @name:de      YouTube Wiedergabe Plox
// @name:it      YouTube Riproduzione Plox
// @name:pt-BR   YouTube Reprodu√ß√£o Plox
// @name:nl      YouTube Afspelen Plox
// @name:pl      YouTube Odtwarzanie Plox
// @name:sv      YouTube Uppspelning Plox
// @name:da      YouTube Afspilning Plox
// @name:no      YouTube Avspilling Plox
// @name:fi      YouTube Toisto Plox
// @name:cs      YouTube P≈ôehr√°v√°n√≠ Plox
// @name:sk      YouTube Prehr√°vanie Plox
// @name:hu      YouTube Lej√°tsz√°s Plox
// @name:ro      YouTube Redare Plox
// @name:be      YouTube –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ Plox
// @name:bg      YouTube –í—ä–∑–ø—Ä–æ–∏–∑–≤–µ–∂–¥–∞–Ω–µ Plox
// @name:el      YouTube ŒëŒΩŒ±œÄŒ±œÅŒ±Œ≥œâŒ≥ŒÆ Plox
// @name:sr      YouTube –†–µ–ø—Ä–æ–¥—É–∫—Ü–∏—ò–∞ Plox
// @name:hr      YouTube Reprodukcija Plox
// @name:sl      YouTube Predvajanje Plox
// @name:lt      YouTube Grotuvas Plox
// @name:lv      YouTube Atska≈Üo≈°ana Plox
// @name:uk      YouTube –í—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è Plox
// @name:ru      YouTube –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ Plox
// @name:tr      YouTube Oynatma Plox
// @name:ar      ŸäŸàÿ™ŸäŸàÿ® ÿ®ŸÑÿßŸäÿ®ÿßŸÉ Plox
// @name:fa      ŸæÿÆÿ¥ €åŸàÿ™€åŸàÿ® Plox
// @name:he      YouTube ◊î◊©◊û◊¢◊î Plox
// @name:hi      YouTube ‡§™‡•ç‡§≤‡•á‡§¨‡•à‡§ï Plox
// @name:bn      YouTube ‡¶™‡ßç‡¶≤‡ßá‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï Plox
// @name:te      YouTube ‡∞™‡±ç‡∞≤‡±á‡∞¨‡±ç‡∞Ø‡∞æ‡∞ï‡±ç Plox
// @name:ta      YouTube ‡Æ™‡Æø‡Æ≥‡Øá‡Æ™‡Ææ‡Æï‡Øç Plox
// @name:mr      YouTube ‡§™‡•ç‡§≤‡•á‡§¨‡•Ö‡§ï Plox
// @name:zh-CN   YouTube Êí≠Êîæ Plox
// @name:zh-TW   YouTube Êí≠Êîæ Plox
// @name:zh-HK   YouTube Êí≠Êîæ Plox
// @name:ja      YouTube ÂÜçÁîü Plox
// @name:ko      YouTube Ïû¨ÏÉù Plox
// @name:th      YouTube ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠ Plox
// @name:vi      YouTube Ph√°t l·∫°i Plox
// @name:id      YouTube Pemutaran Plox
// @name:ms      YouTube Main Semula Plox
// @name:tl      YouTube Playback Plox
// @name:my      YouTube ·Äñ·Äú·Ä±·Ä∑·Äò·ÄÄ·Ä∫ Plox
// @name:sw      YouTube Uchezesha Plox
// @name:am      ·ã®YouTube ·â∞·å´·ãã·âΩ Plox
// @name:ha      YouTube Playback Plox
// @name:ur      YouTube ŸæŸÑ€í ÿ®€å⁄© Plox
// @name:ca      YouTube Reproducci√≥ Plox
// @name:zu      YouTube Playback Plox
// @name:yue      YouTube Êí≠Êîæ Plox
// @name:es-419      YouTube Reproducci√≥n Plox
// @description  Guarda y retoma autom√°ticamente el progreso de v√≠deos en YouTube sin necesidad de iniciar sesi√≥n.
// @description:en  Automatically saves and resumes video playback progress on YouTube without needing to log in.
// @description:es  Guarda y retoma autom√°ticamente el progreso de v√≠deos en YouTube sin necesidad de iniciar sesi√≥n.
// @description:fr  Enregistre et reprend automatiquement la progression de la lecture des vid√©os sur YouTube sans avoir besoin de se connecter.
// @description:de  Speichert und setzt den Fortschritt von YouTube-Videos automatisch fort, ohne dass eine Anmeldung erforderlich ist.
// @description:it  Salva e riprende automaticamente la riproduzione dei video su YouTube senza bisogno di accedere.
// @description:pt-BR  Salva e retoma automaticamente o progresso da reprodu√ß√£o de v√≠deos no YouTube sem precisar fazer login.
// @description:nl  Slaat automatisch de voortgang van video's op YouTube op en hervat deze zonder in te loggen.
// @description:pl  Automatycznie zapisuje i wznawia postƒôp odtwarzania wideo na YouTube bez logowania.
// @description:sv  Sparar och √•terupptar automatiskt videoframsteg p√• YouTube utan att beh√∂va logga in.
// @description:da  Gemmer og genoptager automatisk videoafspilning p√• YouTube uden at logge ind.
// @description:no  Lagrer og gjenopptar automatisk videofremdrift p√• YouTube uten √• logge inn.
// @description:fi  Tallentaa ja jatkaa automaattisesti YouTube-videoiden toistopistett√§ ilman kirjautumista.
// @description:cs  Automaticky ukl√°d√° a obnovuje postup p≈ôehr√°v√°n√≠ vide√≠ na YouTube bez nutnosti p≈ôihl√°≈°en√≠.
// @description:sk  Automaticky uklad√° a obnovuje priebeh prehr√°vania vide√≠ na YouTube bez potreby prihl√°senia.
// @description:hu  Automatikusan menti √©s folytatja a YouTube-vide√≥k lej√°tsz√°si el≈ërehalad√°s√°t bejelentkez√©s n√©lk√ºl.
// @description:ro  SalveazƒÉ »ôi reia automat progresul redƒÉrii videoclipurilor pe YouTube fƒÉrƒÉ a fi nevoie sƒÉ te conectezi.
// @description:be  –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–±–µ—Ä—ñ–≥–∞—î —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª—é—î –ø—Ä–æ–≥—Ä–µ—Å –≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤—ñ–¥–µ–æ –Ω–∞ YouTube –±–µ–∑ –≤—Ö–æ–¥—É –≤ –∞–∫–∞—É–Ω—Ç.
// @description:bg  –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞–ø–∏—Å–≤–∞ –∏ –≤—ä–∑–æ–±–Ω–æ–≤—è–≤–∞ –ø—Ä–æ–≥—Ä–µ—Å–∞ –Ω–∞ –≤–∏–¥–µ–æ—Ç–æ –≤ YouTube –±–µ–∑ –Ω—É–∂–¥–∞ –æ—Ç –≤—Ö–æ–¥.
// @description:el  ŒëœÄŒøŒ∏Œ∑Œ∫ŒµœçŒµŒπ Œ∫Œ±Œπ œÉœÖŒΩŒµœáŒØŒ∂ŒµŒπ Œ±œÖœÑœåŒºŒ±œÑŒ± œÑŒ∑ŒΩ œÄœÅœåŒøŒ¥Œø Œ±ŒΩŒ±œÄŒ±œÅŒ±Œ≥œâŒ≥ŒÆœÇ Œ≤ŒØŒΩœÑŒµŒø œÉœÑŒø YouTube œáœâœÅŒØœÇ ŒΩŒ± œáœÅŒµŒπŒ¨Œ∂ŒµœÑŒ±Œπ œÉœçŒΩŒ¥ŒµœÉŒ∑.
// @description:sr  –ê—É—Ç–æ–º–∞—Ç—Å–∫–∏ —á—É–≤–∞ –∏ –Ω–∞—Å—Ç–∞–≤—ô–∞ –Ω–∞–ø—Ä–µ–¥–∞–∫ —Ä–µ–ø—Ä–æ–¥—É–∫—Ü–∏—ò–µ –≤–∏–¥–µ–æ –∑–∞–ø–∏—Å–∞ –Ω–∞ YouTube-—É –±–µ–∑ –ø—Ä–∏—ò–∞–≤—ô–∏–≤–∞—ö–∞.
// @description:hr  Automatski sprema i nastavlja napredak reprodukcije videozapisa na YouTubeu bez prijave.
// @description:sl  Samodejno shrani in nadaljuje napredek predvajanja videoposnetkov na YouTubu brez prijave.
// @description:lt  Automati≈°kai i≈°saugo ir atnaujina YouTube vaizdo ƒØra≈°≈≥ atk≈´rimo pa≈æangƒÖ be prisijungimo.
// @description:lv  AutomƒÅtiski saglabƒÅ un atsƒÅk video atska≈Üo≈°anas progresu YouTube bez pieteik≈°anƒÅs.
// @description:uk  –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–±–µ—Ä—ñ–≥–∞—î —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª—é—î –ø—Ä–æ–≥—Ä–µ—Å –≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤—ñ–¥–µ–æ –Ω–∞ YouTube –±–µ–∑ –≤—Ö–æ–¥—É –≤ –∞–∫–∞—É–Ω—Ç.
// @description:ru  –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏ –≤–æ–∑–æ–±–Ω–æ–≤–ª—è–µ—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –≤–∏–¥–µ–æ –Ω–∞ YouTube –±–µ–∑ –≤—Ö–æ–¥–∞ –≤ –∞–∫–∫–∞—É–Ω—Ç.
// @description:tr  YouTube'daki video oynatma ilerlemesini otomatik olarak kaydeder ve devam ettirir, giri≈ü yapmaya gerek yok.
// @description:ar  ŸäŸÇŸàŸÖ ÿ®ÿ≠ŸÅÿ∏ Ÿàÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ ÿ™ŸÇÿØŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ ÿπŸÑŸâ ŸäŸàÿ™ŸäŸàÿ® ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ÿØŸàŸÜ ÿßŸÑÿ≠ÿßÿ¨ÿ© ŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ.
// @description:fa  Ÿæ€åÿ¥ÿ±ŸÅÿ™ ŸæÿÆÿ¥ Ÿà€åÿØ€åŸàŸáÿß ÿØÿ± €åŸàÿ™€åŸàÿ® ÿ±ÿß ÿ®Ÿá ÿµŸàÿ±ÿ™ ÿÆŸàÿØ⁄©ÿßÿ± ÿ∞ÿÆ€åÿ±Ÿá Ÿà ÿßÿØÿßŸÖŸá ŸÖ€å‚ÄåÿØŸáÿØ ÿ®ÿØŸàŸÜ ŸÜ€åÿßÿ≤ ÿ®Ÿá Ÿàÿ±ŸàÿØ.
// @description:he  ◊©◊ï◊û◊® ◊ï◊û◊ó◊ì◊© ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊ê◊™ ◊î◊™◊ß◊ì◊û◊ï◊™ ◊î◊†◊ô◊í◊ï◊ü ◊©◊ú ◊°◊®◊ò◊ï◊†◊ô◊ù ◊ë◊ô◊ï◊ò◊ô◊ï◊ë ◊ú◊ú◊ê ◊¶◊ï◊®◊ö ◊ë◊î◊™◊ó◊ë◊®◊ï◊™.
// @description:hi  YouTube ‡§™‡§∞ ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§™‡•ç‡§≤‡•á‡§¨‡•à‡§ï ‡§ï‡•Ä ‡§™‡•ç‡§∞‡§ó‡§§‡§ø ‡§ï‡•ã ‡§∏‡•ç‡§µ‡§ö‡§æ‡§≤‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§∏‡§π‡•á‡§ú‡•á‡§Ç ‡§î‡§∞ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§æ‡§∞‡§Ç‡§≠ ‡§ï‡§∞‡•á‡§Ç, ‡§≤‡•â‡§ó‡§ø‡§® ‡§ï‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ ‡§®‡§π‡•Ä‡§Ç‡•§ 
// @description:bn  YouTube ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶™‡ßç‡¶≤‡ßá‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶∞ ‡¶Ö‡¶ó‡ßç‡¶∞‡¶ó‡¶§‡¶ø ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£ ‡¶è‡¶¨‡¶Ç ‡¶™‡ßÅ‡¶®‡¶∞‡¶æ‡¶Ø‡¶º ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®, ‡¶≤‡¶ó‡¶á‡¶®‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶® ‡¶®‡ßá‡¶á‡•§ 
// @description:te  YouTube ‡∞µ‡±Ä‡∞°‡∞ø‡∞Ø‡±ã ‡∞™‡±ç‡∞≤‡±á‡∞¨‡±ç‡∞Ø‡∞æ‡∞ï‡±ç ‡∞™‡±Å‡∞∞‡±ã‡∞ó‡∞§‡∞ø‡∞®‡∞ø ‡∞Ü‡∞ü‡±ã‡∞Æ‡±á‡∞ü‡∞ø‡∞ï‡±ç‚Äå‡∞ó‡∞æ ‡∞∏‡±á‡∞µ‡±ç ‡∞ö‡±á‡∞∏‡∞ø, ‡∞§‡∞ø‡∞∞‡∞ø‡∞ó‡∞ø ‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø, ‡∞≤‡∞æ‡∞ó‡∞ø‡∞®‡±ç ‡∞Ö‡∞µ‡∞∏‡∞∞‡∞Ç ‡∞≤‡±á‡∞¶‡±Å.
// @description:ta  YouTube ‡Æµ‡ØÄ‡Æü‡Æø‡ÆØ‡Øã‡Æï‡Øç‡Æï‡Æ≥‡Æø‡Æ©‡Øç ‡Æ™‡Æø‡Æ≥‡Øá‡Æ™‡Ææ‡Æï‡Øç ‡ÆÆ‡ØÅ‡Æ©‡Øç‡Æ©‡Øá‡Æ±‡Øç‡Æ±‡Æ§‡Øç‡Æ§‡Øà ‡Æ§‡Ææ‡Æ©‡Ææ‡Æï‡Æö‡Øç ‡Æö‡Øá‡ÆÆ‡Æø‡Æ§‡Øç‡Æ§‡ØÅ ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç, ‡Æâ‡Æ≥‡Øç‡Æ®‡ØÅ‡Æ¥‡Øà‡Æµ‡ØÅ ‡Æ§‡Øá‡Æµ‡Øà‡ÆØ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà.
// @description:mr  YouTube ‡§µ‡•ç‡§π‡§ø‡§°‡§ø‡§ì ‡§™‡•ç‡§≤‡•á‡§¨‡•Ö‡§ï ‡§™‡•ç‡§∞‡§ó‡§§‡•Ä ‡§Ü‡§™‡•ã‡§Ü‡§™ ‡§ú‡§§‡§® ‡§ï‡§∞‡§§‡•á ‡§Ü‡§£‡§ø ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§∏‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§§‡•á, ‡§≤‡•â‡§ó‡§ø‡§® ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§®‡§æ‡§π‡•Ä.
// @description:zh-CN Ëá™Âä®‰øùÂ≠òÂπ∂ÊÅ¢Â§ç YouTube ËßÜÈ¢ëÁöÑÊí≠ÊîæËøõÂ∫¶ÔºåÊó†ÈúÄÁôªÂΩï„ÄÇ
// @description:zh-TW  Ëá™ÂãïÂÑ≤Â≠òÂèäÁπºÁ∫å YouTube ÂΩ±ÁâáÊí≠ÊîæÈÄ≤Â∫¶ÔºåÁÑ°ÈúÄÁôªÂÖ•„ÄÇ
// @description:zh-HK  Ëá™ÂãïÂÑ≤Â≠òÂèäÁπºÁ∫å YouTube ÂΩ±ÁâáÊí≠ÊîæÈÄ≤Â∫¶ÔºåÁÑ°ÈúÄÁôªÂÖ•„ÄÇ
// @description:ja  YouTube „ÅÆÂãïÁîªÂÜçÁîü„ÅÆÈÄ≤Ë°åÁä∂Ê≥Å„ÇíËá™Âãï„Åß‰øùÂ≠ò„ÉªÂÜçÈñã„Åó„Åæ„Åô„ÄÇ„É≠„Ç∞„Ç§„É≥„ÅØ‰∏çË¶Å„Åß„Åô„ÄÇ
// @description:ko  YouTube ÎèôÏòÅÏÉÅ Ïû¨ÏÉù ÏßÑÌñâ ÏÉÅÌô©ÏùÑ ÏûêÎèôÏúºÎ°ú Ï†ÄÏû•ÌïòÍ≥† Ïù¥Ïñ¥ÏÑú Ïû¨ÏÉùÌï©ÎãàÎã§. Î°úÍ∑∏Ïù∏ Î∂àÌïÑÏöî.
// @description:th  ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ö‡∏ô YouTube ‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö.
// @description:vi  T·ª± ƒë·ªông l∆∞u v√† ti·∫øp t·ª•c ti·∫øn tr√¨nh ph√°t video tr√™n YouTube m√† kh√¥ng c·∫ßn ƒëƒÉng nh·∫≠p.
// @description:id  Menyimpan dan melanjutkan kemajuan pemutaran video di YouTube secara otomatis tanpa perlu login.
// @description:ms  Menyimpan dan menyambung semula kemajuan main balik video di YouTube secara automatik tanpa perlu log masuk.
// @description:tl  Awtomatikong ini-save at ipinagpapatuloy ang progreso ng video playback sa YouTube nang hindi nagla-log in.
// @description:my  YouTube ·Äó·ÄÆ·Äí·ÄÆ·Äö·Ä≠·ÄØ·Äñ·Äú·Ä±·Ä∑·Äò·ÄÄ·Ä∫ ·Äê·Ä≠·ÄØ·Ä∏·Äê·ÄÄ·Ä∫·Äô·Äæ·ÄØ·ÄÄ·Ä≠·ÄØ ·Ä°·Äú·Ä≠·ÄØ·Ä°·Äú·Äª·Ä±·Ä¨·ÄÄ·Ä∫ ·Äû·Ä≠·Äô·Ä∫·Ä∏·ÄÜ·Ää·Ä∫·Ä∏·Äï·Äº·ÄÆ·Ä∏ ·Äë·Äï·Ä∫·Äô·Ä∂·ÄÖ·Äê·ÄÑ·Ä∫·Äî·Ä≠·ÄØ·ÄÑ·Ä∫·Äû·Ää·Ä∫·Åã ·Äù·ÄÑ·Ä∫·Äõ·Ä±·Ä¨·ÄÄ·Ä∫·Äõ·Äî·Ä∫ ·Äô·Äú·Ä≠·ÄØ·Ä°·Äï·Ä∫·Äï·Ä´·Åã
// @description:sw  Hifadhi na endelea kwa kiotomatiki maendeleo ya uchezaji wa video kwenye YouTube bila kuingia.
// @description:am  ·â†YouTube ·àã·ã≠ ·ã®·â™·ã≤·ãÆ ·àò·å´·ãà·âª ·ä•·ãµ·åà·âµ·äï ·â†·à´·à± ·ã´·àµ·âÄ·àù·å£·àç ·ä•·äì ·ã´·âÄ·å•·àã·àç ·â†·àò·åç·â£·âµ ·ã´·àµ·çà·àç·åã·àç·ç¢
// @description:ha  Ajiye kuma ci gaba da ci gaban kallon bidiyo a YouTube ta atomatik ba tare da shiga ba.
// @description:ur  YouTube Ÿæÿ± Ÿà€å⁄à€åŸàÿ≤ ⁄©€å ŸæŸÑ€í ÿ®€å⁄© ⁄©€å Ÿæ€åÿ¥ ÿ±ŸÅÿ™ ⁄©Ÿà ÿÆŸàÿØ⁄©ÿßÿ± ÿ∑ÿ±€åŸÇ€í ÿ≥€í ŸÖÿ≠ŸÅŸàÿ∏ ÿßŸàÿ± ÿØŸàÿ®ÿßÿ±€Å ÿ¥ÿ±Ÿàÿπ ⁄©ÿ±€å⁄∫ÿå ŸÑÿß⁄Ø ÿßŸÜ ⁄©€å ÿ∂ÿ±Ÿàÿ±ÿ™ ŸÜ€Å€å⁄∫€î 
// @description:ca  Desa i repr√®n autom√†ticament el progr√©s de reproducci√≥ de v√≠deos a YouTube sense necessitat d'iniciar sessi√≥.
// @description:zu  Igcina futhi uqhubeke ngokuzenzakalelayo nokuqhubeka kwevidiyo ku-YouTube ngaphandle kokungena.
// @description:yue  Ëá™ÂãïÂÑ≤Â≠òÂèäÁπºÁ∫å YouTube ÂΩ±ÁâáÊí≠ÊîæÈÄ≤Â∫¶ÔºåÁÑ°ÈúÄÁôªÂÖ•„ÄÇ
// @description:es-419  Guarda y reanuda autom√°ticamente el progreso de reproducci√≥n de videos en YouTube sin necesidad de iniciar sesi√≥n.
// @homepage     https://github.com/Alplox/Youtube-Playback-Plox
// @supportURL   https://github.com/Alplox/Youtube-Playback-Plox/issues
// @version      0.0.7
// @author       Alplox
// @match        https://www.youtube.com/*
// @icon         https://raw.githubusercontent.com/Alplox/StartpagePlox/refs/heads/main/assets/favicon/favicon.ico
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_registerMenuCommand
// @grant        GM_xmlhttpRequest
// @run-at       document-end
// @namespace    youtube-playback-plox
// @license      MIT
// @downloadURL  https://raw.githubusercontent.com/Alplox/Youtube-Playback-Plox/refs/heads/main/youtube-playback-plox.user.js
// @updateURL    https://raw.githubusercontent.com/Alplox/Youtube-Playback-Plox/refs/heads/main/youtube-playback-plox.meta.js
// @require      https://update.greasyfork.org/scripts/549881/1684270/YouTube%20Helper%20API.js
// ==/UserScript==

// ------------------------------------------
// MARK: üîç SISTEMA DE LOGGING
// ------------------------------------------

(function () {
    'use strict';

    // 1. Determinar si el modo debug est√° activo
    const DEBUG = true; // Cambiar a 'false' para desactivar los logs de depuraci√≥n en producci√≥n

    // 2. Crear el objeto del logger en el √°mbito global (window)
    window.MyScriptLogger = {
        log: (context, ...args) => {
            if (DEBUG) {
                console.log(`%c[${context}]`, 'color: #6a9955;', ...args);
            }
        },
        warn: (context, ...args) => {
            if (DEBUG) {
                console.warn(`%c[${context}]`, 'color: #ce9178; font-weight: bold;', ...args);
            }
        },
        error: (context, ...args) => {
            // Los errores siempre se muestran
            console.error(`%c[${context}]`, 'color: #f44747; font-weight: bold;', ...args);
        }
    };

})();

// Atajo para no tener que escribir window.MyScriptLogger cada vez
const { log, warn, error: conError } = window.MyScriptLogger;

// --- INICIO CARGA L√ìGICA PRINCIPAL DEL USERSCRIPT ---

(() => {
    'use strict';

    // ------------------------------------------
    // MARK: üåê Carga de Traducciones
    // ------------------------------------------

    // URL del archivo de traducciones
    const TRANSLATIONS_URL = 'https://raw.githubusercontent.com/Alplox/Youtube-Playback-Plox/refs/heads/main/translations.json';
    const TRANSLATIONS_URL_BACKUP = 'https://cdn.jsdelivr.net/gh/Alplox/Youtube-Playback-Plox@refs/heads/main/translations.json';

    // Variables globales para las traducciones
    let TRANSLATIONS = {};
    let LANGUAGE_FLAGS = {};

    // Traducciones b√°sicas de fallback en caso de error
    const FALLBACK_FLAGS = {
        "en-US": {
            "emoji": "üá∫üá∏",
            "code": "en-US",
            "name": "English (US)"
        },
        "es-ES": {
            "emoji": "üá™üá∏",
            "code": "es-ES",
            "name": "Espa√±ol"
        },
        "fr": {
            "emoji": "üá´üá∑",
            "code": "fr",
            "name": "Fran√ßais"
        }
    };

    const FALLBACK_TRANSLATIONS = {
        "en-US": {
            "settings": "Settings",
            "savedVideos": "View saved videos",
            "close": "Close",
            "save": "Save",
            "cancel": "Cancel",
            "delete": "Delete",
            "undo": "Undo",
            "enableSavingFor": "Enable saving for",
            "regularVideos": "Regular videos",
            "shorts": "Shorts",
            "liveStreams": "Live streams",
            "showNotifications": "Show save notifications",
            "minSecondsBetweenSaves": "Minimum seconds between saves",
            "showFloatingButton": "Show floating button",
            "language": "Language",
            "alertStyle": "Alert style in playback bar",
            "alertIconText": "Icon + Text",
            "alertIconOnly": "Icon Only",
            "alertTextOnly": "Text Only",
            "alertHidden": "Hidden",
            "noSavedVideos": "No saved videos.",
            "sortBy": "Sort by",
            "mostRecent": "Most recent",
            "oldest": "Oldest",
            "titleAZ": "Title (A-Z)",
            "filterByType": "Filter by type",
            "all": "All",
            "videos": "Videos",
            "playlist": "Playlist",
            "searchByTitleOrAuthor": "Search by title or author...",
            "export": "Export",
            "import": "Import",
            "progressSaved": "Progress saved",
            "dataExported": "Data exported",
            "itemsImported": "Imported {count} items",
            "importError": "Error importing. Make sure the file is valid.",
            "configurationSaved": "Configuration saved",
            "startTimeSet": "Start time set to",
            "fixedTimeRemoved": "Fixed time removed.",
            "itemDeleted": "deleted.",
            "unknownError": "Unknown error",
            "modulesFailed": "{count} module(s) failed: {names}",
            "retryNow": "Retry now",
            "retryCompleted": "Retry completed",
            "progress": "Progress",
            "alwaysStartFrom": "Always start from",
            "resumedAt": "Resumed at",
            "percentWatched": "% watched",
            "remaining": "remaining",
            "setStartTime": "Set start time",
            "changeOrRemoveStartTime": "Always start from {time} (Click to change or remove)",
            "enterStartTime": "Enter the start time you always want to use (example: 1:23)",
            "enterStartTimeOrEmpty": "Enter the start time you always want to use (example: 1:23) or leave empty to remove",
            "deleteEntry": "Delete entry",
            "youtubePlaybackPlox": "YouTube Playback Plox",
            "playlistPrefix": "Playlist",
            "unknown": "Unknown",
            "notAvailable": "N/A",
            "clearAll": "Clear all",
            "clearAllConfirm": "Are you sure you want to delete ALL saved videos? This action can be undone.",
            "allItemsCleared": "All items cleared",
            "undoClearAll": "Undo",
            "viewAllHistory": "View all history",
            "viewCompletedVideos": "View completed videos",
            "completed": "Completed",
            "completedVideos": "Completed videos",
            "videosWithFixedTime": "Videos with fixed time",
            "views": "Views",
            "enableProgressBarGradient": "Enable color gradient in progress bar",
            "staticFinishPercent": "Percentage to mark video as completed",
            "openChannel": "Open channel",
            "openPlaylist": "Open playlist",
            "createPlaylist": "Create playlist",
            "selectVideos": "Select videos",
            "selectedVideos": "Selected videos",
            "generatePlaylistLink": "Generate playlist link",
            "playlistLinkGenerated": "Playlist link generated",
            "copyLink": "Copy link",
            "linkCopied": "Link copied to clipboard",
            "selectAtLeastOne": "Select at least one video",
            "tooManyVideos": "Too many videos selected (max 200)"
        },
        "es-ES": {
            "settings": "Configuraci√≥n",
            "savedVideos": "Ver videos guardados",
            "close": "Cerrar",
            "save": "Guardar",
            "cancel": "Cancelar",
            "delete": "Eliminar",
            "undo": "Deshacer",
            "enableSavingFor": "Activar guardado para",
            "regularVideos": "Videos regulares",
            "shorts": "Shorts",
            "liveStreams": "Directos (Livestreams)",
            "showNotifications": "Mostrar notificaciones de guardado",
            "minSecondsBetweenSaves": "Intervalo segundos m√≠nimos entre guardados",
            "showFloatingButton": "Mostrar bot√≥n flotante",
            "language": "Idioma",
            "alertStyle": "Estilo de alertas en la barra de reproducci√≥n",
            "alertIconText": "Icono + Texto",
            "alertIconOnly": "Solo Icono",
            "alertTextOnly": "Solo Texto",
            "alertHidden": "Oculto",
            "noSavedVideos": "No hay videos guardados.",
            "sortBy": "Ordenar por",
            "mostRecent": "M√°s recientes",
            "oldest": "M√°s antiguos",
            "titleAZ": "T√≠tulo (A-Z)",
            "filterByType": "Filtrar por tipo",
            "all": "Todos",
            "videos": "Videos",
            "playlist": "Playlist",
            "searchByTitleOrAuthor": "Buscar por t√≠tulo o autor...",
            "export": "Exportar",
            "import": "Importar",
            "progressSaved": "Progreso guardado",
            "dataExported": "Datos exportados",
            "itemsImported": "Importados {count} elementos",
            "importError": "Error al importar. Aseg√∫rate de que el archivo sea v√°lido.",
            "configurationSaved": "Configuraci√≥n guardada",
            "startTimeSet": "Tiempo de inicio establecido en",
            "fixedTimeRemoved": "Tiempo fijo eliminado.",
            "itemDeleted": "eliminado.",
            "unknownError": "Error desconocido",
            "modulesFailed": "{count} m√≥dulo(s) fallaron: {names}",
            "retryNow": "Reintentar ahora",
            "retryCompleted": "Reintentos completados",
            "progress": "Progreso",
            "alwaysStartFrom": "Siempre desde",
            "resumedAt": "Reanudado en",
            "percentWatched": "% visto",
            "remaining": "restantes",
            "setStartTime": "Establecer tiempo de inicio",
            "changeOrRemoveStartTime": "Siempre empezar en {time} (Click para cambiar o eliminar)",
            "enterStartTime": "Introduce el tiempo de inicio que siempre quieres usar (ejemplo: 1:23)",
            "enterStartTimeOrEmpty": "Introduce el tiempo de inicio que siempre quieres usar (ejemplo: 1:23) o deja vac√≠o para eliminar",
            "deleteEntry": "Eliminar entrada",
            "youtubePlaybackPlox": "YouTube Playback Plox",
            "playlistPrefix": "Playlist",
            "unknown": "Desconocido",
            "notAvailable": "N/A",
            "clearAll": "Eliminar todo",
            "clearAllConfirm": "¬øEst√°s seguro de que quieres eliminar TODOS los videos guardados? Esta acci√≥n se puede deshacer.",
            "allItemsCleared": "Todos los elementos eliminados",
            "undoClearAll": "Deshacer",
            "viewAllHistory": "Ver todo el historial",
            "viewCompletedVideos": "Ver videos completados",
            "completed": "Completado",
            "completedVideos": "Videos completados",
            "videosWithFixedTime": "Videos con tiempo fijo",
            "views": "Vistas",
            "enableProgressBarGradient": "Habilitar degradado de colores en barra de progreso",
            "staticFinishPercent": "Porcentaje para marcar video como completado",
            "openChannel": "Abrir canal",
            "openPlaylist": "Abrir playlist",
            "createPlaylist": "Crear playlist",
            "selectVideos": "Seleccionar videos",
            "selectedVideos": "Videos seleccionados",
            "generatePlaylistLink": "Generar enlace de playlist",
            "playlistLinkGenerated": "Enlace de playlist generado",
            "copyLink": "Copiar enlace",
            "linkCopied": "Enlace copiado al portapapeles",
            "selectAtLeastOne": "Selecciona al menos un video",
            "tooManyVideos": "Demasiados videos seleccionados (m√°x 200)"
        },
        "fr": {
            "settings": "Param√®tres",
            "savedVideos": "Voir les vid√©os enregistr√©es",
            "close": "Fermer",
            "save": "Enregistrer",
            "cancel": "Annuler",
            "delete": "Supprimer",
            "undo": "Annuler",
            "enableSavingFor": "Activer la sauvegarde pour",
            "regularVideos": "Vid√©os r√©guli√®res",
            "shorts": "Shorts",
            "liveStreams": "Diffusions en direct",
            "showNotifications": "Afficher les notifications de sauvegarde",
            "minSecondsBetweenSaves": "Secondes minimales entre les sauvegardes",
            "showFloatingButton": "Afficher le bouton flottant",
            "language": "Langue",
            "alertStyle": "Style d'alerte dans la barre de lecture",
            "alertIconText": "Ic√¥ne + Texte",
            "alertIconOnly": "Ic√¥ne uniquement",
            "alertTextOnly": "Texte uniquement",
            "alertHidden": "Masqu√©",
            "noSavedVideos": "Aucune vid√©o enregistr√©e.",
            "sortBy": "Trier par",
            "mostRecent": "Plus r√©cent",
            "oldest": "Plus ancien",
            "titleAZ": "Titre (A-Z)",
            "filterByType": "Filtrer par type",
            "all": "Tous",
            "videos": "Vid√©os",
            "playlist": "Playlist",
            "searchByTitleOrAuthor": "Rechercher par titre ou auteur...",
            "export": "Exporter",
            "import": "Importer",
            "progressSaved": "Progr√®s enregistr√©",
            "dataExported": "Donn√©es export√©es",
            "itemsImported": "{count} √©l√©ments import√©s",
            "importError": "Erreur lors de l'importation. Assurez-vous que le fichier est valide.",
            "configurationSaved": "Configuration enregistr√©e",
            "startTimeSet": "Heure de d√©but d√©finie √†",
            "fixedTimeRemoved": "Heure fixe supprim√©e.",
            "itemDeleted": "supprim√©.",
            "unknownError": "Erreur inconnue",
            "modulesFailed": "{count} module(s) ont √©chou√© : {names}",
            "retryNow": "R√©essayer maintenant",
            "retryCompleted": "R√©essais termin√©s",
            "progress": "Progr√®s",
            "alwaysStartFrom": "Toujours commencer √†",
            "resumedAt": "Repris √†",
            "percentWatched": "% regard√©",
            "remaining": "restant",
            "setStartTime": "D√©finir l'heure de d√©but",
            "changeOrRemoveStartTime": "Toujours commencer √† {time} (Cliquez pour changer ou supprimer)",
            "enterStartTime": "Entrez l'heure de d√©but que vous souhaitez toujours utiliser (exemple: 1:23)",
            "enterStartTimeOrEmpty": "Entrez l'heure de d√©but que vous souhaitez toujours utiliser (exemple: 1:23) ou laissez vide pour supprimer",
            "deleteEntry": "Supprimer l'entr√©e",
            "youtubePlaybackPlox": "YouTube Playback Plox",
            "playlistPrefix": "Playlist",
            "unknown": "Inconnu",
            "notAvailable": "N/A",
            "clearAll": "Tout effacer",
            "clearAllConfirm": "√ätes-vous s√ªr de vouloir supprimer TOUTES les vid√©os enregistr√©es ? Cette action peut √™tre annul√©e.",
            "allItemsCleared": "Tous les √©l√©ments effac√©s",
            "undoClearAll": "Annuler",
            "viewAllHistory": "Voir tout l'historique",
            "viewCompletedVideos": "Voir les vid√©os termin√©es",
            "completed": "Termin√©",
            "completedVideos": "Vid√©os termin√©es",
            "videosWithFixedTime": "Vid√©os avec un temps fixe",
            "views": "Vues",
            "enableProgressBarGradient": "Activer le d√©grad√© de couleurs dans la barre de progression",
            "staticFinishPercent": "Pourcentage pour marquer la vid√©o comme termin√©e",
            "openChannel": "Ouvrir la cha√Æne",
            "openPlaylist": "Ouvrir la playlist",
            "createPlaylist": "Cr√©er une playlist",
            "selectVideos": "S√©lectionner des vid√©os",
            "selectedVideos": "Vid√©os s√©lectionn√©es",
            "generatePlaylistLink": "G√©n√©rer le lien de la playlist",
            "playlistLinkGenerated": "Lien de la playlist g√©n√©r√©",
            "copyLink": "Copier le lien",
            "linkCopied": "Lien copi√© dans le presse-papiers",
            "selectAtLeastOne": "S√©lectionnez au moins une vid√©o",
            "tooManyVideos": "Trop de vid√©os s√©lectionn√©es (max 200)"
        }
    };

    // Funci√≥n para cargar las traducciones desde el archivo JSON externo
    async function loadTranslations() {
        return new Promise((resolve) => {
            // Funci√≥n para intentar cargar desde una URL espec√≠fica
            function tryLoadFromUrl(url, isSecondAttempt = false) {
                GM_xmlhttpRequest({
                    method: 'GET',
                    url: url,
                    timeout: 5000,
                    onload: function (response) {
                        try {
                            const data = JSON.parse(response.responseText);

                            if (data.LANGUAGE_FLAGS && Object.keys(data.LANGUAGE_FLAGS).length > 0 &&
                                data.TRANSLATIONS && Object.keys(data.TRANSLATIONS).length > 0) {
                                log('loadTranslations', 'Traducciones externas cargadas correctamente desde: ' + url);
                                resolve(data);
                            } else {
                                if (!isSecondAttempt) {
                                    conError('loadTranslations', 'No se pudieron cargar las traducciones desde el primer enlace, intentando con el segundo...');
                                    tryLoadFromUrl(TRANSLATIONS_URL_BACKUP, true);
                                } else {
                                    conError('loadTranslations', 'No se pudieron cargar las traducciones desde ning√∫n enlace, usando fallback');
                                    resolve({
                                        LANGUAGE_FLAGS: FALLBACK_FLAGS,
                                        TRANSLATIONS: FALLBACK_TRANSLATIONS
                                    });
                                }
                            }
                        } catch (error) {
                            conError('loadTranslations', 'Error al procesar el archivo de traducciones desde ' + url + ':', error);
                            if (!isSecondAttempt) {
                                warn('loadTranslations', 'Intentando con el segundo enlace de traducciones...');
                                tryLoadFromUrl(TRANSLATIONS_URL_BACKUP, true);
                            } else {
                                resolve({
                                    LANGUAGE_FLAGS: FALLBACK_FLAGS,
                                    TRANSLATIONS: FALLBACK_TRANSLATIONS
                                });
                            }
                        }
                    },
                    onerror: function (error) {
                        conError('loadTranslations', 'Error al cargar el archivo de traducciones desde ' + url + ':', error);
                        if (!isSecondAttempt) {
                            warn('loadTranslations', 'Intentando con el segundo enlace de traducciones...');
                            tryLoadFromUrl(TRANSLATIONS_URL_BACKUP, true);
                        } else {
                            resolve({
                                LANGUAGE_FLAGS: FALLBACK_FLAGS,
                                TRANSLATIONS: FALLBACK_TRANSLATIONS
                            });
                        }
                    },
                    ontimeout: function () {
                        conError('loadTranslations', 'Timeout al cargar el archivo de traducciones desde ' + url);
                        if (!isSecondAttempt) {
                            warn('loadTranslations', 'Intentando con el segundo enlace de traducciones...');
                            tryLoadFromUrl(TRANSLATIONS_URL_BACKUP, true);
                        } else {
                            resolve({
                                LANGUAGE_FLAGS: FALLBACK_FLAGS,
                                TRANSLATIONS: FALLBACK_TRANSLATIONS
                            });
                        }
                    }
                });
            }

            // Iniciar el proceso con el primer enlace
            tryLoadFromUrl(TRANSLATIONS_URL);
        });
    }

    // ------------------------------------------
    // MARK: üì¶ Config
    // ------------------------------------------

    const CONFIG = {
        /** Diferencia m√≠nima (en segundos) para considerar un cambio de posici√≥n como v√°lido */
        minSeekDiff: 1.5,

        /** Prefijo para claves en localStorage */
        storagePrefix: 'YT_PLAYBACK_PLOX_',

        /** Enumeraci√≥n de estilos de alerta */
        alertStylesSettings: {
            icon_only: 'iconOnly',
            text_only: 'textOnly',
            icon_and_text: 'iconText',
            no_icon_no_text: 'hidden'
        },

        /** Clave para guardar configuraciones del usuario en GM_* */
        userSettingsKey: 'YT_PLAYBACK_PLOX_userSettings',

        /** Valores predeterminados para configuraciones del usuario */
        defaultSettings: {
            showNotifications: true,
            minSecondsBetweenSaves: 1,
            showFloatingButtons: false,
            saveRegularVideos: true, // Por defecto, guardar videos regulares
            saveShorts: false, // Por defecto, no guardar Shorts
            saveLiveStreams: false, // Por defecto, no guardar directos de URL tipo /live, si es /watch lo toma como regular
            language: 'en-US', // Idioma predeterminado
            alertStyle: 'iconText', // Estilo de alerta predeterminado
            enableProgressBarGradient: true, // Por defecto, habilitar degradado de colores en barra de progreso
            staticFinishPercent: 95, // Porcentaje desde el final para considerar video como completado (95% = 5% antes del final)
        },

        /** Clave para guardar filtros del usuario en GM_* */
        userFiltersKey: 'YT_PLAYBACK_PLOX_userFilters',

        /** Valores predeterminados para filtros del usuario */
        defaultFilters: {
            orderBy: "recent",
            filterBy: "all",
            searchQuery: ""
        }
    };

    // ------------------------------------------
    // MARK: üåê Funciones de traducci√≥n
    // ------------------------------------------

    let currentLanguage = CONFIG.defaultSettings.language; // Idioma predeterminado

    // Funci√≥n para obtener el texto traducido
    function t(key, params = {}) {
        if (!TRANSLATIONS[currentLanguage] || !TRANSLATIONS[currentLanguage][key]) {
            // Si no hay traducci√≥n, intentar con ingl√©s
            if (TRANSLATIONS.en && TRANSLATIONS.en[key]) {
                return replaceParams(TRANSLATIONS.en[key], params);
            }
            // Si no hay ni en ingl√©s, devolver la clave
            return key;
        }
        return replaceParams(TRANSLATIONS[currentLanguage][key], params);
    }

    // Funci√≥n para reemplazar par√°metros en las traducciones
    function replaceParams(text, params) {
        if (!text || typeof text !== 'string') return text;
        return text.replace(/{(\w+)}/g, (match, param) => {
            return params[param] !== undefined ? params[param] : match;
        });
    }

    // Funci√≥n para cambiar el idioma
    async function setLanguage(lang) {
        log('setLanguage', 'lang que llega:', lang);
        let validLang = lang;

        if (!TRANSLATIONS[validLang]) {
            const primary = lang.split('-')[0];
            validLang = Object.keys(TRANSLATIONS).find(k => k === primary || k.startsWith(primary + '-'));
        }

        if (!validLang) validLang = CONFIG.defaultSettings.language;

        currentLanguage = validLang;

        const settings = await Settings.get();
        settings.language = validLang;
        await Settings.set(settings);

        log('setLanguage', 'lang que sale:', validLang);
        return true;
    }

    // Funci√≥n para detectar el idioma del navegador
    function detectBrowserLanguage() {
        const browserLang = navigator.language || navigator.userLanguage; // "es-ES" o "en"
        log('detectBrowserLanguage', 'browserLang:', browserLang);

        // Coincidencia exacta
        log('detectBrowserLanguage', 'TRANSLATIONS[browserLang]:', TRANSLATIONS[browserLang])
        if (TRANSLATIONS[browserLang]) return browserLang;

        // Coincidencia por prefijo (ejemplo: "es" -> "es-ES" o "es-419")
        const primary = browserLang.split('-')[0];
        const matched = Object.keys(TRANSLATIONS).find(k => k === primary || k.startsWith(primary + '-'));
        log('detectBrowserLanguage', 'matched:', matched);
        if (matched) return matched;

        warn(`Idioma del navegador '${browserLang}' no soportado, usando default.`);
        return CONFIG.defaultSettings.language;
    }

    // ------------------------------------------
    // MARK: üé® Styles
    // ------------------------------------------

    function injectStyles() {
        if (document.getElementById('youtube-playback-plox-styles')) return; // evitar duplicados

        const style = document.createElement('style');
        style.id = 'youtube-playback-plox-styles';
        style.textContent = `
:root {
  /* Paleta base */
  --color-bg: #fff;
  --color-text: #222;
  --color-muted: #555;
  --color-light: #888;
  --color-link: #065fd4;
  --color-danger: #dc2626;
  --color-success: #16a34a;
  --color-success-dark: #15803d;
  --color-overlay: rgba(0, 0, 0, 0.4);
  --color-toast: #333;
  --color-primary: #2563eb;
  --color-primary-dark: #1e40af;
  --color-border: #ccc;
  --color-playlist-bg: #f0f8ff; /* Fondo sutil para items de playlist */

  /* Tipograf√≠a */
  --font-base: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;

  /* Espaciado */
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;

  /* Sombra */
  --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.2);
  --shadow-modal: 0 4px 16px rgba(0, 0, 0, 0.25);

  /* Z-index */
  --z-overlay: 9999;
  --z-modal: 10000;
  --z-toast: 10001;
}

.sombra {
    box-shadow:
        0.8px 0.8px 2.7px rgba(0, 0, 0, 0.062),
        2.1px 2.1px 6.9px rgba(0, 0, 0, 0.089),
        4.3px 4.3px 14.2px rgba(0, 0, 0, 0.111),
        8.8px 8.8px 29.2px rgba(0, 0, 0, 0.138),
        24px 24px 80px rgba(0, 0, 0, 0.2);

    -webkit-box-shadow:
        0.8px 0.8px 2.7px rgba(0, 0, 0, 0.062),
        2.1px 2.1px 6.9px rgba(0, 0, 0, 0.089),
        4.3px 4.3px 14.2px rgba(0, 0, 0, 0.111),
        8.8px 8.8px 29.2px rgba(0, 0, 0, 0.138),
        24px 24px 80px rgba(0, 0, 0, 0.2);
}

.svgFolderIcon,
.svgSaveIcon,
.svgPinIcon,
.svgTimerIcon,
.svgPlayOrPauseIcon {
  vertical-align: middle;
  height: 100%;
  margin: 0 0px 2px 0px;
}

.ypp-d-flex {
  display: flex;
}

.ypp-d-none {
    display: none !important;
}

/* =========================
   Contenedores y Overlays
========================= */

.ypp-overlay,
.ypp-modalOverlay {
  position: fixed;
  top: 0;
  left: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100vw;
  height: 100vh;
  background: var(--color-overlay);
  z-index: var(--z-overlay);
}

.ypp-videosContainer {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--ypp-bg, #0f0f0f);
  border: 1px solid var(--ypp-border, #303030);
  border-radius: 12px;
  width: 90%;
  max-width: 800px;
  max-height: 85vh;
  color: var(--ypp-text, #f1f1f1);
  box-shadow: var(--ypp-shadow, 0 12px 24px rgba(0, 0, 0, 0.5));
  z-index: var(--z-modal);
  display: flex;
  flex-direction: column;
  opacity: 0;
  transform: translate(-50%, -50%) translateY(20px) scale(0.95);
  animation: videosModalSlideIn 0.3s ease-out forwards;
}

@keyframes videosModalSlideIn {
  to {
    opacity: 1;
    transform: translate(-50%, -50%) translateY(0) scale(1);
  }
}

.ypp-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--color-bg);
  border-radius: 8px;
  box-shadow: var(--shadow-md);
  padding: 0; /* Padding manejado por hijos */
  z-index: var(--z-modal);
  width: 550px; /* Un poco m√°s ancho para los nuevos botones */
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  font-family: var(--font-base);
  color: var(--color-text);
}

.ypp-time-display {
  color: var(--color-bg);
  font-weight: bold;
  margin-left: 10px;
  font-size: 1.4rem;
  background: /* #4a4a4a91; */ hsla(0,0%,6.7%,0.4);
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: 14px;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: var(--color-success-dark);
  }
}

/* Estilo espec√≠fico para mensajes en Shorts - integrado en el player */
.ypp-shorts-time-display {
  background: hsla(109.7, 56.1%, 22.4%, 0.7);
  color: #fff;
  padding: 4px 0px;
  font-size: 13px;
  font-weight: 700;
  /* backdrop-filter: blur(10px); */
  cursor: pointer;
  transition: all 0.2s ease;
  pointer-events: auto;
  justify-content: center;
  display: flex;
  gap: 6px;
  
  /* Truncado de texto */
  white-space: nowrap;
  overflow: hidden;

  &:hover {
    background: var(--color-success-dark, #15803d);
    transform: translateY(-1px);
  }
}


/* =========================
   Header, Footer, Layout
========================= */

.ypp-header,
.ypp-modalHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 12px;
  border-bottom: 1px solid var(--color-border);
  flex-shrink: 0;
}

.ypp-filters {
  padding: var(--spacing-md) var(--spacing-lg);
  border-bottom: 1px solid var(--color-border);
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  flex-shrink: 0;
  gap: 0;
}

.ypp-footer {
  padding: var(--spacing-md) var(--spacing-lg);
  border-top: 2px solid var(--color-border);
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  z-index: 10;
  flex-shrink: 0;
}

.ypp-footer-row {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: var(--spacing-sm);
  flex-wrap: wrap;
}

.ypp-footer-row-bottom {
  justify-content: space-between;
}

#video-list-container {
  flex-grow: 1; /* Ocupar el espacio restante */
  overflow-y: auto; /* Hacer scrollable solo esta parte */
  padding: var(--spacing-md) var(--spacing-lg);
}

.ypp-settingsContent {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  max-height: 60vh;
  overflow-y: auto;
}

.ypp-btnGroup {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  gap: 12px;
  padding: 16px 24px;
  background: var(--ypp-bg, #0f0f0f);
  border-radius: 0 0 12px 12px;
  flex-shrink: 0;
  margin-top: auto;
}

.ypp-saving-options{
  display: flex;
  flex-direction: column;
  background: var(--ypp-border);
  border-radius: 6px;
  padding: 10px;
}

.ypp-container-saving-options {
  background: var(--ypp-surface);
  border-radius: 6px;
  padding: 6px;
  gap: 8px;
  display: flex;
  flex-direction: column;
  margin-bottom: 10px;

}

.ypp-label-save-type{
    margin: 0 0 0 10px
}

/* =========================
   Tipograf√≠a
========================= */

.ypp-emptyMsg {
  text-align: center;
  color: #aaa;
  padding: 40px 24px;
  font-size: 1.4rem;
}

.ypp-playlistTitle {
  margin: 8px 0 4px;
  color: #065fd4;
  cursor: pointer;
  text-decoration: none;
  display: block;
  font-size: 1.2rem;
  font-weight: 500;
}

.ypp-playlistTitle:hover {
  color: #0550b3;
  text-decoration: underline;
}

.ypp-titleLink {
  font-weight: 600;
  font-size: 1.4rem;
  color: var(--color-link);
  text-decoration: none;
  display: block;
  margin-bottom: 2px;
}

.ypp-titleLink:hover {
  text-decoration: underline;
}

.ypp-author,
.ypp-views {
  font-size: 1.1rem;
  color: var(--color-muted);
}

.ypp-author-link {
  color: var(--color-link);
  text-decoration: none;
  transition: color 0.2s;
}

.ypp-author-link:hover {
  color: var(--color-primary-dark);
  text-decoration: underline;
}

.ypp-timestamp,
.ypp-progressInfo {
  font-size: 1.3rem;
  margin-top: 4px;
  display: flex;
  align-items: center;
  gap: 4px;
}

.ypp-timestamp {
  color: var(--color-muted);
}

.ypp-timestamp.forced {
    color: var(--color-primary-dark);
    font-weight: bold;
}

.ypp-timestamp.completed {
    color: var(--color-success);
    font-weight: bold;
}

.ypp-timestamp.forced.completed {
    /* Video con tiempo fijo Y completado: color mixto */
    color: #15803d;
    font-weight: bold;
    background: linear-gradient(90deg, var(--color-primary-dark) 0%, var(--color-success) 100%);
    background-clip: text;
}

/* =========================
   Video List
========================= */

.ypp-videoWrapper {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-md);
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--spacing-sm);
}

.ypp-videoWrapper.playlist-item {
  border-radius: 6px;
  padding: var(--spacing-sm);
  margin-bottom: var(--spacing-sm);
  transition: all 0.2s ease;
}

.ypp-videoWrapper.regular-item {
  background-color: var(--color-bg-secondary);
  border-left: 4px solid var(--color-border);
}

.ypp-playlist-indicator {
  display: flex;
  align-items: center;
  margin: 4px 0;
  font-size: 0.85em;
  opacity: 1;
  background: rgba(0, 0, 0, 0.75);
  color: #ffffff;
  padding: 3px 8px;
  border-radius: 6px;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(3px);
  font-weight: 600;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.ypp-playlist-link {
  display: inline-flex;
  align-items: center;
  margin-left: 8px;
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.ypp-playlist-link:hover {
  opacity: 1;
}

/* Estilos para modo de selecci√≥n */
.ypp-videoWrapper.selection-mode {
  cursor: pointer;
  transition: all 0.2s ease;
}

.ypp-videoWrapper.selection-mode:hover {
  background-color: var(--color-bg-hover) !important;
  transform: translateX(2px);
}

.ypp-video-checkbox {
  min-width: 15px;
  margin: 0 10px;
  transform: scale(1.2);
  cursor: pointer;
}

/* Estilos para el √°rea de playlist integrada */
.ypp-playlist-creation-area {
  margin-top: 12px;
  padding: 15px;
  background-color: var(--color-bg-secondary);
  border: 1px solid var(--color-border);
  border-radius: 6px;
  display: none;
}

.ypp-playlist-creation-area.active {
  display: block;
}

.ypp-playlist-textarea {
  width: 100%;
  height: 50px;
  max-height: 40px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  line-height: 1.3;
  background-color: var(--color-bg);
  color: var(--color-text);
  resize: none;
  overflow-y: auto;
  word-wrap: break-word;
}

.ypp-playlist-actions {
  display: flex;
  gap: 10px;
  margin-top: 10px;
  justify-content: center;
}

.ypp-footer-row.hidden {
  display: none;
}

.ypp-thumb {
  max-width: 110px;
  max-height: 80px;
  object-fit: cover;
  border-radius: 4px;
  margin-right: var(--spacing-sm);
  flex-shrink: 0;
}

.ypp-infoDiv {
  flex-grow: 1;
  min-width: 0; /* Permite que el contenedor se encoja correctamente */
}

.ypp-containerButtonsTime {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: auto;
}

.ypp-sort-select, .ypp-filter-select {
  background: #1a1a1a;
  border: 1px solid #303030;
  color: #f1f1f1;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 1.3rem;
  cursor: pointer;
  transition: border-color 0.2s ease, background-color 0.2s ease;
  width: 100%;
  height: fit-content;
}

.ypp-sort-select:focus, .ypp-filter-select:focus {
  outline: none;
  border-color: #065fd4;
  background: #252525;
}

.ypp-sort-select option, .ypp-filter-select option {
  background: #1a1a1a;
  color: #f1f1f1;
}


.ypp-search-input {
  background: #1a1a1a;
  border: 1px solid #303030;
  color: #f1f1f1;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 1.3rem;
  transition: border-color 0.2s ease, background-color 0.2s ease;
  flex: 1;
  min-width: 200px;
}

.ypp-search-input:focus {
  outline: none;
  border-color: #065fd4;
  background: #252525;
}

.ypp-search-input::placeholder {
  color: #888;
}

/* =========================
   Botones
========================= */

.ypp-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 5px 14px;
  font-weight: 500;
  font-size: 1.4rem;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  border: none;
  outline: none;
  position: relative;
  overflow: hidden;
  min-height: 20px;
  gap: 8px;
}

.ypp-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.1);
  opacity: 0;
  transition: opacity 0.2s ease;
}

.ypp-btn:hover::before {
  opacity: 1;
}

.ypp-btn:active {
  transform: scale(0.98);
}

.ypp-btn {
  background: var(--color-primary);
  color: var(--ypp-text);
}

.ypp-btn:hover {
  background: var(--paper-checkbox-checked-color);
  color: var(--color-bg);
}

.ypp-btn:active {
  background: #0441a1;
}


.ypp-btn-outlined {
  background: transparent;
  border: 1px solid #065fd4;
    color: inherit;

  &:hover {
    background: rgba(6, 95, 212, 0.3);
    color: inherit;
  }
}

.ypp-save-button {
  background: transparent;
  border: 1px solid var(--color-success);
    color: inherit;

  &:hover {
    background: rgba(22, 212, 6, 0.3);
    color: inherit;
  }

  &:active {
    background: #008855;
  }
}



.ypp-btn-secondary {
  background: #f1f1f1;
  color: #0f0f0f;
}

.ypp-btn-secondary:hover {
  background: var(--color-success-dark);
  color: var(--color-bg);
}

.ypp-btn-secondary:active {
  background: #d9d9d9;
}

.ypp-btn-delete {
  background: transparent;
  border: 1px solid var(--color-danger);
  color: var(--color-danger);;
}

.ypp-btn-delete:hover {
  background: var(--color-danger);
  color: inherit;
}

.ypp-btn-delete:active {
  background: rgba(255, 68, 68, 0.2);
}


.ypp-btn-danger {
  background: #ff4444;
  color: #ffffff;
}

.ypp-btn-danger:hover {
  background: var(--error-color);
}

.ypp-btn-danger:active {
  background: #dd2222;
}

.ypp-btn-small {
    padding: 8px;
    width: 36px;
    height: 36px;
    min-height: 36px;
    flex-shrink: 0;
    border-radius: 18px;
}

.ypp-btn-close{
  background: var(--color-text);
  border: 1px solid #303030;
  color: var(--dark-theme-text-color);
}

.ypp-btn-close:hover {
background: var(--color-danger);
}





@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* =========================
   Toasts
========================= */

.ypp-toast-container {
  position: fixed;
  top: var(--spacing-md);
  right: var(--spacing-md);
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  z-index: var(--z-toast);
}

.ypp-toast {
  background: var(--ypp-bg, #0f0f0f);
  color: var(--ypp-text, #f1f1f1);
  padding: 12px 16px;
  border-radius: 8px;
  border: 1px solid var(--ypp-border, #303030);
  box-shadow: var(--ypp-shadow, 0 4px 12px rgba(0, 0, 0, 0.3));
  font-size: 1.4rem;
  max-width: 300px;
  animation: slideInRight 0.3s ease-out;
  backdrop-filter: blur(10px);
}

.ypp-toast.persistent {
  background: var(--color-muted);
  position: relative;
  padding-right: 40px;
}

.ypp-toast-close {
  position: absolute;
  top: 8px;
  right: 8px;
  background: var(--color-text);
  border: 1px solid #303030;
  color: var(--dark-theme-text-color);
  width: 24px;
  height: 24px;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background-color 0.2s ease;
  font-size: 12px;
  padding: 0;
}

.ypp-toast-close:hover {
  background: var(--color-danger);
}

.ypp-toast-action {
    background: var(--color-primary);
    border: none;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    margin-left: auto;
}

/* =========================
   Modal
========================= */

.ypp-modalOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--ypp-overlay, rgba(0, 0, 0, 0.8));
  backdrop-filter: blur(4px);
  z-index: var(--z-modal);
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.2s ease-out;
}

.ypp-modalBox {
  background: var(--ypp-bg, #0f0f0f);
  border: 1px solid var(--ypp-border, #303030);
  border-radius: 12px;
  padding: 0;
  color: var(--ypp-text, #f1f1f1);
  max-width: 500px;
  width: 90%;
  max-height: 85vh;
  overflow: hidden;
  box-shadow: var(--ypp-shadow, 0 12px 24px rgba(0, 0, 0, 0.5));
  animation: slideUp 0.3s ease-out;
  display: flex;
  flex-direction: column;
  opacity: 0;
  transform: translateY(20px) scale(0.95);
  animation: modalSlideIn 0.3s ease-out forwards;
}

@keyframes modalSlideIn {
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.ypp-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 12px;
  border-bottom: 1px solid var(--ypp-border, #303030);
  background: var(--ypp-bg, #0f0f0f);
  border-radius: 12px 12px 0 0;
  flex-shrink: 0;
}

.ypp-header h2 {
  margin: 0;
  color: var(--ypp-text, #f1f1f1);
  font-size: 1.8rem;
  font-weight: 500;
}

.ypp-modalTitle {
  font-weight: 500;
  color: var(--ypp-text, #f1f1f1);
  font-size: 1.6rem;
  margin: 0;
  flex: 1;
}

.ypp-modalBody {
  font-size: 1.4rem;
  padding: 24px;
  flex: 1;
  background: var(--ypp-bg, #0f0f0f);
  min-height: 0;
}

/* =========================
   Inputs y Forms
========================= */

.ypp-label {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
  color: var(--ypp-text, #f1f1f1);
  font-size: 1.4rem;
  transition: color 0.2s ease;
}

.ypp-label input[type="checkbox"] {
  margin-right: 12px;
  width: 18px;
  height: 18px;
  accent-color: var(--ypp-input-focus, #065fd4);
}

.ypp-label-language {
    gap: 12px;
}

.ypp-input {
  width: 100%;
  padding: 12px 16px;
  margin-bottom: 16px;
  background: var(--ypp-input, #1a1a1a);
  border: 1px solid var(--ypp-input-border, #303030);
  border-radius: 8px;
  color: var(--ypp-text, #f1f1f1);
  font-size: 1.4rem;
  transition: border-color 0.2s ease, background-color 0.2s ease;
}

.ypp-input:focus {
  outline: none;
  border-color: var(--ypp-input-focus, #065fd4);
  background: var(--ypp-surface, #252525);
}

.ypp-input::placeholder {
  color: var(--ypp-text-secondary, #888);
}

.ypp-percent-symbol {
    margin-left: 6px;
}

.ypp-select {
  width: 100%;
  padding: 12px 16px;
  background: var(--ypp-input, #1a1a1a);
  border: 1px solid var(--ypp-input-border, #303030);
  border-radius: 8px;
  color: var(--ypp-text, #f1f1f1);
  font-size: 1.4rem;
  cursor: pointer;
  transition: border-color 0.2s ease, background-color 0.2s ease;
}

.ypp-select:focus {
  outline: none;
  border-color: var(--ypp-input-focus, #065fd4);
  background: var(--ypp-surface, #252525);
}

.ypp-select option {
  background: var(--ypp-input, #1a1a1a);
  color: var(--ypp-text, #f1f1f1);
}

.ypp-input-small {
  margin-left: 10px;
  border-radius: 10px;
  padding: 2px 16px;
}

/* =========================
   Floating Button
========================= */

.ypp-floatingBtnContainer {
  position: fixed;
  bottom: var(--spacing-md);
  right: var(--spacing-md);
  z-index: var(--z-overlay);
  display: flex;
  gap: 10px;
}

/* =========================
   Selector de Idioma con Banderas
========================= */

.ypp-language-selector {
  display: flex;
  align-items: center;
  gap: 8px;
}

.ypp-language-flag {
  font-size: 1.2em;
  margin-right: 5px;
}
`;
        document.head.appendChild(style);
    }

    // ------------------------------------------
    // MARK: üé® Theme
    // ------------------------------------------

    function isYouTubeDarkTheme() {
        // Detectar si YouTube est√° en modo oscuro
        const htmlElement = document.documentElement;
        const computedStyle = getComputedStyle(htmlElement);

        // Verificar tema oscuro
        return (
            htmlElement.getAttribute('dark') === 'true' ||
            htmlElement.hasAttribute('dark') ||
            computedStyle.getPropertyValue('--yt-spec-base-background') === '#0f0f0f' ||
            computedStyle.getPropertyValue('--yt-spec-text-primary') === '#f1f1f1' ||
            document.body.classList.contains('dark-theme') ||
            document.querySelector('ytd-masthead')?.getAttribute('dark') === 'true'
        );
    }

    function getThemeColors() {
        const isDark = isYouTubeDarkTheme();
        return {
            background: isDark ? '#0f0f0f' : '#ffffff',
            surface: isDark ? '#1a1a1a' : '#f9f9f9',
            border: isDark ? '#303030' : '#e0e0e0',
            text: isDark ? '#f1f1f1' : '#0f0f0f',
            textSecondary: isDark ? '#aaa' : '#606060',
            input: isDark ? '#1a1a1a' : '#ffffff',
            inputBorder: isDark ? '#303030' : '#cccccc',
            inputFocus: isDark ? '#065fd4' : '#1a73e8',
            overlay: isDark ? 'rgba(0, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.5)',
            shadow: isDark ? '0 12px 24px rgba(0, 0, 0, 0.5)' : '0 12px 24px rgba(0, 0, 0, 0.15)'
        };
    }

    function applyThemeStyles(element) {
        const colors = getThemeColors();
        element.style.setProperty('--ypp-bg', colors.background);
        element.style.setProperty('--ypp-surface', colors.surface);
        element.style.setProperty('--ypp-border', colors.border);
        element.style.setProperty('--ypp-text', colors.text);
        element.style.setProperty('--ypp-text-secondary', colors.textSecondary);
        element.style.setProperty('--ypp-input', colors.input);
        element.style.setProperty('--ypp-input-border', colors.inputBorder);
        element.style.setProperty('--ypp-input-focus', colors.inputFocus);
        element.style.setProperty('--ypp-overlay', colors.overlay);
        element.style.setProperty('--ypp-shadow', colors.shadow);
    }

    // ------------------------------------------
    // MARK: üé® SVG Icons
    // ------------------------------------------

    // SVGs como strings para reemplazar emojis
    const SVG_ICONS = {
        folder: '<svg class="svgFolderIcon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M10 4H4c-1.11 0-2 .89-2 2v12c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2h-8l-2-2z"/></svg>',
        timer: '<svg class="svgTimerIcon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M15 1H9v2h6V1zm-4 13h2V8h-2v6zm8.03-6.61l1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42A8.962 8.962 0 0 0 12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9a9 9 0 0 0 7.03-14.61zM12 20c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/></svg>',
        check: '<svg width="16" height="16" viewBox="0 0 24 24" fill="var(--color-success)"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>',
        save: '<svg class="svgSaveIcon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>',
        chart: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/></svg>',
        settings: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>',
        close: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: text-bottom;"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>',
        // play: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>',
        trash: '<svg id="svgTrashIcon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>',
        download: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>',
        upload: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/></svg>',
        externalLink: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/></svg>',
        playlist: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M15 6H3v2h12V6zm0 4H3v2h12v-2zM3 16h8v-2H3v2zM17 6v8.18c-.31-.11-.65-.18-1-.18-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3V8h3V6h-5z"/></svg>',
        copy: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>',
        // calendar: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg>',
        // sort: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z"/></svg>',
        locked: '<svg width="16" height="16" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" version="1.1" viewBox="0 0 30 30"><path d="M9 16V8c0-3.3 2.7-6 6-6h0c3.3 0 6 2.7 6 6v8" style="fill:none;stroke:#6a83ba;stroke-width:4;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10"/><path d="M22 29H8c-1.1 0-2-.9-2-2V16c0-1.1.9-2 2-2h14c1.1 0 2 .9 2 2v11c0 1.1-.9 2-2 2z" style="fill:#f2bb41;stroke:#f2bb41;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10"/><path d="M15 24h0c-.6 0-1-.4-1-1v-3c0-.6.4-1 1-1h0c.6 0 1 .4 1 1v3c0 .6-.4 1-1 1z" style="fill:#354c75;stroke:#354c75;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10"/></svg>',
        pin: '<svg class="svgPinIcon" width="16" height="16" viewBox="0 0 508.901 508.901" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve"><defs><path id="a" fill="#a31c09" d="m342.08 279.177 58.606-58.606c-24.594-6.727-48.746-21.389-69.853-42.496-21.116-21.116-35.257-45.789-41.366-70.991l-59.727 59.719-48.719 48.719c6.118 25.212 22.581 47.554 43.697 68.661 21.107 21.116 44.067 36.97 68.661 43.697l48.701-48.703z"/></defs><path fill="#a31c09" d="M505.605 190.556c-13.789 13.789-66.887-16.949-118.599-68.661s-82.45-104.81-68.661-118.599 66.887 16.949 118.599 68.661 82.45 104.811 68.661 118.599"/><path fill="#d9dbe8" d="m0 508.9 112.358-162.295 49.937 49.938z"/><path fill="#ce3929" d="M387.007 121.894c-51.712-51.712-82.45-104.81-68.661-118.599-49.991 49.991-39.23 123.065 12.482 174.777s121.671 65.589 171.652 15.607l-.786-.821c-18.069 6.577-66.93-23.207-114.687-70.964"/><use xlink:href="#a"/><path fill="#ce3929" d="M311.324 389.978c2.348-21.486-1.607-44.226-11.829-68.22l-6.118 6.126c-24.594-6.735-47.554-22.59-68.661-43.697-21.116-21.107-37.579-43.458-43.697-68.661l6.241-6.241-.274-.282c-24.143-10.346-47.016-14.345-68.626-11.979-40.157 4.378-64.071 45.877-47.634 82.785 12.509 28.072 35.566 60.734 66.322 91.489 30.746 30.747 63.417 53.813 91.489 66.313 36.901 16.437 78.4-7.477 82.787-47.633"/></svg>',
        playOrPause: '<svg class="svgPlayOrPauseIcon" width="16"height="16" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" viewBox="0 0 40 40"><path fill="#3B88C3" d="M36 32a4 4 0 0 1-4 4H4a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4h28a4 4 0 0 1 4 4v28z"></path><path fill="#FFF" d="m6 7 13 11L6 29zm20 0h4v22h-4zm-7 0h4v22h-4z"></path></svg>'
    };

    // ------------------------------------------
    // MARK: üé® Estilo barra progreso
    // ------------------------------------------
    /**
    * Aplica degradado de colores a la barra de progreso del reproductor de YouTube usando CSS
    * @param {number} currentTime - Tiempo actual del video en segundos
    * @param {number} duration - Duraci√≥n total del video en segundos
    * @param {string} type - Tipo de video ('shorts' o 'watch')
    */
    function updateProgressBarGradient(currentTime, duration, type = 'watch') {
        try {
            // Verificar si la funcionalidad est√° deshabilitada en la configuraci√≥n
            if (!cachedSettings.enableProgressBarGradient) {
                return;
            }

            if (!duration || duration <= 0) return;

            const percent = Math.min(100, Math.round((currentTime / duration) * 100));
            const progressColor = getProgressColor(percent);

            // Detectar si estamos en shorts
            const isShorts = type === 'shorts' || window.location.pathname.includes('/shorts/');

            if (isShorts) {
                // Selectores espec√≠ficos para shorts con estructura correcta
                const shortsProgressHost = document.querySelector('.desktopShortsPlayerControlsHost .ytPlayerProgressBarHost, .ytPlayerProgressBarHost');
                const shortsPlayedBar = document.querySelector('.ytProgressBarLineProgressBarPlayed');
                const shortsHoveredBar = document.querySelector('.ytProgressBarLineProgressBarHovered');
                const shortsPlayheadDot = document.querySelector('.ytProgressBarPlayheadProgressBarPlayheadDot');

                if (shortsProgressHost) {
                    // Aplicar variables CSS para el degradado en shorts
                    shortsProgressHost.style.setProperty('--ytp-progress-color', progressColor, 'important');
                    shortsProgressHost.style.setProperty('--ytp-progress-percent', `${percent}%`, 'important');

                    // Aplicar estilos directamente a los elementos de la barra de shorts
                    if (shortsPlayedBar) {
                        shortsPlayedBar.style.backgroundColor = progressColor;
                        shortsPlayedBar.style.setProperty('background', progressColor, 'important');
                    }

                    if (shortsHoveredBar) {
                        shortsHoveredBar.style.backgroundColor = progressColor;
                        shortsHoveredBar.style.setProperty('background', progressColor, 'important');
                    }

                    if (shortsPlayheadDot) {
                        shortsPlayheadDot.style.backgroundColor = progressColor;
                        shortsPlayheadDot.style.setProperty('background', progressColor, 'important');
                    }

                    log('updateProgressBarGradient', `Barra de progreso de shorts actualizada: ${percent}% - Color: ${progressColor}`);
                }
            } else {
                // Selectores para videos regulares
                const progressContainer = document.querySelector('.ytp-progress-bar');
                const playProgress = document.querySelector('.ytp-play-progress');
                const hoverProgress = document.querySelector('.ytp-hover-progress');

                if (progressContainer) {
                    // Aplicar variables CSS para el degradado
                    progressContainer.style.setProperty('--ytp-progress-color', progressColor, 'important');
                    progressContainer.style.setProperty('--ytp-progress-percent', `${percent}%`, 'important');

                    // Aplicar estilos directamente a la barra de progreso
                    if (playProgress) {
                        playProgress.style.backgroundColor = progressColor;
                        playProgress.style.setProperty('background', progressColor, 'important');
                    }

                    if (hoverProgress) {
                        hoverProgress.style.backgroundColor = progressColor;
                        hoverProgress.style.setProperty('background', progressColor, 'important');
                    }

                    log('updateProgressBarGradient', `Barra de progreso regular actualizada: ${percent}% - Color: ${progressColor}`);
                }
            }
        } catch (error) {
            // Silenciar errores para no afectar el funcionamiento principal
        }
    }

    // Inyecta CSS personalizado para la barra de progreso de YouTube (regular y shorts)
    function injectProgressBarCSS() {
        // Verificar si la funcionalidad est√° deshabilitada en la configuraci√≥n
        if (!cachedSettings.enableProgressBarGradient) {
            log('injectProgressBarCSS', 'Degradado de barra de progreso deshabilitado en configuraci√≥n');
            return;
        }

        // Verificar si ya existe el estilo para evitar duplicados
        if (document.getElementById('ypp-progress-bar-styles')) {
            log('injectProgressBarCSS', 'CSS ya existe, omitiendo inyecci√≥n');
            return;
        }

        const css = `
            /* Barra de progreso personalizada con degradado de colores - Videos regulares */
            .ytp-progress-bar {
                --ytp-progress-color: #ff4533;
                --ytp-progress-percent: 0%;
            }
            
            .ytp-play-progress {
                background: var(--ytp-progress-color) !important;
                transition: background 0.3s ease !important;
            }
            
            .ytp-hover-progress {
                background: var(--ytp-progress-color) !important;
                transition: background 0.3s ease !important;
            }
            
            .ytp-progress-bar-container {
                background: linear-gradient(to right, 
                    var(--ytp-progress-color) 0%, 
                    var(--ytp-progress-color) var(--ytp-progress-percent), 
                    rgba(255, 255, 255, 0.2) var(--ytp-progress-percent), 
                    rgba(255, 255, 255, 0.2) 100%) !important;
                background-size: 100% 100% !important;
                transition: background 0.3s ease !important;
            }
            
            .ytp-load-progress {
                background: rgba(255, 255, 255, 0.3) !important;
            }
            
            /* Shorts - barra de progreso espec√≠fica con estructura correcta */
            .desktopShortsPlayerControlsHost .ytPlayerProgressBarHost,
            .ytPlayerProgressBarHost {
                --ytp-progress-color: #ff4533;
                --ytp-progress-percent: 0%;
            }
            
            /* Barra de progreso principal de shorts */
            .ytProgressBarLineProgressBarPlayed {
                background: var(--ytp-progress-color) !important;
                transition: background 0.3s ease !important;
            }
            
            /* Barra de hover en shorts */
            .ytProgressBarLineProgressBarHovered {
                background: var(--ytp-progress-color) !important;
                transition: background 0.3s ease !important;
            }
            
            /* Contenedor principal de la barra de shorts */
            .ytProgressBarLineProgressBarLine {
                background: linear-gradient(to right, 
                    var(--ytp-progress-color) 0%, 
                    var(--ytp-progress-color) var(--ytp-progress-percent), 
                    rgba(255, 255, 255, 0.2) var(--ytp-progress-percent), 
                    rgba(255, 255, 255, 0.2) 100%) !important;
                background-size: 100% 100% !important;
                transition: background 0.3s ease !important;
            }
            
            /* Fondo de carga en shorts */
            .ytProgressBarLineProgressBarLoaded {
                background: rgba(255, 255, 255, 0.3) !important;
            }
            
            /* Punto del seek (playhead) en shorts */
            .ytProgressBarPlayheadProgressBarPlayheadDot {
                background: var(--ytp-progress-color) !important;
                transition: background 0.3s ease !important;
            }
            
            /* Asegurar que los estilos se apliquen sobre los de YouTube */
            .ytp-progress-bar .ytp-play-progress,
            .ytp-chrome-controls .ytp-progress-bar .ytp-play-progress {
                background: var(--ytp-progress-color) !important;
            }
            
            .ytp-progress-bar .ytp-hover-progress,
            .ytp-chrome-controls .ytp-progress-bar .ytp-hover-progress {
                background: var(--ytp-progress-color) !important;
            }
            
            /* Para el punto del seek (thumb) - regular */
            .ytp-scrubber-container .ytp-scrubber {
                background: var(--ytp-progress-color) !important;
            }
            
            .ytp-scrubber-button {
                background: var(--ytp-progress-color) !important;
            }
        `;

        try {
            // Crear y a√±adir el estilo
            const style = document.createElement('style');
            style.id = 'ypp-progress-bar-styles';
            style.textContent = css;
            document.head.appendChild(style);

            log('injectProgressBarCSS', 'CSS inyectado para barra de progreso (regular y shorts)');
        } catch (error) {
            conError('injectProgressBarCSS', 'Error al inyectar CSS:', error);
        }
    }

    /**
    * Calcula el color del progreso basado en el porcentaje y el tema (rojo -> naranja -> verde)
    * @param {number} percent - Porcentaje de progreso (0-100)
    * @returns {string} Color en formato hexadecimal
    */
    function getProgressColor(percent) {
        if (percent === null || percent === undefined) return '#666666';

        // Detectar si estamos en tema claro
        const isLightTheme = !isYouTubeDarkTheme();

        // Rangos de color para tema oscuro (colores oscuros para mejor contraste en playlists):
        // 0-33%: Rojo oscuro (#dd4444 -> #ff8844)
        // 34-66%: Naranja oscuro (#ff8844 -> #ffcc44) 
        // 67-100%: Verde oscuro (#ffcc44 -> #00cc00)

        // Rangos de color para tema claro (colores oscuros con mejor contraste):
        // 0-33%: Rojo oscuro (#cc0000 -> #dd6600)
        // 34-66%: Naranja oscuro (#dd6600 -> #cc9900)
        // 67-100%: Verde oscuro (#cc9900 -> #008800)

        let color;
        if (isLightTheme) {
            // Colores para tema claro (m√°s oscuros para mejor contraste)
            if (percent <= 33) {
                // Rojo oscuro a naranja oscuro
                const ratio = percent / 33;
                const r = Math.round(204 - (204 - 221) * ratio); // 204 -> 221
                const g = Math.round(0 + (102 - 0) * ratio); // 0 -> 102
                const b = 0;
                color = `rgb(${r}, ${g}, ${b})`;
            } else if (percent <= 66) {
                // Naranja oscuro a amarillo oscuro
                const ratio = (percent - 33) / 33;
                const r = Math.round(221 - (221 - 204) * ratio); // 221 -> 204
                const g = Math.round(102 + (153 - 102) * ratio); // 102 -> 153
                const b = 0;
                color = `rgb(${r}, ${g}, ${b})`;
            } else if (percent <= 95) {
                // Amarillo oscuro a verde oscuro
                const ratio = (percent - 66) / 29;
                const r = Math.round(204 - (204 - 0) * ratio); // 204 -> 0
                const g = Math.round(153 + (136 - 153) * ratio); // 153 -> 136
                const b = 0;
                color = `rgb(${r}, ${g}, ${b})`;
            } else {
                // Verde oscuro (casi completado o completado)
                color = '#008800';
            }
        } else {
            // Colores mejorados para tema oscuro (m√°s oscuros para contraste en playlists)
            if (percent <= 33) {
                // Rojo oscuro a naranja
                const ratio = percent / 33;
                const r = Math.round(221 - (221 - 255) * ratio); // 221 -> 255
                const g = Math.round(68 + (136 - 68) * ratio); // 68 -> 136
                const b = 68;
                color = `rgb(${r}, ${g}, ${b})`;
            } else if (percent <= 66) {
                // Naranja a amarillo
                const ratio = (percent - 33) / 33;
                const r = 255;
                const g = Math.round(136 + (204 - 136) * ratio); // 136 -> 204
                const b = Math.round(68 + (68 - 68) * ratio); // 68 -> 68
                color = `rgb(${r}, ${g}, ${b})`;
            } else if (percent <= 95) {
                // Amarillo a verde oscuro
                const ratio = (percent - 66) / 29;
                const r = Math.round(255 - (255 - 0) * ratio); // 255 -> 0
                const g = Math.round(204 + (204 - 204) * ratio); // 204 -> 204
                const b = Math.round(68 + (68 - 68) * ratio); // 68 -> 68
                color = `rgb(${r}, ${g}, ${b})`;
            } else {
                // Verde oscuro (casi completado o completado) - mejor contraste en fondos celestes
                color = '#00cc00';
            }
        }

        return color;
    }

    // ------------------------------------------
    // MARK: üíæ Storage + Settings
    // ------------------------------------------
    /**
    * Objeto Storage para gestionar el almacenamiento local del navegador.
    * Proporciona m√©todos para guardar, obtener y eliminar datos, 
    * as√≠ como para listar claves almacenadas con un prefijo espec√≠fico.
    */
    const Storage = {
        /**
         * Obtiene un valor del almacenamiento local.
         * @param {string} key - La clave bajo la cual se almacena el valor.
         * @returns {Object|null} El valor parseado de JSON o null si no existe.
         */
        get(key) {
            try {
                const raw = localStorage.getItem(`${CONFIG.storagePrefix}${key}`);
                return raw ? JSON.parse(raw) : null;
            } catch (error) {
                conError('Storage', `Storage.get: Error al parsear la clave "${key}"`, error);
                return null;
            }
        },

        /**
         * Almacena un valor en el almacenamiento local.
         * @param {string} key - La clave bajo la cual se almacenar√° el valor.
         * @param {Object} value - El valor a almacenar, que ser√° serializado a JSON.
         */
        set(key, value) {
            try {
                const serialized = JSON.stringify(value);
                localStorage.setItem(`${CONFIG.storagePrefix}${key}`, serialized);
            } catch (error) {
                conError('Storage', `Storage.set: Error al guardar la clave "${key}"`, error);
            }
        },

        /**
         * Elimina un valor del almacenamiento local.
         * @param {string} key - La clave del valor que se eliminar√°.
         */
        del(key) {
            try {
                localStorage.removeItem(`${CONFIG.storagePrefix}${key}`);
            } catch (error) {
                conError('Storage', `Storage.del: Error al eliminar la clave "${key}"`, error);
            }
        },

        /**
         * Obtiene todas las claves almacenadas que comienzan con el prefijo definido.
         * @returns {Array<string>} Un array de claves sin el prefijo.
         */
        keys() {
            return Object.keys(localStorage)
                .filter((fullKey) => fullKey.startsWith(CONFIG.storagePrefix))
                .map((fullKey) => fullKey.slice(CONFIG.storagePrefix.length));
        }
    };

    /**
    * Objeto Settings para gestionar la configuraci√≥n del usuario.
    * Proporciona m√©todos as√≠ncronos para obtener y establecer 
    * la configuraci√≥n del usuario utilizando GM_getValue y GM_setValue.
    */
    const Settings = {
        /**
         * Obtiene la configuraci√≥n del usuario.
         * @returns {Promise<Object>} Una promesa que resuelve un objeto con 
         * los ajustes del usuario, combinando los ajustes por defecto 
         * con los ajustes almacenados.
         */
        async get() {
            try {
                const raw = await GM_getValue(CONFIG.userSettingsKey, null);
                const parsed = raw ? JSON.parse(raw) : {};
                return { ...CONFIG.defaultSettings, ...parsed };
            } catch (error) {
                conError('Settings', 'Error al cargar configuraci√≥n del usuario:', error);
                return { ...CONFIG.defaultSettings };
            }
        },

        /**
         * Establece la configuraci√≥n del usuario.
         * @param {Object} settings - Un objeto que contiene los nuevos ajustes del usuario.
         * @returns {Promise<void>} Una promesa que resuelve cuando la configuraci√≥n es guardada.
         */
        async set(settings) {
            try {
                const serialized = JSON.stringify(settings);
                await GM_setValue(CONFIG.userSettingsKey, serialized);
            } catch (error) {
                conError('Settings', 'Error al guardar configuraci√≥n del usuario:', error);
            }
        }
    };

    // ------------------------------------------
    // MARK: üìä Variables Globales
    // ------------------------------------------

    // Variables para controlar el estado de inicializaci√≥n
    let isNavigating = false;
    let navigationDebounceTimeout = null;
    let isResuming = false;
    let YTHelper = null; // YouTube Helper API, Redeclarada en waitForHelper
    let currentPageType = null; // Tipo de p√°gina actual

    // ------------------------------------------
    // MARK: üîß Utils
    // ------------------------------------------

    // MARK: üîß Formateo de Tiempo
    /**
    * Formatea un valor de tiempo (en segundos o string) a un string en formato "MM:SS" o "HH:MM:SS".
    *
    * @param {number|string} input - Valor de tiempo a formatear.
    * @returns {string} - String con el tiempo formateado.
    * Ejemplos:
    * formatTime(65)         // "01:05"
    * formatTime("5:30")     // "05:30"
    * formatTime("1:05:30")  // "01:05:30"
    * formatTime("invalid")  // "00:00"
    */
    const formatTime = (input) => {
        let seconds;

        // Si es un n√∫mero, lo usa directamente
        if (typeof input === 'number' && !isNaN(input)) {
            seconds = input;
        }
        // Si es un string, intenta convertirlo
        else if (typeof input === 'string') {
            // Maneja formatos como "5:30" o "05:30"
            if (input.includes(':')) {
                const parts = input.split(':').map(part => parseInt(part, 10));

                // Si es MM:SS
                if (parts.length === 2) {
                    seconds = parts[0] * 60 + parts[1];
                }
                // Si es HH:MM:SS
                else if (parts.length === 3) {
                    seconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
                } else {
                    conError('Formato de tiempo no v√°lido:', input);
                    return '00:00';
                }
            }
            // Intenta convertir directamente a n√∫mero
            else {
                seconds = parseFloat(input);
            }
        }
        // Caso por defecto
        else {
            conError('Valor de entrada no v√°lido:', input);
            return '00:00';
        }

        // Validaci√≥n final
        if (typeof seconds !== 'number' || isNaN(seconds) || seconds < 0) {
            conError('Valor de segundos no v√°lido:', input);
            return '00:00';
        }

        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);

        return hours > 0
            ? `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
            : `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };

    /**
    * Parsea un string de tiempo en formato "MM:SS" o "HH:MM:SS" a segundos.
    *
    * @param {string} timeStr - String con el tiempo en formato "MM:SS" o "HH:MM:SS".
    * @returns {number} N√∫mero de segundos correspondiente al string. Retorna 0 si el formato es inv√°lido.
    *
    * @example
    * // Formato MM:SS ‚Üí minutos y segundos
    * parseTimeToSeconds("5:30");      // ‚Üí 330
    *
    * @example
    * // Formato HH:MM:SS ‚Üí horas, minutos y segundos
    * parseTimeToSeconds("1:05:30");   // ‚Üí 3930
    *
    * @example
    * // Formato inv√°lido ‚Üí 0
    * parseTimeToSeconds("invalid");   // ‚Üí 0
    *
    * @example
    * // Cadena vac√≠a o no string ‚Üí 0
    * parseTimeToSeconds("");          // ‚Üí 0
    * parseTimeToSeconds(null);        // ‚Üí 0
    */
    const parseTimeToSeconds = (timeStr) => {
        if (typeof timeStr !== 'string' || !timeStr.includes(':')) return 0;

        const parts = timeStr.split(':').map(Number);

        // Retorna 0 si alg√∫n valor es NaN
        if (parts.some(isNaN)) return 0;

        if (parts.length === 2) return parts[0] * 60 + parts[1];
        if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];

        return 0;
    };

    /**
     * Convierte una duraci√≥n en formato ISO 8601 (PT4M35S) a segundos
     * @param {string} isoDuration - Duraci√≥n en formato ISO (ej: "PT4M35S", "PT1H2M3S")
     * @returns {number} Duraci√≥n en segundos
     * @example
     * parseISODuration("PT4M35S");    // ‚Üí 275
     * parseISODuration("PT1H2M3S");   // ‚Üí 3723
     * parseISODuration("PT30S");      // ‚Üí 30
     * parseISODuration("invalid");    // ‚Üí 0
     */
    const parseISODuration = (isoDuration) => {
        if (typeof isoDuration !== 'string' || !isoDuration.startsWith('PT')) return 0;

        // Expresi√≥n regular para extraer horas, minutos y segundos
        const regex = /PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/;
        const matches = isoDuration.match(regex);

        if (!matches) return 0;

        const hours = parseInt(matches[1]) || 0;
        const minutes = parseInt(matches[2]) || 0;
        const seconds = parseInt(matches[3]) || 0;

        return hours * 3600 + minutes * 60 + seconds;
    };

    /**
    * Normaliza un valor de tiempo a segundos.
    *
    * @param {number|string} value - Valor de tiempo a normalizar.
    *                              Puede ser un n√∫mero (ya en segundos)
    *                              o una cadena en formato "SS", "MM:SS" o "HH:MM:SS".
    * @returns {number} N√∫mero de segundos (0 si el valor es inv√°lido o no existe).
    *
    * @example
    * // N√∫mero directo ‚Üí devuelve el mismo n√∫mero
    * normalizeSeconds(65);        // ‚Üí 65
    *
    * @example
    * // "MM:SS" ‚Üí minutos y segundos
    * normalizeSeconds("5:30");    // ‚Üí 330
    *
    * @example
    * // "HH:MM:SS" ‚Üí horas, minutos y segundos
    * normalizeSeconds("1:05:30"); // ‚Üí 3930
    *
    * @example
    * // Sin argumento o null ‚Üí 0
    * normalizeSeconds();          // ‚Üí 0
    * normalizeSeconds(null);      // ‚Üí 0
    *
    * @example
    * // Valor inv√°lido ‚Üí 0
    * normalizeSeconds("invalid"); // ‚Üí 0
    */
    const normalizeSeconds = (value) => {
        if (!value) return 0;
        if (typeof value === 'number') return value;
        if (typeof value === 'string') return parseTimeToSeconds(value.trim());
        return 0;
    };

    // MARK: üîß SetInnerHTML
    /**
    * Asigna HTML de forma segura para compatibilidad con Trusted Types (Chrome)
    *
    * @param {HTMLElement} element - Elemento HTML al que se le asignar√° el HTML.
    * @param {string} html - HTML a asignar en su innerHTML.
    */
    function setInnerHTML(element, html) {
        if (window.trustedTypes && window.trustedTypes.createPolicy) {
            try {
                const policy = window.trustedTypes.createPolicy('youtube-playback-plox', {
                    createHTML: (string) => string
                });
                element.innerHTML = policy.createHTML(html);
            } catch (e) {
                // Si la creaci√≥n de la pol√≠tica falla, usar innerHTML directamente
                element.innerHTML = html;
            }
        } else {
            // Si TrustedHTML no est√° soportado, usar innerHTML
            element.innerHTML = html;
        }
    }

    // MARK: üîß Crear Elemento
    /**
    * Crea un elemento HTML con varias opciones de configuraci√≥n.
    * 
    * @param {string} tag - Nombre del tag HTML a crear, e.g., 'div', 'span'.
    * @param {Object} [options] - Opciones para configurar el elemento.
    * @param {string} [options.className] - Clases CSS del elemento.
    * @param {string} [options.id] - ID del elemento.
    * @param {string} [options.text] - Texto interno del elemento.
    * @param {string} [options.html] - HTML interno del elemento (usa setInnerHTML seguro).
    * @param {Function} [options.onClickEvent] - Funci√≥n legacy para el evento click.
    * @param {Object.<string, Function>} [options.events] - Eventos a a√±adir, e.g., { click: fn, mouseover: fn }.
    * @param {Object.<string, string>} [options.atribute] - Atributos HTML a a√±adir, e.g., { src: 'img.png' }.
    * @param {Object.<string, any>} [options.props] - Propiedades del elemento, e.g., { value: '123' }.
    * @param {Object.<string, string>} [options.styles] - Estilos CSS a aplicar, e.g., { color: 'red', fontSize: '14px' }.
    * @param {Array<string|Node>} [options.children] - Hijos a a√±adir al elemento, strings o nodos.
    * @returns {HTMLElement} - El elemento HTML creado y configurado.
    */
    function createElement(tag, {
        className = '',
        id = '',
        text = '',
        html = '',
        onClickEvent = null,
        events = {},
        atribute = {},
        props = {},
        styles = {},
        children = []
    } = {}) {
        const el = document.createElement(tag);

        if (className) el.className = className;
        if (id) el.id = id;
        if (text) el.textContent = text;
        if (html) setInnerHTML(el, html);

        // Soporte legacy (funci√≥n onClickEvent)
        if (onClickEvent && typeof onClickEvent === 'function') {
            el.addEventListener('click', onClickEvent);
        }

        // Soporte para m√∫ltiples eventos
        if (events && typeof events === 'object') {
            Object.entries(events).forEach(([event, handler]) => {
                if (typeof handler === 'function') {
                    el.addEventListener(event, handler);
                }
            });
        }

        // Atributos
        if (atribute && typeof atribute === 'object') {
            Object.entries(atribute).forEach(([k, v]) => el.setAttribute(k, v));
        }

        // Propiedades directas
        if (props && typeof props === 'object') {
            Object.entries(props).forEach(([k, v]) => {
                if (k in el) el[k] = v;
            });
        }

        // Estilos CSS
        if (styles && typeof styles === 'object') {
            Object.entries(styles).forEach(([property, value]) => {
                el.style[property] = value;
            });
        }

        // A√±adir children
        if (Array.isArray(children)) {
            children.forEach(child => {
                if (typeof child === 'string') {
                    el.appendChild(document.createTextNode(child));
                } else if (child instanceof Node) {
                    el.appendChild(child);
                }
            });
        }

        return el;
    }

    // MARK: üîß YouTube Helper API
    /**
    * Espera a que YouTube Helper API est√© listo.
    *
    * @param {number} retries - N√∫mero de reintentos (opcional, por defecto 0).
    * @returns {Promise} - Promesa que se resuelve cuando YouTube Helper API est√° listo.
    */
    function waitForHelper(retries = 0) {
        return new Promise((resolve, reject) => {
            const MAX_RETRIES = 10;
            const RETRY_INTERVAL = 1000;

            const helper = window.youtubeHelperApi;

            if (helper) {
                // Si ya est√° inicializado completamente
                if (helper.player?.api) return resolve(helper);

                // Si existe pero a√∫n no se inicializ√≥
                helper.eventTarget.addEventListener('yt-helper-api-ready', (e) => {
                    resolve(e.detail);
                }, { once: true });
                return;
            }

            // Si no existe todav√≠a, reintenta
            if (retries < MAX_RETRIES) {
                warn('init', `[YTHelper] No disponible, reintentando... (${retries + 1}/${MAX_RETRIES})`);
                setTimeout(() => resolve(waitForHelper(retries + 1)), RETRY_INTERVAL);
            } else {
                reject(new Error("YouTube Helper API no disponible tras varios intentos"));
            }
        });
    }

    // MARK: üîß YouTube Thumbnail Loading
    /**
     * Devuelve la URL de la miniatura de un video de YouTube.
     * Utiliza un enfoque progresivo para obtener la miniatura m√°s alta disponible.
     * @param {string} videoId - ID del video de YouTube
     * @returns {Promise<string>} - URL de la miniatura o placeholder
     */
    function loadYouTubeThumbnail(videoId) {
        const base = `https://i.ytimg.com/vi/${videoId}`;
        const levels = ['maxresdefault', 'hqdefault', 'mqdefault']; // fallback progresivo
        const placeholder = 'data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTI4IiBoZWlnaHQ9IjcyIiB2aWV3Qm94PSIwIDAgMTI4IDcyIj4KICA8cmVjdCB3aWR0aD0iMTI4IiBoZWlnaHQ9IjcyIiBmaWxsPSIjMjAyMDIwIi8+CiAgPHBvbHlnb24gcG9pbnRzPSI1MCwyMiA1MCw1MCA3OCwzNiIgZmlsbD0iI2ZmZiIvPgo8L3N2Zz4=';

        return new Promise((resolve) => {
            let index = 0;

            function tryNext() {
                if (index >= levels.length) {
                    resolve(placeholder); // no se encontr√≥ ninguna v√°lida
                    return;
                }

                const url = `${base}/${levels[index]}.jpg`;
                const img = new Image();
                img.onload = () => {
                    // YouTube placeholder de maxresdefault suele tener tama√±o 120x90
                    if (img.naturalWidth <= 120 || img.naturalHeight <= 90) {
                        index++;
                        tryNext();
                    } else {
                        resolve(url); // imagen v√°lida encontrada
                    }
                };
                img.onerror = () => {
                    index++;
                    tryNext(); // intentar siguiente nivel
                };
                img.src = url;
            }

            tryNext();
        });
    }

    // MARK: üîß Debounce
    /**
    * Crea una funci√≥n "debounceada" que retrasa la ejecuci√≥n de la funci√≥n original
    * hasta que haya pasado un tiempo determinado sin que se vuelva a invocar.
    *
    * @param {Function} fn - La funci√≥n que se quiere ejecutar con retraso.
    * @param {number} delay - Tiempo de espera (en milisegundos) antes de ejecutar `fn`.
    * @returns {Function} - Una nueva funci√≥n que, al llamarse repetidamente,
    *                       solo ejecutar√° `fn` una vez pasado el tiempo indicado.
    */
    const debounce = (fn, delay) => {
        // Variable para almacenar el identificador del temporizador
        let timer;

        // Retorna una nueva funci√≥n que "envuelve" a la original
        return (...args) => {
            // Si el temporizador ya estaba activo, se cancela
            clearTimeout(timer);

            // Se crea un nuevo temporizador que ejecutar√° la funci√≥n despu√©s del delay
            timer = setTimeout(() => fn(...args), delay);
        };
    };

    // MARK: üì§ Import/Export JSON
    // Exportaci√≥n/Importaci√≥n JSON nativo del userscript (preserva videoType de shorts)
    const exportDataToFile = () => {
        try {
            const exportData = {};
            const keys = Storage.keys().filter(k =>
                !k.startsWith('userSettings') &&
                !k.startsWith('userFilters') &&
                !k.startsWith('playlist_meta_')
            );

            keys.forEach(k => {
                const data = Storage.get(k);
                if (data) exportData[k] = data;
            });

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().split('T')[0];
            a.download = `youtube-playback-plox-backup-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);

            const videoCount = Object.keys(exportData).length;
            showFloatingToast(`üì§ ${videoCount} videos exportados`);
            log('exportDataToFile', `Exportados ${videoCount} videos en formato JSON nativo`);
        } catch (error) {
            conError('exportDataToFile', 'Error al exportar:', error);
            showFloatingToast(`‚ùå Error al exportar datos`);
        }
    };

    const importDataFromFile = () => {
        let inputFile = document.getElementById('ypp-import-file');
        if (!inputFile) {
            inputFile = createElement('input', {
                id: 'ypp-import-file',
                atribute: { type: 'file', accept: '.json' },
                style: { display: 'none' }
            });
            document.body.appendChild(inputFile);
        }

        inputFile.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (typeof data !== 'object' || data === null) {
                    showFloatingToast(`‚ùå Formato de archivo inv√°lido`);
                    return;
                }

                let importCount = 0;
                let skipped = 0;

                Object.entries(data).forEach(([key, value]) => {
                    // Evitar importar configuraciones
                    if (key.startsWith('userSettings') || key.startsWith('userFilters')) {
                        skipped++;
                        return;
                    }

                    // Validar que el valor tenga estructura m√≠nima de video
                    if (value && typeof value === 'object' && (value.videoId || value.timestamp !== undefined)) {
                        Storage.set(key, value);
                        importCount++;
                    } else {
                        log('importDataFromFile', `Entrada inv√°lida ignorada: ${key}`);
                        skipped++;
                    }
                });

                updateVideoList();

                if (importCount > 0) {
                    showFloatingToast(`‚úÖ ${importCount} videos importados${skipped > 0 ? ` (${skipped} omitidos)` : ''}`);
                    log('importDataFromFile', `Importados ${importCount} videos, ${skipped} omitidos`);
                } else {
                    showFloatingToast(`‚ö†Ô∏è No se encontraron videos v√°lidos para importar`);
                }
            } catch (error) {
                conError('importDataFromFile', 'Error al importar:', error);
                showFloatingToast(`‚ùå Error al importar: archivo JSON inv√°lido`);
            } finally {
                inputFile.value = '';
            }
        };

        inputFile.click();
    };

    // MARK: üì§ Import/Export FreeTube
    // Exportaci√≥n/Importaci√≥n FreeTube (no preserva videoType de shorts)
    const exportToFreeTube = () => {
        // Usar la funci√≥n centralizada para exportar en formato FreeTube
        // para asegurar que todos los campos est√©n correctamente mapeados
        (async () => {
            try {
                const exportData = await exportToFreeTubeFormat();
                // FreeTube imports as JSON Lines / .db where each line is a JSON object.
                // Generar JSON Lines (NDJSON) - cada l√≠nea debe ser un objeto JSON completo
                // JSON.stringify serializa sin saltos de l√≠nea por defecto, pero nos aseguramos
                const ndjson = exportData
                    .map(obj => {
                        // Asegurar que no haya saltos de l√≠nea internos en el JSON serializado
                        const jsonLine = JSON.stringify(obj);
                        // Verificar que sea v√°lido (debugging)
                        if (jsonLine.includes('\n') || jsonLine.includes('\r')) {
                            warn('exportToFreeTube', 'JSON con saltos de l√≠nea detectado, limpiando...');
                            // Esto no deber√≠a ocurrir con JSON.stringify, pero por seguridad
                            return jsonLine.replace(/\r?\n/g, '\\n');
                        }
                        return jsonLine;
                    })
                    .join('\n');

                const blob = new Blob([ndjson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().split('T')[0];
                // Usar extensi√≥n .db porque FreeTube a veces espera ese sufijo (incluso si es JSONL)
                a.download = `youtube-playback-plox-backup-${timestamp}-freetube-compatible.db`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                showFloatingToast(`üì§ FreeTube ${t('dataExported')}`);
            } catch (err) {
                conError('exportToFreeTube', 'Error exporting to FreeTube format:', err);
                showFloatingToast(`‚ùå ${t('importError')}`);
            }
        })();
    };

    const importFromFreeTube = () => {
        let inputFile = document.getElementById('ypp-import-freetube-file');
        if (!inputFile) {
            inputFile = createElement('input', {
                id: 'ypp-import-freetube-file',
                atribute: { type: 'file', accept: '.json, .db' },
                style: { display: 'none' }
            });
            document.body.appendChild(inputFile);
        }
        inputFile.onchange = async (e) => {
            const file = e.target.files[0];
            const fileName = file?.name || '';
            if (!file) return;

            if (file.size > 10 * 1024 * 1024) { // 10MB limit
                showFloatingToast(`‚ùå El archivo es demasiado grande (m√°ximo 10MB)`);
                return;
            }

            // Si es un archivo .db de FreeTube, puede ser:
            //  - un SQLite binario (real .db)
            //  - un .db renombrado que contiene JSON o JSON Lines (caso observado)
            if (fileName.endsWith('.db')) {
                // Intentar leer como texto primero (JSON o JSON Lines)
                try {
                    showFloatingToast(`üì• Procesando archivo FreeTube (.db) como texto...`);
                    const text = await file.text();

                    // Intentar parsear como JSON array
                    let data = null;
                    try {
                        data = JSON.parse(text);
                    } catch (e) {
                        // Intentar JSON Lines
                        try {
                            const lines = text.trim().split('\n').filter(l => l.trim());
                            data = lines.map(l => JSON.parse(l));
                        } catch (e2) {
                            data = null;
                        }
                    }

                    if (Array.isArray(data) && data.length > 0) {
                        const result = await importFromFreeTubeFormat(data);
                        updateVideoList();
                        if (result.imported > 0) {
                            showFloatingToast(`‚úÖ ${result.imported} videos importados desde FreeTube${result.failed > 0 ? ` (${result.failed} errores)` : ''}`);
                        } else {
                            showFloatingToast(`‚ùå No se pudo importar ning√∫n video (${result.failed} errores)`);
                        }
                        return;
                    }
                    // Si llegamos aqu√≠, el archivo .db no era JSON v√°lido -> intentar parsear como SQLite
                    showFloatingToast(`üì• Intentando procesar .db como SQLite...`);
                } catch (textErr) {
                    // Si leer como texto falla por cualquier motivo, continuamos intentando parsear como SQLite
                    log('importFromFreeTube', 'No se pudo procesar .db como texto, intentando SQLite', textErr);
                }

                // Intentar parsear como SQLite DB (binario)
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const data = await parseFreeTubeDB(arrayBuffer);

                    if (!data || data.length === 0) {
                        showFloatingToast(`‚ö†Ô∏è No se encontraron videos en la base de datos de FreeTube`);
                        return;
                    }

                    const result = await importFromFreeTubeFormat(data);
                    updateVideoList();

                    if (result.imported > 0) {
                        showFloatingToast(`‚úÖ ${result.imported} videos importados desde FreeTube DB${result.failed > 0 ? ` (${result.failed} errores)` : ''}`);
                    } else {
                        showFloatingToast(`‚ùå No se pudo importar ning√∫n video desde la base de datos (${result.failed} errores)`);
                    }
                } catch (error) {
                    conError('importFromFreeTube', 'Error procesando archivo .db:', error);
                    showFloatingToast(`‚ùå Error al procesar la base de datos de FreeTube`);
                }

                return;
            }

            try {
                showFloatingToast(`üì• Procesando archivo...`);
                const text = await file.text();

                // Validar que el archivo no est√© vac√≠o
                if (!text.trim()) {
                    showFloatingToast(`‚ùå El archivo est√° vac√≠o`);
                    return;
                }

                let data;

                // Intentar parsear como JSON array est√°ndar primero
                try {
                    data = JSON.parse(text);
                } catch (standardError) {
                    // Si falla, intentar parsear como JSON Lines (formato FreeTube)
                    try {
                        data = [];
                        const lines = text.trim().split('\n').filter(line => line.trim());

                        for (const line of lines) {
                            if (line.trim()) {
                                const obj = JSON.parse(line);
                                data.push(obj);
                            }
                        }

                        log('importFromFreeTube', `Parseado como JSON Lines: ${data.length} objetos encontrados`);
                    } catch (linesError) {
                        throw new SyntaxError('El archivo no tiene un formato JSON v√°lido ni JSON Lines (formato FreeTube)');
                    }
                }

                // Validar que sea un array
                if (!Array.isArray(data)) {
                    showFloatingToast(`‚ùå El formato del archivo no es v√°lido (se espera un array de videos)`);
                    return;
                }

                if (data.length === 0) {
                    showFloatingToast(`‚ö†Ô∏è El archivo no contiene videos para importar`);
                    return;
                }

                const result = await importFromFreeTubeFormat(data);
                updateVideoList();

                if (result.imported > 0) {
                    showFloatingToast(`‚úÖ ${result.imported} videos importados desde FreeTube${result.failed > 0 ? ` (${result.failed} errores)` : ''}`);
                } else {
                    showFloatingToast(`‚ùå No se pudo importar ning√∫n video (${result.failed} errores)`);
                }
            } catch (error) {
                conError('importFromFreeTube', 'Error importando:', error);
                if (error instanceof SyntaxError) {
                    showFloatingToast(`‚ùå Error al leer el archivo JSON: ${error.message}`);
                } else {
                    showFloatingToast(`‚ùå Error al importar archivo FreeTube`);
                }
            } finally {
                // Limpiar el input para permitir seleccionar el mismo archivo nuevamente
                inputFile.value = '';
            }
        };
        inputFile.click();
    };

    /**
    * Convierte el formato interno de YouTube Playback Plox a formato FreeTube
    * @param {Object} internalData - Datos en formato interno del script
    * @returns {Object} Datos en formato FreeTube
    */
    function toFreeTubeFormat(internalData) {
        // Redondear valores de tiempo para que FreeTube los muestre correctamente
        const timestamp = internalData.timestamp || 0;
        const duration = internalData.duration || 0;

        // Redondear watchProgress a 2 decimales
        const watchProgress = Math.round(timestamp * 100) / 100;
        // Redondear lengthSeconds a entero (FreeTube espera segundos completos)
        const lengthSeconds = Math.round(duration);

        // IMPORTANTE: FreeTube guarda TODOS los videos (incluyendo shorts) como type:'video'
        // No distingue entre shorts y videos regulares en el campo type
        const result = {
            videoId: internalData.videoId,
            title: internalData.title || 'Unknown Title',
            author: internalData.author || 'Unknown Author',
            authorId: internalData.authorId || '',
            published: internalData.published || null,
            description: internalData.description || '',
            viewCount: typeof internalData.viewsNumber === 'string'
                ? parseInt(internalData.viewsNumber.replace(/[,.\s]/g, '')) || 0
                : (internalData.viewsNumber || 0),
            lengthSeconds: lengthSeconds, // Redondeado a entero
            watchProgress: watchProgress, // Redondeado a 2 decimales
            timeWatched: internalData.lastUpdated || internalData.savedAt || Date.now(),
            isLive: internalData.isLive || false,
            type: 'video', // FreeTube siempre usa 'video', incluso para shorts
            // Metadatos de playlist (FreeTube los incluye siempre, aunque sean null)
            lastViewedPlaylistId: internalData.lastViewedPlaylistId || null,
            lastViewedPlaylistType: internalData.lastViewedPlaylistType || '',
            lastViewedPlaylistItemId: internalData.lastViewedPlaylistItemId || null
        };

        return result;
    }

    /**
    * Parsea un archivo SQLite de FreeTube para extraer el historial
    * @param {ArrayBuffer} arrayBuffer - Datos del archivo .db
    * @returns {Array} Array de videos en formato FreeTube
    */
    async function parseFreeTubeDB(arrayBuffer) {
        try {
            // Convertir a string para buscar patrones de texto
            const uint8Array = new Uint8Array(arrayBuffer);
            let text = '';

            // Extraer texto legible del archivo binario
            for (let i = 0; i < uint8Array.length; i++) {
                const byte = uint8Array[i];
                if (byte >= 32 && byte <= 126) { // Caracteres imprimibles
                    text += String.fromCharCode(byte);
                } else {
                    text += ' '; // Reemplazar bytes no imprimibles
                }
            }

            // Buscar patrones JSON en el texto
            const jsonObjects = [];
            const jsonPattern = /\{[^}]*"videoId"[^}]*\}/g;

            let match;
            while ((match = jsonPattern.exec(text)) !== null) {
                try {
                    // Limpiar y parsear el objeto JSON
                    let cleanJson = match[0];

                    // Intentar parsear directamente
                    const obj = JSON.parse(cleanJson);
                    if (obj.videoId) {
                        jsonObjects.push(obj);
                    }
                } catch (e) {
                    // Si falla, intentar reparar JSON com√∫n
                    try {
                        let cleanJson = match[0]
                            .replace(/,\s*}/g, '}') // Remove trailing commas
                            .replace(/,\s*]/g, ']'); // Remove trailing commas in arrays

                        const obj = JSON.parse(cleanJson);
                        if (obj.videoId) {
                            jsonObjects.push(obj);
                        }
                    } catch (e2) {
                        // Ignorar objetos que no se pueden parsear
                    }
                }
            }

            // Si no se encontraron objetos con el patr√≥n anterior, buscar m√°s ampliamente
            if (jsonObjects.length === 0) {
                // Buscar cualquier objeto que parezca un video de YouTube
                const broaderPattern = /\{[^}]*"videoId"\s*:\s*"[^"]*"[^}]*\}/g;
                let broaderMatch;
                while ((broaderMatch = broaderPattern.exec(text)) !== null) {
                    try {
                        const obj = JSON.parse(broaderMatch[0]);
                        if (obj.videoId && obj.videoId.length > 5) {
                            jsonObjects.push(obj);
                        }
                    } catch (e) {
                        // Ignorar errores
                    }
                }
            }

            log('parseFreeTubeDB', `Encontrados ${jsonObjects.length} videos en la base de datos`);
            return jsonObjects;

        } catch (error) {
            conError('parseFreeTubeDB', 'Error parseando DB:', error);
            return [];
        }
    }

    /**
     * Convierte el formato FreeTube a formato interno
     * @param {Object} freeTubeData - Datos en formato FreeTube
     * @returns {Object} Datos en formato interno del script
     */
    function fromFreeTubeFormat(freeTubeData) {
        // Generar thumbnail URL directamente sin depender del contexto de la p√°gina
        const videoId = freeTubeData.videoId;
        let thumbnailUrl;

        if (videoId && typeof videoId === 'string' && videoId.length >= 11) {
            // Usar URL directa de YouTube como fallback confiable
            thumbnailUrl = `https://i.ytimg.com/vi/${videoId}/maxresdefault.jpg`;
        } else {
            // Fallback adicional si el videoId es inv√°lido
            thumbnailUrl = 'https://i.ytimg.com/vi/default/maxresdefault.jpg';
        }

        // Determinar si el video est√° completado basado en el progreso
        const watchProgress = freeTubeData.watchProgress || 0;
        const lengthSeconds = freeTubeData.lengthSeconds || 0;
        let isCompleted = false;

        if (lengthSeconds > 0) {
            // Considerar completado si el progreso es >= 95% o si quedan menos de 30 segundos
            const progressPercent = (watchProgress / lengthSeconds) * 100;
            const remainingSeconds = lengthSeconds - watchProgress;
            isCompleted = progressPercent >= CONFIG.defaultSettings.staticFinishPercent || remainingSeconds <= 30;
        }

        return {
            videoId: freeTubeData.videoId,
            title: freeTubeData.title,
            author: freeTubeData.author,
            authorId: freeTubeData.authorId,
            thumb: thumbnailUrl,
            viewsNumber: freeTubeData.viewCount ? freeTubeData.viewCount.toLocaleString() : 'N/D',
            savedAt: freeTubeData.timeWatched,
            duration: freeTubeData.lengthSeconds,
            timestamp: freeTubeData.watchProgress,
            lastUpdated: freeTubeData.timeWatched,
            videoType: freeTubeData.type === 'short' ? 'shorts' : 'watch',
            isCompleted: isCompleted,
            published: freeTubeData.published,
            description: freeTubeData.description,
            isLive: freeTubeData.isLive || false,
            // Preservar metadatos de playlist
            lastViewedPlaylistId: freeTubeData.lastViewedPlaylistId || null,
            lastViewedPlaylistType: freeTubeData.lastViewedPlaylistType || '',
            lastViewedPlaylistItemId: freeTubeData.lastViewedPlaylistItemId || null
        };
    }

    /**
    * Exporta todos los videos guardados en formato FreeTube
    * @returns {Array} Array de videos en formato FreeTube
    */
    async function exportToFreeTubeFormat() {
        const videoKeys = Storage.keys().filter(key =>
            !key.includes('userSettings') &&
            !key.includes('userFilters') &&
            !key.startsWith('playlist_meta_') // Excluir metadata de playlists
        );

        const freeTubeData = [];
        let videoCount = 0;
        let shortCount = 0;

        for (const key of videoKeys) {
            const data = Storage.get(key);
            if (!data) continue;

            // Compatibilidad con formato antiguo (playlists anidadas)
            if (data.videos) {
                log('exportToFreeTubeFormat', `Exportando playlist antigua ${key} con ${Object.keys(data.videos).length} videos`);
                Object.entries(data.videos).forEach(([vidKey, videoObj]) => {
                    const internal = Object.assign({}, videoObj, { videoId: videoObj.videoId || vidKey });
                    const formatted = toFreeTubeFormat(internal);
                    freeTubeData.push(formatted);
                    if (formatted.type === 'short') shortCount++;
                    else videoCount++;
                });
            } else {
                // Formato FreeTube: el video ya est√° en el formato correcto, solo mapear campos si es necesario
                const internal = Object.assign({}, data, { videoId: data.videoId || key });
                const formatted = toFreeTubeFormat(internal);
                freeTubeData.push(formatted);
                if (formatted.type === 'short') {
                    shortCount++;
                    log('exportToFreeTubeFormat', `Short detectado: ${formatted.videoId} | videoType: ${internal.videoType}`);
                } else {
                    videoCount++;
                }
            }
        }

        log('exportToFreeTubeFormat', `Exportando ${freeTubeData.length} items: ${videoCount} videos, ${shortCount} shorts`);
        return freeTubeData;
    }

    /**
    * Importa videos desde formato FreeTube
    * @param {Array} freeTubeData - Array de videos en formato FreeTube
    * @returns {Object} Resultado de la importaci√≥n { imported: number, failed: number }
    */
    async function importFromFreeTubeFormat(freeTubeData) {
        let imported = 0;
        let failed = 0;

        // Validar que los datos sean un array
        if (!Array.isArray(freeTubeData)) {
            conError('importFromFreeTubeFormat', 'Los datos no son un array v√°lido');
            return { imported: 0, failed: 0, total: 0 };
        }

        for (const video of freeTubeData) {
            try {
                // Validar que el video tenga los campos m√≠nimos requeridos
                if (!video || typeof video !== 'object') {
                    conError('importFromFreeTubeFormat', 'Video inv√°lido: no es un objeto');
                    failed++;
                    continue;
                }

                if (!video.videoId) {
                    conError('importFromFreeTubeFormat', 'Video inv√°lido: no tiene videoId');
                    failed++;
                    continue;
                }

                // Validar que el videoId tenga un formato v√°lido
                if (typeof video.videoId !== 'string' || video.videoId.length < 5) {
                    conError('importFromFreeTubeFormat', `VideoId inv√°lido: ${video.videoId}`);
                    failed++;
                    continue;
                }

                const internalFormat = fromFreeTubeFormat(video);

                // Validaci√≥n adicional del formato interno
                if (!internalFormat || !internalFormat.videoId) {
                    conError('importFromFreeTubeFormat', 'Error al convertir formato interno');
                    failed++;
                    continue;
                }

                Storage.set(video.videoId, internalFormat);
                imported++;
                log('importFromFreeTubeFormat', `‚úÖ Importado: ${video.videoId} - ${video.title || 'Sin t√≠tulo'}`);
            } catch (error) {
                conError('importFromFreeTubeFormat', `Error importando ${video?.videoId || 'desconocido'}:`, error);
                failed++;
            }
        }

        log('importFromFreeTubeFormat', `Importaci√≥n completada: ${imported} exitosos, ${failed} fallidos, total ${freeTubeData.length}`);
        return { imported, failed, total: freeTubeData.length };
    }

    // ------------------------------------------
    // MARK: üì∫ Helpers
    // ------------------------------------------
    // MARK: üì∫ Obtiene datos guardados de un video
    /**
    * Obtiene datos guardados de un video, intentando todas las combinaciones posibles.
    * Soporta tanto videos individuales como en playlist.
    *
    * @param {string} videoId - ID del video
    * @param {string|null} playlistId - ID de la playlist (opcional)
    * @returns {Object|null} - Datos guardados o null si no se encuentra
    */
    function getSavedVideoData(videoId, playlistId = null) {
        log('getSavedVideoData', `Buscando datos guardados para ID: ${videoId} | Playlist ID: ${playlistId}`);
        if (!videoId) return null;

        // En el formato FreeTube, todos los videos se guardan con video_id como clave
        // independientemente de si fueron vistos en una playlist o no
        const videoData = Storage.get(videoId);

        if (videoData) {
            // Si encontramos el video y se especific√≥ un playlistId, verificar compatibilidad
            if (playlistId && videoData.lastViewedPlaylistId === playlistId) {
                log('getSavedVideoData', `‚úÖ Video encontrado con playlist coincidente`);
                return videoData;
            } else if (!playlistId) {
                log('getSavedVideoData', `‚úÖ Video encontrado (sin filtro de playlist)`);
                return videoData;
            } else {
                // Video encontrado pero fue visto en otra playlist o sin playlist
                log('getSavedVideoData', `‚ö† Video encontrado pero en contexto diferente (guardado: ${videoData.lastViewedPlaylistId}, buscado: ${playlistId})`);
                return videoData; // A√∫n as√≠ retornar para backward compatibility
            }
        }

        // Compatibilidad con formato antiguo (playlists anidadas)
        if (playlistId) {
            const oldPlaylistData = Storage.get(playlistId);
            if (oldPlaylistData?.videos?.[videoId]) {
                log('getSavedVideoData', `‚úÖ Video encontrado en formato antiguo (playlist anidada)`);
                return oldPlaylistData.videos[videoId];
            }
        }

        // B√∫squeda flexible: por si alguna vez se guard√≥ con prefijos raros
        const keys = Storage.keys?.() || [];
        const altKey = keys.find(k => k.endsWith(videoId) || k.includes(videoId));
        if (altKey && altKey !== `playlist_meta_${videoId}`) {
            log('getSavedVideoData', `‚úÖ Video encontrado con clave alternativa: ${altKey}`);
            return Storage.get(altKey);
        }

        log('getSavedVideoData', `‚úó No se encontraron datos para el video`);
        return null;
    }

    // MARK: üì∫ Normaliza las claves de almacenamiento de YouTube
    /**
    * @function normalizeYouTubeStorageKeys
    * @description
    * Normaliza las claves almacenadas en `Storage` que est√©n relacionadas con YouTube.
    * Revisa todas las claves, intenta extraer o corregir los IDs de video,
    * y migra los datos a claves normalizadas, evitando duplicados.
    *
    * @returns {void} No devuelve ning√∫n valor. Realiza operaciones directamente sobre `Storage`.
    *
    * @example
    * // Ejemplo de uso:
    * normalizeYouTubeStorageKeys();
    *
    * // Este proceso:
    * //  - Lee todas las claves del almacenamiento
    * //  - Detecta las que contienen identificadores de videos no normalizados
    * //  - Crea nuevas claves con el formato correcto y migra los datos
    */
    async function normalizeYouTubeStorageKeys() {
        const NORMALIZE_VERSION = 1; // Incrementar si cambia la l√≥gica de normalizaci√≥n
        const NORMALIZE_KEY = 'ypp_normalize_storage_keys_version';

        // Evitar re-ejecuci√≥n si ya se aplic√≥ esta versi√≥n
        try {
            const last = await GM_getValue(NORMALIZE_KEY, 0);
            if (last >= NORMALIZE_VERSION) {
                log('normalizeYouTubeStorageKeys', `‚úÖ Normalizaci√≥n ya aplicada (versi√≥n ${last})`);
                return;
            }
        } catch (e) {
            // Si falla GM_getValue, continuar sin bloquear la normalizaci√≥n
            warn('normalizeYouTubeStorageKeys', 'No se pudo leer versi√≥n de normalizaci√≥n, continuando...', e);
        }
        // Verifica si el objeto Storage tiene disponible el m√©todo keys()
        if (typeof Storage?.keys !== 'function') {
            conError('normalizeYouTubeStorageKeys', 'Storage.keys() no disponible.');
            return;
        }

        // Obtiene todas las claves almacenadas
        const allKeys = Storage.keys();
        // Contador para llevar registro de cu√°ntas claves se han migrado
        let changes = 0;

        // Recorre todas las claves encontradas en el almacenamiento
        for (const key of allKeys) {
            // Intenta extraer o normalizar el ID del video desde la clave
            const newKey = extractOrNormalizeVideoId(key)?.id;

            // Registra la operaci√≥n en el log
            log('normalizeYouTubeStorageKeys', `Clave original: ${key} | Clave nueva: ${newKey}`);

            // Si se obtuvo un ID v√°lido y diferente de la clave original
            if (newKey && newKey !== key) {
                // Obtiene los datos asociados a la clave antigua
                const data = Storage.get(key);

                // Solo migra si la nueva clave a√∫n no existe (para evitar sobrescribir datos)
                if (!Storage.get(newKey)) {
                    Storage.set(newKey, data);  // Guarda los datos bajo la nueva clave
                    Storage.del(key);           // Elimina la clave antigua
                    log('normalizeYouTubeStorageKeys', `‚úÖ Migrado: "${key}" -> "${newKey}"`);
                    changes++;
                } else {
                    // Si la nueva clave ya existe, registra un aviso de duplicado
                    log('normalizeYouTubeStorageKeys', `‚ö†Ô∏è Duplicado detectado: "${key}" ya existe como "${newKey}"`);
                }
            }
        }

        // Muestra un resumen al final del proceso
        log('normalizeYouTubeStorageKeys', `üîÅ Normalizaci√≥n completa. ${changes} claves migradas.`);

        // Marcar como aplicada esta versi√≥n de normalizaci√≥n para evitar re-ejecuciones
        try {
            await GM_setValue(NORMALIZE_KEY, NORMALIZE_VERSION);
            log('normalizeYouTubeStorageKeys', `üìù Versi√≥n de normalizaci√≥n guardada: ${NORMALIZE_VERSION}`);
        } catch (e) {
            warn('normalizeYouTubeStorageKeys', 'No se pudo guardar versi√≥n de normalizaci√≥n', e);
        }
    }


    // MARK: üì∫ Get YouTube Page Type
    /**
    * Determina el tipo de p√°gina actual en YouTube seg√∫n la URL.
    * 
    * Analiza la ruta (`window.location.pathname`) y devuelve un identificador
    * descriptivo del tipo de p√°gina (por ejemplo: "home", "shorts", "watch", "channel", etc.).
    * 
    * @returns {string} - Tipo de p√°gina detectada. Puede ser uno de:
    *   - `'home'` ‚Äî P√°gina principal de YouTube
    *   - `'shorts'` ‚Äî P√°gina de YouTube Shorts
    *   - `'watch'` ‚Äî P√°gina de reproducci√≥n de un video
    *   - `'embed'` ‚Äî P√°gina de video embebido
    *   - `'playlist'` ‚Äî P√°gina de una lista de reproducci√≥n
    *   - `'search'` ‚Äî P√°gina de resultados de b√∫squeda
    *   - `'music'` ‚Äî P√°gina de YouTube Music (canal oficial)
    *   - `'gaming'` ‚Äî P√°gina de YouTube Gaming
    *   - `'news'` ‚Äî P√°gina de noticias
    *   - `'sports'` ‚Äî P√°gina de deportes
    *   - `'learning'` ‚Äî P√°gina de aprendizaje
    *   - `'you'` ‚Äî P√°gina "Tu espacio" (feed personal)
    *   - `'history'` ‚Äî P√°gina del historial de reproducciones
    *   - `'subscriptions'` ‚Äî P√°gina de suscripciones
    *   - `'live'` ‚Äî Transmisi√≥n en vivo o enlace directo a live
    *   - `'channel'` ‚Äî P√°gina de canal (personalizada, por ID o nombre)
    *   - `'unknown'` ‚Äî Si no coincide con ninguno de los anteriores
    */
    function getYouTubePageType() {
        // Obtener la ruta actual de la URL (sin dominio)
        const path = window.location.pathname;

        // Comprobaciones directas de ruta
        if (path === '/') return 'home';
        if (path.startsWith('/shorts')) return 'shorts';
        if (path.startsWith('/watch')) return 'watch';
        if (path.startsWith('/embed')) return 'embed';
        if (path.startsWith('/playlist')) return 'playlist';
        if (path.startsWith('/results')) return 'search';

        // Comprobaciones por canal o categor√≠a especial (IDs fijos de YouTube)
        if (path.endsWith('/UC-9-kyTW8ZkZNDHQJ6FgpwQ')) return 'music';     // Canal oficial de YouTube Music
        if (path.startsWith('/gaming')) return 'gaming';                    // Secci√≥n de Gaming
        if (path.endsWith('/UCYfdidRxbB8Qhf0Nx7ioOYw')) return 'news';      // Canal de Noticias
        if (path.endsWith('/UCEgdi0XIXXZ-qJOFPf4JSKw')) return 'sports';    // Canal de Deportes
        if (path.endsWith('/UCtFRv9O2AHqOZjjynzrv-xg')) return 'learning';  // Canal de Aprendizaje

        // Feeds personales del usuario
        if (path.endsWith('/feed/you')) return 'you';
        if (path.endsWith('/feed/history')) return 'history';
        if (path.endsWith('/feed/subscriptions')) return 'subscriptions';

        // Detecci√≥n de videos en vivo o enlaces con "/live"
        // Ejemplo: https://www.youtube.com/@NASA/live
        // Para raros casos, ya que Youtube usa "/watch" igual para directos.
        if (path.includes('/live')) return 'live';

        // Posibles rutas de canales de usuario
        const channelPaths = [
            '/@',        // Canal personalizado (nuevo formato: /@nombre)
            '/channel',  // Canal por ID (formato: /channel/UCxxxx)
            '/c',        // Canal personalizado (antiguo: /c/nombre)
            '/user',     // Canal de usuario cl√°sico (muy antiguo)
            '/UC'        // Canal directo por ID (raro)
        ];

        // Si la ruta coincide con alguno de los prefijos de canal, se considera canal
        if (channelPaths.some(prefix => path.startsWith(prefix))) return 'channel';

        // Si no se reconoce la ruta, devolvemos "unknown"
        return 'unknown';
    }

    // ------------------------------------------
    // MARK: üì∫ Get Video Element
    // ------------------------------------------
    // Helper para encontrar el <video> actual
    async function getActiveVideoElement() {
        // Prioridad: YouTube Helper API
        if (YTHelper?.player?.videoElement) {
            log('getActiveVideoElement', '‚úÖ Usando YTHelper.player.videoElement');
            return YTHelper.player.videoElement;
        }

        log('getActiveVideoElement', '‚ö†Ô∏è YouTube Helper API no disponible, usando b√∫squeda DOM');

        const selectors = [
            // === SHORTS ===
            'ytd-reel-video-renderer #short-video-container ytd-player div.html5-video-container video',
            'ytd-reel-video-renderer video.reel-video-player-element',
            'ytd-shorts video.html5-main-video',
            '#shorts-player video',

            // === VIDEOS REGULARES (en p√°gina de reproducci√≥n) ===
            '#movie_player video.html5-main-video',
            '.html5-video-player video.html5-main-video',

            // === MINIPLAYER FLOTANTE (Picture-in-Picture / Miniplayer) ===
            // Este es el clave para cuando el usuario vuelve al homepage o cambia a shorts desde video regular reproduciendose
            '#movie_player',
            '.ytp-miniplayer-ui video.html5-main-video',
            '#miniplayer video.html5-main-video',
            'ytd-miniplayer video',
            '.html5-video-container video', // m√°s gen√©rico, pero √∫til

            // === FALLBACKS GEN√âRICOS (evitando previews) ===
            'video:not([data-no-fullscreen])',
            'video'
        ];

        const candidates = selectors.flatMap(selector => {
            const elements = Array.from(document.querySelectorAll(selector));
            log('getActiveVideoElement', `Selector "${selector}": ${elements.length} elementos`);
            return elements;
        });

        log('getActiveVideoElement', `Total de candidatos: ${candidates.length}`);

        const visibleVideos = candidates.filter(video => {
            if (!video) return false;

            const rect = video.getBoundingClientRect();
            const isVisible = rect.width > 50 && rect.height > 50; // m√°s permisivo para miniplayer
            const hasSource = video.src || video.currentSrc || video.querySelector('source');
            const isPlaying = !video.paused;
            const hasDuration = video.duration > 0;

            log('getActiveVideoElement', `Video: ${video.currentSrc?.substring(0, 50)}... | Visible: ${isVisible} | Tama√±o: ${rect.width}x${rect.height} | Reproduciendo: ${isPlaying}`);

            return isVisible && hasSource && hasDuration;
        });

        log('getActiveVideoElement', `Videos visibles y reproducibles: ${visibleVideos.length}`);

        if (visibleVideos.length === 0) return null;

        // === PRIORIZAR: Miniplayer > Reproductor principal > Shorts > Otros ===
        const miniplayer = visibleVideos.find(v =>
            v.closest('.ytp-miniplayer-ui') ||
            v.closest('#miniplayer') ||
            v.closest('ytd-miniplayer')
        );
        if (miniplayer) {
            log('getActiveVideoElement', 'Miniplayer flotante detectado y seleccionado');
            return miniplayer;
        }

        const mainPlayer = visibleVideos.find(v =>
            v.closest('#movie_player') ||
            v.closest('.html5-video-player')
        );
        if (mainPlayer) {
            log('getActiveVideoElement', 'Reproductor principal detectado');
            return mainPlayer;
        }

        const shortsPlayer = visibleVideos.find(v =>
            v.closest('ytd-reel-video-renderer') ||
            v.closest('ytd-shorts') ||
            v.closest('#shorts-player')
        );
        if (shortsPlayer) {
            log('getActiveVideoElement', 'Shorts detectado');
            return shortsPlayer;
        }

        // √öltimo recurso
        log('getActiveVideoElement', 'Usando primer <video> visible como fallback');
        return visibleVideos[0];
    }

    // ------------------------------------------
    // MARK: üì∫ Get Container
    // ------------------------------------------

    // Helper para encontrar el <container> actual
    function getActiveContainer() {
        // Prioridad: YouTube Helper API
        if (YTHelper?.player?.playerObject) {
            log('getActiveContainer', '‚úÖ Usando YTHelper.player.playerObject');
            return YTHelper.player.playerObject;
        }

        // Fallback a selectores DOM
        const container = (
            // Shorts
            document.querySelector('ytd-reel-video-renderer') || // √önico en DOM
            document.querySelector('#reel-video-renderer') || // √önico en DOM (es id de item ytd-reel-video-renderer)
            document.querySelector('ytd-shorts') || // √önico en DOM
            document.querySelector('#shorts-container') || // √önico en DOM
            // Video normal
            document.querySelector('#player-container-inner #player-container #movie_player') || // √önico en DOM
            document.querySelector('#movie_player') || // √önico en DOM
            document.querySelector('.html5-video-player:not(#inline-preview-player)') || // M√°s de uno en DOM, excluye variante
            document.querySelector('video:not([data-no-fullscreen])') // M√°s de uno en DOM, excluye variante
        );
        
        if (container) {
            log('getActiveContainer', `‚úÖ Container encontrado via DOM: ${container.tagName}${container.id ? '#' + container.id : ''}`);
        } else {
            warn('getActiveContainer', '‚ö†Ô∏è No se encontr√≥ container activo');
        }
        
        return container;
    }

    // ------------------------------------------
    // MARK: üé¨ Get Video Tittle
    // ------------------------------------------

    /**
     * Valida que un t√≠tulo sea el actual comparando con document.title
     * @param {string} candidateTitle - T√≠tulo candidato a validar
     * @returns {boolean} - true si el t√≠tulo es v√°lido
     */
    function validateTitle(candidateTitle) {
        if (!candidateTitle) return false;

        // Durante navegaci√≥n, ser m√°s permisivo ya que document.title puede estar desactualizado
        if (isNavigating) {
            // Validaciones b√°sicas durante navegaci√≥n
            const isReasonableLength = candidateTitle.length > 3 && candidateTitle.length < 500;
            const hasValidChars = /[a-zA-Z0-9]/.test(candidateTitle);
            const isNotGeneric = !['YouTube', 'Loading...', 'Untitled', ''].includes(candidateTitle.trim());

            const isValid = isReasonableLength && hasValidChars && isNotGeneric;

            if (isValid) {
                log('validateTitle', `‚úÖ T√≠tulo validado durante navegaci√≥n: "${candidateTitle}"`);
            } else {
                log('validateTitle', `‚ùå T√≠tulo rechazado durante navegaci√≥n: "${candidateTitle}" (longitud: ${candidateTitle.length}, hasValidChars: ${hasValidChars}, isNotGeneric: ${isNotGeneric})`);
            }

            return isValid;
        }

        // Validaci√≥n normal cuando no estamos navegando
        const docTitle = document.title.replace(/ - YouTube$/, '').trim();
        if (!docTitle) {
            // Si no hay document.title, usar validaci√≥n b√°sica como fallback
            const isReasonableLength = candidateTitle.length > 3 && candidateTitle.length < 500;
            const hasValidChars = /[a-zA-Z0-9]/.test(candidateTitle);
            const isNotGeneric = !['YouTube', 'Loading...', 'Untitled', ''].includes(candidateTitle.trim());
            return isReasonableLength && hasValidChars && isNotGeneric;
        }

        // Normalizar t√≠tulos para comparaci√≥n (eliminar espacios extras, convertir a min√∫sculas)
        const normalize = (str) => str.toLowerCase().replace(/\s+/g, ' ').trim();
        const normalizedCandidate = normalize(candidateTitle);
        const normalizedDocTitle = normalize(docTitle);

        // Coincidencia exacta o si uno contiene al otro (para casos de t√≠tulos truncados)
        const isValid = normalizedDocTitle === normalizedCandidate ||
            normalizedDocTitle.includes(normalizedCandidate) ||
            normalizedCandidate.includes(normalizedDocTitle);

        if (isValid) {
            log('validateTitle', `‚úÖ T√≠tulo validado: "${candidateTitle}" coincide con document.title: "${docTitle}"`);
        } else {
            log('validateTitle', `‚ùå T√≠tulo NO validado: "${candidateTitle}" no coincide con document.title: "${docTitle}"`);
        }

        return isValid;
    }

    function getVideoTittle(player) {
        // Prioridad: YouTube Helper API
        if (YTHelper?.video?.title) {
            log('getVideoTittle', `T√≠tulo encontrado en YTHelper: ${YTHelper.video.title}`);
            // Validar antes de retornar
            if (validateTitle(YTHelper.video.title)) {
                return YTHelper.video.title;
            }
            warn('getVideoTittle', '‚ö†Ô∏è T√≠tulo de YTHelper no validado, puede ser de video previo');
        }

        // Fallback de Shorts 
        const anchorTitleShorts =
            document.querySelector('yt-formatted-string.ytd-video-description-header-renderer')?.textContent.trim() ||
            document.querySelector('#anchored-panel yt-formatted-string.style-scope.ytd-video-description-header-renderer')?.textContent?.trim();
        if (anchorTitleShorts) {
            log('getVideoTittle', `T√≠tulo encontrado en #anchored-panel: ${anchorTitleShorts}`);
            if (validateTitle(anchorTitleShorts)) {
                return anchorTitleShorts;
            }
            warn('getVideoTittle', '‚ö†Ô∏è T√≠tulo de Shorts anchor no validado');
        }

        // Selectores meta tag y window.ytInitialPlayerResponse pueden tener/regresar datos de videos previos!

        // Si el t√≠tulo est√° en el meta tag, usarlo
        const metaTitleTag = document.querySelector('meta[name="title"]');
        const metaTitle = metaTitleTag ? metaTitleTag.getAttribute('content') : null;
        if (metaTitle) {
            log('getVideoTittle', `T√≠tulo encontrado en meta tag: ${metaTitle}`);
            if (validateTitle(metaTitle)) {
                return metaTitle;
            }
            warn('getVideoTittle', '‚ö†Ô∏è T√≠tulo de meta tag no validado, puede ser de video previo');
        }

        // Fallback si no est√° en meta[name=title]
        const metaOgTitleTag = document.querySelector('meta[property="og:title"]');
        const metaOgTitle = metaOgTitleTag ? metaOgTitleTag.getAttribute('content') : null;
        if (metaOgTitle) {
            log('getVideoTittle', `T√≠tulo encontrado en meta og:title: ${metaOgTitle}`);
            if (validateTitle(metaOgTitle)) {
                return metaOgTitle;
            }
            warn('getVideoTittle', '‚ö†Ô∏è T√≠tulo de og:title no validado, puede ser de video previo');
        }

        // Fallback si no est√° en meta[property="og:title"]
        const metaTwitterTitleTag = document.querySelector('meta[name="twitter:title"]');
        const metaTwitterTitle = metaTwitterTitleTag ? metaTwitterTitleTag.getAttribute('content') : null;
        if (metaTwitterTitle) {
            log('getVideoTittle', `T√≠tulo encontrado en meta twitter:title: ${metaTwitterTitle}`);
            if (validateTitle(metaTwitterTitle)) {
                return metaTwitterTitle;
            }
            warn('getVideoTittle', '‚ö†Ô∏è T√≠tulo de twitter:title no validado, puede ser de video previo');
        }

        // Fallback a JSON incrustado (CUIDADO: puede tener datos de videos previos)
        const title = window.ytInitialPlayerResponse?.videoDetails?.title;
        if (title) {
            log('getVideoTittle', `T√≠tulo encontrado en JSON incrustado: ${title}`);
            if (validateTitle(title)) {
                return title;
            }
            warn('getVideoTittle', '‚ö†Ô∏è T√≠tulo de JSON incrustado no validado, puede ser de video previo');
        }

        /* 
        player.getVideoData() = {
                "video_id": "iy4mXZN1Zzk",
                "author": "robbiewilliamsvevo",
                "title": "Robbie Williams - Feel",
                "isPlayable": true,
                "errorCode": null,
                "video_quality": "medium",
                "video_quality_features": [],
                "list": "RDiy4mXZN1Zzk",
                "backgroundable": false,
                "eventId": "Q-AHae30KbiZ4dUPnbDByQk",
                "cpn": "m6WhMHqg6WQd25ET",
                "isLive": false,
                "isWindowedLive": false,
                "isManifestless": false,
                "allowLiveDvr": false,
                "isListed": true,
                "isMultiChannelAudio": false,
                "hasProgressBarBoundaries": false,
                "isPremiere": false,
                "itct": "CAAQu2kiEwitooPuxtSQAxW4TLgEHR1YMJk=",
                "playerResponseCpn": "",
                "progressBarStartPositionUtcTimeMillis": null,
                "progressBarEndPositionUtcTimeMillis": null,
                "paidContentOverlayDurationMs": 0
            }
        */

        const videoData = player?.getVideoData?.();
        if (videoData != null) {
            log('getVideoTittle', `T√≠tulo encontrado en player.getVideoData(): ${videoData?.title}`);
            if (validateTitle(videoData.title)) {
                return videoData.title;
            }
            warn('getVideoTittle', '‚ö†Ô∏è T√≠tulo de player.getVideoData() no validado, puede ser de video previo');
        }

        // Fallback al DOM
        const DOMSelectors = [
            'ytd-watch-metadata h1 yt-formatted-string',
            'h1.ytd-watch-metadata yt-formatted-string',
            '#title h1 yt-formatted-string',
            'h1 yt-formatted-string',
            '#title h1',
            'h1.title'
            //'h2 span.yt-core-attributed-string' // entrega el nombre pero si existe traducci√≥n activa devuelve esa version, No original.
        ];

        for (const sel of DOMSelectors) {
            const el = document.querySelector(sel);
            const t = el?.textContent.trim();
            if (t) {
                log('getVideoTittle', `T√≠tulo encontrado en DOM: ${t}`);
                if (validateTitle(t)) {
                    return t;
                }
                warn('getVideoTittle', '‚ö†Ô∏è T√≠tulo de DOM no validado, puede ser de video previo');
            }
        }

        // Fallback al <title> del documento, limpiando "- YouTube"
        const docTitle = document.title.replace(/ - YouTube$/, '');
        log('getVideoTittle', `T√≠tulo encontrado en <title>: ${docTitle}`);
        if (validateTitle(docTitle)) {
            return docTitle;
        }
        warn('getVideoTittle', '‚ö†Ô∏è T√≠tulo de <title> no validado, puede ser de video previo');

        // Si llegamos aqu√≠, no pudimos validar ning√∫n t√≠tulo
        // Retornar el primer t√≠tulo encontrado con advertencia
        warn('getVideoTittle', '‚ö†Ô∏è No se pudo validar ning√∫n t√≠tulo, usando primer t√≠tulo disponible');
        return YTHelper?.video?.title ||
            anchorTitleShorts ||
            metaTitle ||
            metaOgTitle ||
            metaTwitterTitle ||
            title ||
            videoData?.title ||
            docTitle ||
            t('unknown');
    }

    // Funci√≥n para obtener el autor del video
    function getVideoAuthor(player) {
        // Prioridad: YouTube Helper API
        if (YTHelper?.video?.channel) {
            log('getVideoAuthor', `Autor encontrado en YTHelper: ${YTHelper.video.channel}`);
            return YTHelper.video.channel;
        }

        // Player API
        const playerAuthor = player?.getVideoData?.()?.author;
        if (playerAuthor) {
            log('getVideoAuthor', `Autor encontrado en player: ${playerAuthor}`);
            return playerAuthor;
        }

        // DOM selectors
        const domAuthor =
            document.querySelector('link[itemprop="name"]')?.getAttribute('content') ||
            document.querySelector('yt-button-shape#subscribe-button-shape button.yt-spec-button-shape-next')?.getAttribute('aria-label')?.replace(/^Subscribe to /, '').replace(/\.$/, '').trim() ||
            document.querySelector('ytd-subscription-notification-toggle-button-renderer-next button.yt-spec-button-shape-next')?.getAttribute('aria-label')?.match(/for (.+)$/)?.[1]?.trim();

        if (domAuthor) {
            log('getVideoAuthor', `Autor encontrado en DOM: ${domAuthor}`);
            return domAuthor;
        }

        log('getVideoAuthor', 'No se pudo obtener autor, usando fallback');
        return t('unknown');
    }

    // ------------------------------------------
    // MARK: üì∫ Get Thumbnail
    // ------------------------------------------

    function getVideoThumbnail(vid) {
        if (!vid) return null;

        let thumb = YTHelper?.video?.thumbnails[0].url;
        if (thumb) return cleanThumbnailUrl(thumb);

        // Desde DOM
        /* 
        <link rel="image_src" href="https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&amp;rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA">
        <meta property="og:image" content="https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&amp;rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA">
        <meta name="twitter:image" content="https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&amp;rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA">
        <link itemprop="thumbnailUrl" href="https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&amp;rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA">
        <link itemprop="url" href="https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&amp;rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA">
        */
        const selectors = [
            'link[rel="image_src"]',
            'meta[property="og:image"]',
            'meta[name="twitter:image"]',
            'link[itemprop="thumbnailUrl"]',
            'link[itemprop="url"]'
        ];

        for (const sel of selectors) {
            const el = document.querySelector(sel);
            const url = el?.content || el?.href;
            if (url) return cleanThumbnailUrl(url);
        }

        // Desde el div de YouTube player
        /*
        <div class="ytp-cued-thumbnail-overlay-image" style="background-image: url(&quot;https://i.ytimg.com/vi_webp/${vid}/maxresdefault.webp&quot;);"></div>
        */
        const thumbDiv = document.querySelector('.ytp-cued-thumbnail-overlay-image');
        if (thumbDiv) {
            const style = thumbDiv.style.backgroundImage;
            const match = style.match(/url\((['"]?)(.*?)\1\)/);
            if (match) return match[2];
        }

        // Desde JSON incrustado
        /* 
        "microformat":{"playerMicroformatRenderer":{"thumbnail":{"thumbnails":[{"url":"https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=\u0026rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA","width":405,"height":720}],
        */
        try {

            const url = window.ytInitialPlayerResponse?.microformat?.playerMicroformatRenderer?.thumbnail?.thumbnails?.[0]?.url;

            if (url != null && vid && url?.includes(vid)) {
                return cleanThumbnailUrl(url);
            }
        } catch (err) {
            warn('Error al obtener thumbnail desde JSON:', err);
        }

        // Fallback final
        return `https://i.ytimg.com/vi/${vid}/maxresdefault.jpg`;
    }

    // Limpia par√°metros innecesarios de la URL
    function cleanThumbnailUrl(url) {
        const match = url.match(/^(https:\/\/i\.ytimg\.com\/vi\/[A-Za-z0-9_-]+\/[^?]+)/);
        return match ? match[1] : url;
    }

    // ------------------------------------------
    // MARK: üì∫ Get Video Info
    // ------------------------------------------

    // Cache por video
    const viewCountCache = new Map();

    async function getVideoInfo(player, videoId) {
        const now = Date.now();

        // T√≠tulo y autor
        let title = getVideoTittle(player);
        let author = getVideoAuthor(player);

        // Thumbnail
        let thumb = getVideoThumbnail(videoId)

        // Datos adicionales para compatibilidad con FreeTube
        let published = YTHelper?.video?.publishDate?.getTime() ||
            (YTHelper?.video?.rawPublishDate ? new Date(YTHelper.video.rawPublishDate).getTime() : null);

        let description =
            YTHelper?.video?.rawDescription?.trim() ??
            document.querySelector('div#snippet span.yt-formatted-string')?.textContent?.trim() ??
            /*   document.querySelector('meta[name="description"]')?.getAttribute('content') ??
              document.querySelector('meta[property="og:description"]')?.getAttribute('content') ??
              document.querySelector('meta[name="twitter:description"]')?.getAttribute('content') ??
              document.querySelector('meta[itemprop="description"]')?.getAttribute('content') ?? */
            document.querySelector('div#expanded.ytd-text-inline-expander yt-attributed-string yt-core-attributed-string yt-core-attributed-string--link-inherit-color')?.textContent?.trim() ??
            document.querySelector('#inline-expander div#snippet.ytd-text-inline-expander yt-attributed-string')?.textContent.trim() ??
            '';


        log('getVideoInfo', ' üìù Descripci√≥n 0= ', YTHelper?.video?.rawDescription)
        log('getVideoInfo', ' üìù Descripci√≥n 1= ', document.querySelector('div#snippet span.yt-formatted-string')?.textContent?.trim())
        /*  log('getVideoInfo', ' üìù Descripci√≥n 2= ', document.querySelector('meta[name="description"]')?.getAttribute('content'))
            log('getVideoInfo', ' üìù Descripci√≥n 3= ', document.querySelector('meta[property="og:description"]')?.getAttribute('content'))
            log('getVideoInfo', ' üìù Descripci√≥n 4= ', document.querySelector('meta[name="twitter:description"]')?.getAttribute('content'))
            log('getVideoInfo', ' üìù Descripci√≥n 5= ', document.querySelector('meta[itemprop="description"]')?.getAttribute('content')) */
        log('getVideoInfo', ' üìù Descripci√≥n 6= ', document.querySelector('div#expanded.ytd-text-inline-expander yt-attributed-string yt-core-attributed-string yt-core-attributed-string--link-inherit-color')?.textContent?.trim())
        log('getVideoInfo', ' üìù Descripci√≥n 7= ', document.querySelector('#inline-expander div#snippet.ytd-text-inline-expander yt-attributed-string')?.textContent.trim())

        let isLive = YTHelper?.video?.isCurrentlyLive || false;

        // Views
        let viewsNumber;
        if (YTHelper?.video?.viewCount) {
            viewsNumber = Number(YTHelper.video.viewCount).toLocaleString();
        } else if (window.ytInitialPlayerResponse?.videoDetails?.viewCount != null) {
            viewsNumber = Number(window.ytInitialPlayerResponse.videoDetails.viewCount).toLocaleString();
        } else {
            viewsNumber =
                document.querySelector('.view-count')?.textContent?.match(/[\d.,\s]+/)?.[0].trim() ||
                document.querySelector('view-count-factoid-renderer .ytwFactoidRendererFactoid[role="text"]')?.getAttribute('aria-label')?.match(/[\d.,\s]+/)?.[0].trim() ||
                document.querySelector('ytd-watch-info-text div#tooltip.tp-yt-paper-tooltip')?.textContent?.match(/[\d.,\s]+/)?.[0].trim() ||
                document.querySelector('yt-formatted-string.view-count')?.textContent?.match(/[\d.,\s]+/)?.[0].trim() ||
                t('notAvailable');
        }

        const videoEl = await getActiveVideoElement();
        let duration = normalizeSeconds(getVideoDuration(player, videoEl));
        log('getVideoInfo', ' üïï Duraci√≥n tras normalizeSeconds = ', duration);

        // Autor ID (Channel ID)
        let authorId =
            YTHelper?.video?.channelId || // Prioridad a YouTube Helper API
            window.ytInitialPlayerResponse?.videoDetails?.channelId ||
            // Videos regulares
            document.querySelector('#upload-info a.yt-simple-endpoint')?.href?.split('/channel/')[1] ||
            document.querySelector('a.ytp-ce-channel-title.ytp-ce-link')?.href?.split('/channel/')[1] ||
            document.querySelector('#items yt-button-shape a')?.href?.split('/channel/')[1]?.split('/')[0] ||
            document.querySelector('#infocard-channel-button yt-button-shape a')?.href?.split('/channel/')[1]?.split('/')[0] ||
            // Shorts
            document.querySelector('link[rel="canonical"]')?.href?.split('/channel/')[1] ||
            document.querySelector('meta[property="og:url"]')?.content?.split('/channel/')[1] ||
            document.querySelector('link[itemprop="url"]')?.href?.split('/channel/')[1] ||
            t('unknown');

        // Cach√© de views
        const cached = viewCountCache.get(videoId);
        if (!cached || (now - cached.time) > 5000) {
            viewCountCache.set(videoId, { views: viewsNumber, time: now });
        } else {
            viewsNumber = cached.views;
        }

        log('getVideoInfo', 'Info Obtenida:', { title, author, thumb, viewsNumber, savedAt: now, duration, authorId, videoId, published, description, isLive })
        return {
            title,
            author,
            thumb,
            viewsNumber,
            savedAt: now,
            duration,
            authorId,
            videoId,
            published,
            description,
            isLive
        };
    }

    // ------------------------------------------
    // MARK: üì∫ get Video Duration
    // ------------------------------------------

    function getVideoDuration(player, videoEl) {
        let duration;

        // Player directo
        // 275.421
        duration = player?.getDuration?.();
        log('getVideoDuration', 'duraci√≥n player.getDuration', duration)
        if (duration && duration > 0 && !isNaN(duration)) return duration;

        // movie_player global
        // 275.421
        duration = document.querySelector('#movie_player')?.getDuration?.();
        log('getVideoDuration', 'duraci√≥n movie_player.getDuration', duration)
        if (duration && duration > 0 && !isNaN(duration)) return duration;

        // PlayerObject
        // 275.421
        duration = player?.playerObject?.getDuration?.();
        log('getVideoDuration', 'duraci√≥n playerObject.getDuration', duration)
        if (duration && duration > 0 && !isNaN(duration)) return duration;

        // Elemento video
        // 275.421
        duration = videoEl?.duration;
        log('getVideoDuration', 'duraci√≥n videoEl.duration', duration)
        if (duration && duration > 0 && !isNaN(duration)) return duration;

        // YouTube Helper API (no da decimales)
        // 275 no da decimales!
        duration = YTHelper?.video?.lengthSeconds;
        log('getVideoDuration', 'duraci√≥n YTHelper.video.lengthSeconds', duration)
        if (duration && duration > 0 && !isNaN(duration)) return duration;

        // ytp-time-duration (no da decimales)
        // "4:35" -> parseTimeToSeconds -> 275 no da decimales!
        duration = document.querySelector('.ytp-time-duration')?.textContent;
        log('getVideoDuration', 'duraci√≥n document.querySelector(.ytp-time-duration).textContent', duration)
        if (duration) {
            const parsedDuration = parseTimeToSeconds(duration.trim());
            if (parsedDuration && parsedDuration > 0 && !isNaN(parsedDuration)) return parsedDuration;
        }

        // meta[itemprop="duration"] (no da decimales)
        // "PT4M35S" -> parseISODuration -> 275  no da decimales!
        duration = document.querySelector('meta[itemprop="duration"]')?.content;
        log('getVideoDuration', 'duraci√≥n document.querySelector(meta[itemprop="duration"]).content', duration)
        if (duration) {
            const parsedDuration = parseISODuration(duration);
            if (parsedDuration && parsedDuration > 0 && !isNaN(parsedDuration)) return parsedDuration;
        }

        // Si todav√≠a no se obtuvo, probar con el <video> real
        // 275.421
        if (!duration || isNaN(duration) || duration === 0) {
            if (videoEl) {
                // Esperar a que el <video> cargue los metadatos si a√∫n no lo ha hecho
                if (isNaN(videoEl.duration) || videoEl.duration === 0) {
                    // Retornar una promesa que esperar√° los metadatos
                    return new Promise(resolve => {
                        const checkDuration = () => {
                            if (!isNaN(videoEl.duration) && videoEl.duration > 0) {
                                log('getVideoDuration', 'duraci√≥n videoEl.duration (despu√©s de esperar metadatos)', videoEl.duration);
                                resolve(videoEl.duration);
                            } else {
                                videoEl.addEventListener('loadedmetadata', () => {
                                    log('getVideoDuration', 'duraci√≥n videoEl.duration (despu√©s de loadedmetadata)', videoEl.duration);
                                    resolve(videoEl.duration);
                                }, { once: true });
                                // Timeout por si nunca se cargan los metadatos
                                setTimeout(() => {
                                    log('getVideoDuration', 'timeout esperando metadatos, usando 0');
                                    resolve(0);
                                }, 3000);
                            }
                        };
                        checkDuration();
                    });
                } else {
                    duration = videoEl.duration;
                    log('getVideoDuration', 'duraci√≥n videoEl.duration (directo)', duration);
                    return duration;
                }
            }
        }

        return 0;
    }

    // ------------------------------------------
    // MARK: üì∫ Extraer o Normalizar Video ID
    // ------------------------------------------

    /**
    * Extrae o normaliza un video ID de YouTube desde URL, embed o ID directo.
    * Soporta:
    *  - URLs normales: watch?v=ID
    *  - Shorts: /shorts/ID
    *  - Short URLs: youtu.be/ID
    *  - Embeds: /embed/ID
    *  - IDs directos
    * @param {string} input - URL completa o ID de video.
    * @returns {string|null} - Video ID o null si no se pudo determinar.
    */
    function extractOrNormalizeVideoId(input) {
        if (!input || typeof input !== 'string') return null;
        const trimmed = input.trim();

        // Si es solo un ID directo (no URL)
        if (/^[A-Za-z0-9_-]{6,}$/.test(trimmed)) {
            return { type: "video", id: trimmed };
        }

        try {
            const url = new URL(trimmed);

            // --- LISTAS ---
            const listParam = url.searchParams.get("list");
            if (url.pathname.includes("/playlist") && listParam) {
                return { type: "playlist", id: listParam };
            }

            // --- VIDEOS ---
            // watch?v=ID
            const vParam = url.searchParams.get("v");
            if (vParam) {
                const result = { type: "video", id: vParam };
                if (listParam) result.list = listParam; // video dentro de lista
                return result;
            }

            // shorts/ID
            const shortsMatch = url.pathname.match(/\/shorts\/([A-Za-z0-9_-]{6,})/);
            if (shortsMatch) return { type: "video", id: shortsMatch[1] };

            // embed/ID
            const embedMatch = url.pathname.match(/\/embed\/([A-Za-z0-9_-]{6,})/);
            if (embedMatch) return { type: "video", id: embedMatch[1] };

            // short URL (youtu.be/ID)
            if (url.hostname.includes("youtu.be")) {
                const shortId = url.pathname.slice(1);
                if (/^[A-Za-z0-9_-]{6,}$/.test(shortId)) {
                    const result = { type: "video", id: shortId };
                    if (listParam) result.list = listParam;
                    return result;
                }
            }
        } catch {
            // Si no es URL v√°lida, continuar
        }

        // Si todo falla
        warn("extractOrNormalizeVideoId: no se pudo determinar video_id para", input);
        return null;
    }

    // MARK: üì∫ Is Live Video
    function isLiveVideo() {
        try {
            log('isLiveVideo', 'üîç Iniciando detecci√≥n de video live...');

            // Verificar si hay tiempo fijo configurado (indicador de que NO es live)
            const hasFixedTime = window.location.href.includes('&t=') || window.location.href.includes('#t=');
            log('isLiveVideo', `Tiempo fijo en URL: ${hasFixedTime}`);
            if (hasFixedTime) {
                log('isLiveVideo', '‚ùå Video tiene tiempo fijo configurado - NO es live');
                return false;
            }

            // 1. Usar YouTube Helper API
            if (YTHelper?.video) {
                const isCurrentlyLive = YTHelper.video.isCurrentlyLive;
                const isLiveOrVodContent = YTHelper.video.isLiveOrVodContent;
                const wasStreamedOrPremiered = YTHelper.video.wasStreamedOrPremiered;

                log('isLiveVideo', `YouTube Helper API detecci√≥n:`);
                log('isLiveVideo', `   - isCurrentlyLive: ${isCurrentlyLive}`);
                log('isLiveVideo', `   - isLiveOrVodContent: ${isLiveOrVodContent}`);
                log('isLiveVideo', `   - wasStreamedOrPremiered: ${wasStreamedOrPremiered}`);

                // Si est√° actualmente en vivo
                if (isCurrentlyLive /* || isLiveOrVodContent || wasStreamedOrPremiered */) {
                    log('isLiveVideo', '‚úÖ Detectado como LIVE por YouTube Helper API');
                    return true;
                }
            }

            // 2. Fallback: Verificar badge de live en el player
            const liveBadge = document.querySelector('.ytp-live-badge');
            const liveBadgeText = liveBadge?.getAttribute('aria-label') || liveBadge?.textContent || '';
            log('isLiveVideo', `2Ô∏è‚É£ Live badge encontrado: ${!!liveBadge}, tiene aria-label: ${liveBadge?.hasAttribute('aria-label')}`);
            log('isLiveVideo', `2Ô∏è‚É£b Contenido del badge: "${liveBadgeText}"`);

            if (liveBadge && liveBadge.hasAttribute('aria-label')) {
                // Verificar que el contenido del badge realmente indique "live" actual
                // Excluir mensajes de navegaci√≥n como "Sigue adelante hasta alcanzar..."
                const lowerText = liveBadgeText.toLowerCase();
                const isNavigationMessage = lowerText.includes('sigue') ||
                    lowerText.includes('adelante') ||
                    lowerText.includes('alcanzar') ||
                    lowerText.includes('hasta') ||
                    lowerText.includes('go forward') ||
                    lowerText.includes('seek to');

                const badgeIndicatesLive = !isNavigationMessage && (
                    lowerText === 'live' ||
                    lowerText === 'en vivo' ||
                    lowerText === 'directo' ||
                    lowerText.startsWith('live ') ||
                    lowerText.startsWith('en vivo ') ||
                    lowerText.startsWith('directo ')
                );

                log('isLiveVideo', `Badge indica live: ${badgeIndicatesLive} (navegaci√≥n: ${isNavigationMessage})`);

                if (badgeIndicatesLive) {
                    log('isLiveVideo', '‚úÖ Detectado como LIVE por badge del player');
                    return true;
                } else {
                    log('isLiveVideo', '‚ö†Ô∏è Badge encontrado pero no indica live actual - continuando verificaciones...');
                }
            }

            // 3. Fallback: Verificar meta tag espec√≠fico de live broadcast (con validaci√≥n adicional)
            const isLiveBroadcastMeta = document.querySelector('meta[itemprop="isLiveBroadcast"]');
            const isLiveBroadcast = isLiveBroadcastMeta?.content === 'True';
            log('isLiveVideo', `Meta isLiveBroadcast: ${isLiveBroadcastMeta?.content}, es True: ${isLiveBroadcast}`);

            if (isLiveBroadcast) {
                // SIEMPRE validar meta tag con otros indicadores para evitar falsos positivos
                const currentDocTitle = document.title.replace(/ - YouTube$/, '').trim();
                const hasLiveInTitle = currentDocTitle.toLowerCase().includes('live');
                const hasLiveInUrl = window.location.href.includes('/live/');

                log('isLiveVideo', `Validaci√≥n de meta tag isLiveBroadcast:`);
                log('isLiveVideo', `   - T√≠tulo: "${currentDocTitle}"`);
                log('isLiveVideo', `   - T√≠tulo contiene "live": ${hasLiveInTitle}`);
                log('isLiveVideo', `   - URL contiene "/live/": ${hasLiveInUrl}`);

                // Solo confiar en el meta tag si hay otros indicadores de live
                if (hasLiveInTitle || hasLiveInUrl) {
                    log('isLiveVideo', '‚úÖ Detectado como LIVE por meta tag isLiveBroadcast + validaci√≥n');
                    return true;
                } else {
                    log('isLiveVideo', '‚ö†Ô∏è Meta isLiveBroadcast=True pero sin otros indicadores - posible falso positivo, continuando verificaciones...');
                }
            }

            // Verificar indicadores adicionales de live/DVR
            log('isLiveVideo', `Verificando indicadores adicionales de live/DVR`);

            // Verificar si YouTube considera este contenido como live
            const hasLiveDvr = window.location.href.includes('live=dvr') ||
                window.location.href.includes('pltype=contentlive');

            // Tambi√©n verificar en el contexto del player y requests de YouTube
            const hasPlayerLiveContext = document.querySelector('[data-live="true"]') ||
                document.querySelector('.ytp-live:not(.ytp-live-badge)') ||
                document.querySelector('.live-stream-text') ||
                document.querySelector('.ytp-chrome-top .ytp-live') ||
                document.body.innerHTML.includes('live=dvr') ||
                document.body.innerHTML.includes('pltype=contentlive');

            log('isLiveVideo', `YouTube live/DVR indicators:`);
            log('isLiveVideo', `   - URL contiene live=dvr/pltype=contentlive: ${hasLiveDvr}`);
            log('isLiveVideo', `   - Contexto de player live detectado: ${hasPlayerLiveContext}`);

            if (hasLiveDvr || hasPlayerLiveContext) {
                log('isLiveVideo', '‚úÖ Detectado como LIVE por indicadores de YouTube (live=dvr, pltype=contentlive o contexto de player)');
                return true;
            }

            // Verificar duraci√≥n PT0M0S solo si no estamos navegando
            if (!isNavigating) {
                const durationMeta = document.querySelector('meta[itemprop="duration"]')?.content;
                log('isLiveVideo', `Meta duration: "${durationMeta}"`);

                if (durationMeta === 'PT0M0S') {
                    // Verificaci√≥n adicional: buscar otros indicadores de live
                    const liveAriaLabel = document.querySelector('[aria-label*="live"]');
                    const liveTitle = document.querySelector('[title*="live"]');
                    const liveBadgeClass = document.querySelector('.live-badge');
                    const liveUrl = window.location.href.includes('/live/');

                    log('isLiveVideo', `Indicadores adicionales de live:`);
                    log('isLiveVideo', `   - aria-label con "live": ${!!liveAriaLabel}`);
                    log('isLiveVideo', `   - title con "live": ${!!liveTitle}`);
                    log('isLiveVideo', `   - clase .live-badge: ${!!liveBadgeClass}`);
                    log('isLiveVideo', `   - URL contiene /live/: ${liveUrl}`);

                    const hasLiveIndicators = liveAriaLabel || liveTitle || liveBadgeClass || liveUrl;

                    if (hasLiveIndicators) {
                        log('isLiveVideo', '‚úÖ Detectado como LIVE por PT0M0S + indicadores adicionales');
                        return true;
                    } else {
                        log('isLiveVideo', '‚ö†Ô∏è PT0M0S encontrado pero SIN indicadores adicionales de live - probablemente tiempo fijo');
                    }
                }
            } else {
                log('isLiveVideo', '‚è≠Ô∏è Omitiendo verificaci√≥n PT0M0S durante navegaci√≥n');
            }

            log('isLiveVideo', '‚ùå NO detectado como live');
            return false;
        } catch (e) {
            warn('isLiveVideo', 'Error al detectar video live:', e);
            return false;
        }
    }

    // MARK: üì∫ Get Playlist Name
    const playlistNameCache = new Map();
    /**
     * Obtiene el nombre de la playlist desde el DOM o la URL.
     * @param {string} playlistId - ID de la playlist. 
     * @returns {string|null} Nombre de la playlist o null si no se encuentra.
     * 
     * Ejemplo de URL: 
     * https://www.youtube.com/watch?v=VIDEO_ID&list=PLAYLIST_ID 
     */
    async function getPlaylistName(playlistId) {
        if (playlistNameCache.has(playlistId)) {
            return playlistNameCache.get(playlistId);
        }

        const url = new URL(location.href);
        const currentPlaylistId = url.searchParams.get('list');

        if (currentPlaylistId === playlistId) {
            // Intentar m√∫ltiples selectores para el panel de playlist
            const playlistName =
                // Playlist panel en el reproductor
                document.querySelector('ytd-playlist-panel-renderer #title span#text')?.textContent?.trim() ||
                // Header de la p√°gina de playlist
                document.querySelector('#header .ytd-playlist-header-renderer h1 yt-formatted-string')?.textContent?.trim() ||
                document.querySelector('ytd-browse[page-subtype="playlist"] ytd-playlist-header-renderer #title')?.textContent?.trim() ||
                document.querySelector('ytd-playlist-header-renderer h1.title')?.textContent?.trim() ||
                // Alternativas adicionales
                document.querySelector('#container #header-description yt-formatted-string')?.textContent?.trim() ||
                document.querySelector('yt-formatted-string.title:nth-child(1)')?.textContent?.trim() ||
                // Overlay del reproductor (menos confiable)
                document.querySelector('.ytp-title-playlist-button')?.getAttribute('aria-label')?.replace(/^Playlist:\s*/, '')?.trim() ||
                document.querySelector('.byline-title')?.textContent?.trim();

            log('getPlaylistName', 'Playlist name from DOM:', playlistName);
            if (playlistName) {
                playlistNameCache.set(playlistId, playlistName);
                return playlistName;
            }
        }

        return new Promise((resolve) => {
            GM_xmlhttpRequest({
                method: 'GET',
                url: `https://www.youtube.com/playlist?list=${playlistId}`,
                onload: function (response) {
                    try {
                        const htmlText = response.responseText;

                        // Intentar extraer JSON principal
                        const ytInitialDataMatch = htmlText.match(/var ytInitialData = ({.+?});/);
                        let title = null;

                        if (ytInitialDataMatch) {
                            const data = JSON.parse(ytInitialDataMatch[1]);

                            // Intentar extraer t√≠tulo de playlist normal
                            title = data?.metadata?.playlistMetadataRenderer?.title ||
                                data?.sidebar?.playlistSidebarRenderer?.items?.[0]?.playlistSidebarPrimaryInfoRenderer?.title?.runs?.[0]?.text ||
                                data?.header?.playlistHeaderRenderer?.title?.simpleText;

                            // Fallback: intentar rutas t√≠picas de Mixes autom√°ticos
                            if (!title) {
                                title = data?.contents?.twoColumnWatchNextResults?.playlist?.playlist?.title ||
                                    data?.playerOverlays?.playerOverlayRenderer?.autoplay?.autoplay?.title?.simpleText ||
                                    data?.contents?.twoColumnWatchNextResults?.playlist?.title;
                            }
                        }

                        // Si a√∫n no hay t√≠tulo, buscar en meta tags
                        if (!title) {
                            const metaTitleMatch = htmlText.match(/<meta property="og:title" content="([^"]+)">/);
                            if (metaTitleMatch && metaTitleMatch[1]) {
                                title = metaTitleMatch[1];
                            }
                        }

                        // Si no se pudo extraer, usar el ID como fallback
                        if (!title) {
                            warn('getPlaylistName', 'No se pudo extraer el t√≠tulo de la playlist, usando ID');
                            title = playlistId;
                        }

                        playlistNameCache.set(playlistId, title);
                        log('getPlaylistName', `T√≠tulo obtenido: ${title}`);
                        resolve(title);
                    } catch (e) {
                        conError('getPlaylistName', 'Error parsing playlist page:', e);
                        playlistNameCache.set(playlistId, playlistId);
                        resolve(playlistId);
                    }
                },
                onerror: function (error) {
                    conError('getPlaylistName', 'Error fetching playlist page:', error);
                    playlistNameCache.set(playlistId, playlistId);
                    resolve(playlistId);
                }
            });
        });
    }

    // ------------------------------------------
    // MARK: üíæ Video Status Management
    // ------------------------------------------

    // Cache para info de video (evita llamadas repetidas a YouTube API)
    const videoInfoCache = new Map();
    const CACHE_DURATION = 5 * 60 * 1000; // 5 minutos

    /**
     * Limpia el cach√© de informaci√≥n de video para un ID espec√≠fico o todo el cach√©
     * @param {string} [video_id] - ID del video a limpiar (opcional, si no se especifica limpia todo)
     */
    function clearVideoInfoCache(video_id = null) {
        if (video_id) {
            if (videoInfoCache.has(video_id)) {
                videoInfoCache.delete(video_id);
                log('clearVideoInfoCache', `üßπ Cache limpiado para video ${video_id}`);
            }
        } else {
            const size = videoInfoCache.size;
            videoInfoCache.clear();
            log('clearVideoInfoCache', `üßπ Cache completo limpiado (${size} entradas)`);
        }
    }

    /**
     * Obtiene la informaci√≥n del video con cache
     * @param {object} player - Player de YouTube
     * @param {string} video_id - ID del video
     * @returns {Promise<object>} - Informaci√≥n del video
     */
    async function getCachedVideoInfo(player, video_id) {
        const cacheKey = video_id;
        const cached = videoInfoCache.get(cacheKey);

        // Durante navegaci√≥n, ser m√°s estricto con el cach√© para evitar datos obsoletos
        const cacheTimeout = isNavigating ? 30 * 1000 : CACHE_DURATION; // 30 segundos durante navegaci√≥n, 5 minutos normal

        // Verificar si el cach√© es v√°lido
        const isCacheValid = cached && (Date.now() - cached.timestamp) < cacheTimeout;

        // Durante navegaci√≥n, tambi√©n verificar que el t√≠tulo en cach√© coincida con document.title actual
        let isCacheAccurate = true;
        if (isNavigating && cached?.data?.title) {
            const currentDocTitle = document.title.replace(/ - YouTube$/, '').trim();
            if (currentDocTitle) {
                const normalize = (str) => str.toLowerCase().replace(/\s+/g, ' ').trim();
                const normalizedCacheTitle = normalize(cached.data.title);
                const normalizedDocTitle = normalize(currentDocTitle);

                // Si los t√≠tulos no coinciden, el cach√© probablemente tiene datos del video anterior
                isCacheAccurate = normalizedDocTitle === normalizedCacheTitle ||
                    normalizedDocTitle.includes(normalizedCacheTitle) ||
                    normalizedCacheTitle.includes(normalizedDocTitle);

                if (!isCacheAccurate) {
                    log('getCachedVideoInfo', `‚ö†Ô∏è Cache inv√°lido para ${video_id}: t√≠tulo "${cached.data.title}" no coincide con document.title "${currentDocTitle}"`);
                }
            }
        }

        // Retornar cache solo si es v√°lido Y preciso
        if (isCacheValid && isCacheAccurate) {
            log('getCachedVideoInfo', `‚úÖ Usando cache para ${video_id}`);
            return cached.data;
        }

        // Obtener info fresca
        log('getCachedVideoInfo', `üîÑ Obteniendo info fresca para ${video_id}${isNavigating ? ' (navegando)' : ''}${!isCacheAccurate ? ' (cache impreciso)' : ''}`);
        const info = await getVideoInfo(player, video_id);

        // Solo guardar en cache si no estamos navegando O si los datos parecen v√°lidos
        const shouldCache = !isNavigating || (info.title && info.title.length > 3);

        if (shouldCache) {
            videoInfoCache.set(cacheKey, {
                data: info,
                timestamp: Date.now()
            });
            log('getCachedVideoInfo', `üíæ Info cacheada para ${video_id}: "${info.title}"`);
        } else {
            log('getCachedVideoInfo', `‚è≠Ô∏è No cacheando durante navegaci√≥n para ${video_id}`);
        }

        return info;
    }

    /**
     * Guarda el progreso del video actual
     * @param {object} player - Player de YouTube
     * @param {HTMLVideoElement} videoEl - Elemento de video
     * @param {string} type - Tipo de video (watch, embed, shorts)
     * @param {string} plId - ID del playlist (opcional)
     * @returns {Promise<object>} - Resultado del guardado
     */
    const updateStatus = async (player, videoEl, type, plId) => {
        // Obtener el ID desde URL
        const homeVideoCheck = await getActiveVideoElement();
        let url = getYouTubePageType() === 'home' && homeVideoCheck ? lastVideoUrl : location.href;

        let video_id = extractOrNormalizeVideoId(url)?.id;
        log('updateStatus', `URL del reproductor: ${url} | Video ID Extraido: ${video_id}`)

        if (!video_id) {
            conError('updateStatus', 'No se pudo determinar video_id. Abortando guardado.');
            return { success: false, reason: 'no_video_id' };
        }

        const currentTime = videoEl.currentTime;
        const now = Date.now();

        return getCachedVideoInfo(player, video_id).then(async ({ duration, ...videoInfo }) => {
            log('updateStatus', `then duration: ${duration} = ${formatTime(duration)} | current time: ${currentTime} | video_id: ${video_id}`);
            if (!duration || isNaN(currentTime) || currentTime < 1 || !isFinite(duration)) return { success: false, reason: 'invalid_data' };

            // Evitar guardar progreso durante anuncios
            // Verificar si hay anuncios activos usando el estado centralizado
            if (isAdPlaying) {
                log('updateStatus', '‚è∏ Anuncio activo detectado, no guardando progreso');
                return { success: false, reason: 'ad_playing' };
            }
            if (isResuming) {
                log('updateStatus', '‚è∏ isResuming est√° en true, no guardando progreso');
                return { success: false, reason: 'is_resuming' };
            }

            // Buscar progreso previo siempre
            const sourceData = getSavedVideoData(video_id, plId);
            log('updateStatus', `Datos guardados encontrados para ${video_id} y currentTime ${currentTime}:`, sourceData);

            // Verificar si el video est√° completado (staticFinishPercent porcentaje del video)
            const isFinished = duration > 0 && (currentTime / duration) * 100 >= (cachedSettings?.staticFinishPercent || CONFIG.defaultSettings.staticFinishPercent);

            log('updateStatus', 'duration', duration, 'currentTime', currentTime, 'percentWatched', (currentTime / duration) * 100, 'staticFinishPercent', cachedSettings?.staticFinishPercent || CONFIG.defaultSettings.staticFinishPercent, 'isFinished:', isFinished, 'condicion se cumple?', (currentTime / duration) * 100 >= (cachedSettings?.staticFinishPercent || CONFIG.defaultSettings.staticFinishPercent))

            if (sourceData && sourceData.forceResumeTime > 0) {
                if (isFinished) {
                    log('updateStatus', `Video con tiempo fijo ${video_id} completado. Manteniendo tiempo fijo.`);
                    const base = {
                        ...sourceData,
                        isCompleted: true,
                        lastUpdated: now,
                        timestamp: 0,
                    };
                    if (plId) {
                        const playlist = Storage.get(plId);
                        if (playlist?.videos?.[video_id]) {
                            playlist.videos[video_id] = base;
                            Storage.set(plId, playlist);
                        }
                    } else {
                        Storage.set(video_id, base);
                        log('updateStatus', `Datos guardados para ${video_id}:`, base);
                        return { success: true, video_id, timestamp: base.timestamp };
                    }
                }
                // No sobreescribir progreso en videos con tiempo fijo
                return { success: false, reason: 'fixed_time_no_overwrite' };
            }

            // En p√°ginas que no son watch (home, etc.), evitar sobreescribir metadata sensible
            const pageType = getYouTubePageType();
            const safeVideoInfo = { ...videoInfo };
            if (pageType !== 'watch' && sourceData) {
                if (sourceData.title) safeVideoInfo.title = sourceData.title;
                if (sourceData.author) safeVideoInfo.author = sourceData.author;
                if (sourceData.authorId) safeVideoInfo.authorId = sourceData.authorId;
                if (sourceData.thumb) safeVideoInfo.thumb = sourceData.thumb;
            }

            // Guardar progreso en formato FreeTube (video independiente con metadata de playlist)
            const videoData = {
                videoId: video_id,
                timestamp: currentTime,
                lastUpdated: now,
                videoType: type,
                isCompleted: isFinished,
                duration: duration,
                ...safeVideoInfo,
                // Metadatos de playlist (estilo FreeTube)
                lastViewedPlaylistId: plId || null,
                lastViewedPlaylistType: plId ? 'channel' : '', // 'channel', 'user', o vac√≠o
                lastViewedPlaylistItemId: null // YouTube no proporciona itemId, FreeTube lo usa internamente
            };

            // Siempre guardar con video_id como clave
            Storage.set(video_id, videoData);
            log('updateStatus', `Datos guardados para video ${video_id}${plId ? ` (playlist: ${plId})` : ''}:`, videoData);

            // Si hay playlist, obtener su nombre de manera as√≠ncrona y guardarlo en metadata de playlist
            if (plId) {
                // Guardar metadata de la playlist por separado (para referencia)
                const playlistMetaKey = `playlist_meta_${plId}`;
                let playlistMeta = Storage.get(playlistMetaKey) || {
                    playlistId: plId,
                    title: '',
                    lastWatchedVideoId: video_id,
                    lastUpdated: now
                };

                playlistMeta.lastWatchedVideoId = video_id;
                playlistMeta.lastUpdated = now;
                Storage.set(playlistMetaKey, playlistMeta);

                if (!playlistMeta.title) {
                    log('updateStatus', `Playlist ${plId} sin t√≠tulo, buscando...`);
                    getPlaylistName(plId).then(name => {
                        const updated = Storage.get(playlistMetaKey);
                        if (updated && !updated.title) {
                            updated.title = name;
                            Storage.set(playlistMetaKey, updated);
                        }
                    });
                }

                return { success: true, video_id, timestamp: videoData.timestamp, playlistId: plId };
            } else {
                return { success: true, video_id, timestamp: videoData.timestamp };
            }

        }).catch(error => {
            conError('updateStatus', 'Error en getVideoInfo:', error);
            return { success: false, reason: 'get_video_info_error', error };
        });
    };

    const resumePlayback = async (player, vid, videoEl, savedData, type) => {
        log('resumePlayback', 'Llamado con:', { player, vid, videoEl, savedData, type });
        if (!savedData || !vid) {
            log('resumePlayback', '‚ö†Ô∏è No se encontr√≥ informaci√≥n para reanudar o video_id inv√°lido.');
            return;
        }

        log('resumePlayback', `üé¨ Reanudando video, player tiene getDuration: ${typeof player?.getDuration}`);

        const lastTime = savedData.timestamp;
        const forceTime = savedData.forceResumeTime;
        const timeToSeek = forceTime > 0 ? forceTime : lastTime;

        log('resumePlayback', `üé¨ Reanudando video ${vid} en ${timeToSeek}s = ${(timeToSeek / 60).toFixed(2)} minutos`);

        if (!timeToSeek || timeToSeek <= 1) {
            log('resumePlayback', '‚è© No hay tiempo v√°lido para reanudar');
            return;
        }

        const waitForPlayer = () => {
            // Usar el estado centralizado del monitor de anuncios
            if (isAdPlaying) {
                log('resumePlayback', '‚è∏ Anuncio activo detectado, esperando para hacer seek...');
                setTimeout(waitForPlayer, 500);
                return;
            }

            // obtener duracion con fallbacks
            const duration = getVideoDuration(player, videoEl);

            if (duration > 0) {
                // A√±adir delay extra si se est√° navegando r√°pidamente
                const extraDelay = isNavigating ? 300 : 0;

                if (extraDelay > 0) {
                    log('resumePlayback', `‚è≥ Navegaci√≥n r√°pida detectada, esperando ${extraDelay}ms extra...`);
                }

                setTimeout(() => {
                    log('resumePlayback', `‚úÖ Player listo, aplicando seek a ${timeToSeek}s`);
                    applySeek(player, videoEl, timeToSeek, {
                        bypassMinDiff: true,
                        isForced: forceTime > 0,
                        type,
                    });
                }, extraDelay);

                // Actualizar barra de progreso con colores despu√©s del seek
                setTimeout(() => {
                    try {
                        const duration = getVideoDuration(player, videoEl);
                        // Determinar el tipo de video para la barra de progreso
                        const videoType = Boolean(plId) ? 'shorts' : 'watch';
                        updateProgressBarGradient(timeToSeek, duration, videoType);
                    } catch (error) {
                        // Silenciar errores para no afectar el funcionamiento principal
                    }
                }, 100);
            } else {
                setTimeout(waitForPlayer, 150);
            }
        };
        waitForPlayer();
    };

    // ------------------------------------------
    // MARK: üì¢ Time Display
    // ------------------------------------------

    let timeDisplay;
    let clearMessageTimeout = null;
    let shortsTimeDisplay;
    let clearShortsMessageTimeout = null;

    // Inicializa la visualizaci√≥n de tiempo en la barra de reproducci√≥n
    function initTimeDisplay() {
        const timeContainer = document.querySelector('.ytp-time-contents');
        log('initTimeDisplay', 'timeContainer encontrado:', timeContainer);
        if (!timeContainer || timeDisplay) return;
        timeDisplay = createElement('span', {
            className: 'ypp-time-display ypp-d-none',
            onClickEvent: showSavedVideosList,
            atribute: { title: `${t('savedVideos')}` }
        });
        timeContainer.appendChild(timeDisplay);
        log('initTimeDisplay', 'Creada visualizaci√≥n de tiempo en la barra de reproducci√≥n');
    }

    /**
     * Inicializa la visualizaci√≥n de tiempo para videos Shorts
     */
    function initShortsTimeDisplay() {
        // Buscar el contenedor de controles dentro del player de Shorts
        const shortsPlayerControls = document.querySelector('#metapanel');
        log('initShortsTimeDisplay', 'shortsPlayerControls encontrado:', shortsPlayerControls)
        /* document.querySelector('.desktopShortsPlayerControlsHost') */ /* ||
                                     document.querySelector('ytd-shorts #player-container') ||
                                     document.querySelector('.reel-video-in-sequence[is-active] #player-container') ||
                                     document.querySelector('.shorts-container #player-container'); */

        if (!shortsPlayerControls) {
            log('initShortsTimeDisplay', 'Container no encontrado o ya inicializado', shortsPlayerControls);
            return;
        }

        // Crear contenedor espec√≠fico para Shorts
        shortsTimeDisplay = createElement('div', {
            className: 'ypp-shorts-time-display ypp-d-none',
            onClickEvent: showSavedVideosList,
            atribute: {
                title: `${t('savedVideos')}`,
            }
        });

        // A√±adir al contenedor del player de Shorts
        shortsPlayerControls.appendChild(shortsTimeDisplay);
        log('initShortsTimeDisplay', 'Creada visualizaci√≥n de tiempo para Shorts dentro del player');
    }

    // ------------------------------------------
    // MARK: üì¢ Playback Bar Messages
    // ------------------------------------------
    /**
    * Actualiza el mensaje en la barra de reproducci√≥n
    * @param {string} message - Mensaje a mostrar en la barra de reproducci√≥n
    */
    function updatePlaybackBarMessage(message) {
        log('updatePlaybackBarMessage', `Actualizando mensaje: "${message}"`);
        if (!timeDisplay) initTimeDisplay();

        if (!timeDisplay) return;
        setInnerHTML(timeDisplay, message);
        timeDisplay.classList.remove('ypp-d-none');

        // Limpiar timeout anterior si existe
        if (clearMessageTimeout) {
            clearTimeout(clearMessageTimeout);
        }

        // No programar limpieza autom√°tica para mensajes seek si el video est√° pausado
        const isSeekMessage = /* message.includes('‚èØ'); */ !!message.includes('svgPlayOrPauseIcon')
        const activeVideoEl = currentVideoEl || getActiveVideoElement();
        const isVideoPaused = activeVideoEl?.paused || false;
        log('updatePlaybackBarMessage', `üîç Estado: videoPaused=${isVideoPaused}, currentMessage="${message}", isSeekMessage=${isSeekMessage}, currentVideoEl=${!!currentVideoEl}`);

        if (isSeekMessage && isVideoPaused) return;
    }

    function clearPlaybackBarMessage() {
        if (timeDisplay) {
            setInnerHTML(timeDisplay, '');
            timeDisplay.classList.add('ypp-d-none');
        }

        // Limpiar timeout si existe
        if (clearMessageTimeout) {
            clearTimeout(clearMessageTimeout);
            clearMessageTimeout = null;
        }
    }

    // MARK: üì¢ Shorts Messages
    /**
    * Actualiza el mensaje para videos Shorts
    * @param {string} message - Mensaje a mostrar en Shorts
    */
    function updateShortsMessage(message) {
        if (!shortsTimeDisplay || !document.querySelector('#metapanel')?.contains(shortsTimeDisplay)) initShortsTimeDisplay();

        if (!shortsTimeDisplay) {
            warn('updateShortsMessage', 'No se pudo inicializar el display de Shorts');
            return;
        }

        setInnerHTML(shortsTimeDisplay, message);
        shortsTimeDisplay.classList.remove('ypp-d-none');

        // Limpiar timeout anterior si existe
        if (clearShortsMessageTimeout) {
            clearTimeout(clearShortsMessageTimeout);
        }

        // No programar limpieza autom√°tica para mensajes seek si el video est√° pausado
        const isSeekMessage = /* message.includes('‚èØ'); */ !!message.includes('svgPlayOrPauseIcon')
        const activeVideoEl = currentVideoEl || getActiveVideoElement();
        const isVideoPaused = activeVideoEl?.paused || false;
        log('updateShortsMessage', `üîç Estado: videoPaused=${isVideoPaused}, currentMessage="${message}", isSeekMessage=${isSeekMessage}, currentVideoEl=${!!currentVideoEl}`);

        if (isSeekMessage && isVideoPaused) return;
    }

    function clearShortsMessage() {
        if (shortsTimeDisplay) {
            setInnerHTML(shortsTimeDisplay, '');
            shortsTimeDisplay.classList.add('ypp-d-none');
        }

        // Limpiar timeout si existe
        if (clearShortsMessageTimeout) {
            clearTimeout(clearShortsMessageTimeout);
            clearShortsMessageTimeout = null;
        }
    }

    // ------------------------------------------
    // MARK: üçû Toasts
    // ------------------------------------------

    const toastTimeouts = new WeakMap();

    function createToastContainer() {
        let container = document.querySelector('.ypp-toast-container');
        if (!container) {
            container = createElement('div', { className: 'ypp-toast-container' });
            document.body.appendChild(container);
            log('createToastContainer', 'Contenedor de toasts creado');
        }

        return container;
    }

    /**
    * Desvanece y elimina un toast despu√©s de un tiempo.
    * @param {HTMLElement} toast - Elemento toast a eliminar.
    * @param {number} duration - Tiempo en ms antes de iniciar el fade out.
    */
    function fadeAndRemoveToast(toast, duration) {
        // Limpiar timeout previo si existe
        if (toastTimeouts.has(toast)) {
            clearTimeout(toastTimeouts.get(toast));
            toastTimeouts.delete(toast);
        }

        const timeoutId = setTimeout(() => {
            toast.style.opacity = '0';

            const onTransitionEnd = () => {
                toast.remove();
                toast.removeEventListener('transitionend', onTransitionEnd);
            };

            toast.addEventListener('transitionend', onTransitionEnd);
            toastTimeouts.delete(toast);
        }, duration);

        toastTimeouts.set(toast, timeoutId);
    }

    /**
    * Muestra un toast flotante.
    * @param {string} message - Texto del toast.
    * @param {number} [duration=2500] - Duraci√≥n en ms del toast temporal.
    * @param {Object} [options={}] - Opciones:
    *   - persistent: boolean (reutiliza un toast √∫nico)
    *   - keep: boolean (no se auto elimina)
    *   - action: { label: string, callback: function }
    */
    function showFloatingToast(message, duration = 2500, options = {}) {
        const container = createToastContainer();
        let toast;

        if (options.persistent) {
            toast = container.querySelector('.ypp-toast.persistent');
            if (!toast) {
                toast = createElement('div', { className: 'ypp-toast persistent' });
                container.appendChild(toast);
            }
            // Resetear contenido y estilo
            setInnerHTML(toast, '');
            toast.style.opacity = '1';
        } else {
            toast = createElement('div', { className: 'ypp-toast' });
            if (options.action) toast.classList.add('has-action');
            container.appendChild(toast);
            // Inicializar opacity 0 antes de animar
            toast.style.opacity = '0';
            requestAnimationFrame(() => (toast.style.opacity = '1'));
        }

        // Contenido
        const messageSpan = createElement('span', { html: message });
        toast.appendChild(messageSpan);

        // Agregar bot√≥n de cerrar para toasts persistentes
        if (options.persistent) {
            const closeBtn = createElement('button', {
                className: 'ypp-toast-close',
                html: SVG_ICONS.close,
                atribute: { 'aria-label': t('close'), title: t('close'), type: 'button' },
                onClickEvent: () => {
                    fadeAndRemoveToast(toast, 0);
                }
            });
            toast.appendChild(closeBtn);
        }

        if (options.action) {
            const actionBtn = createElement('button', {
                className: 'ypp-toast-action',
                text: options.action.label,
                onClickEvent: () => {
                    if (typeof options.action.callback === 'function') {
                        options.action.callback();
                    }
                    fadeAndRemoveToast(toast, 0);
                },
                atribute: { 'aria-label': options.action.label, type: 'button' }
            });
            toast.appendChild(actionBtn);
        }

        if (!options.keep && !options.persistent) fadeAndRemoveToast(toast, duration);

        log('showFloatingToast', 'Toast mostrado', { message, options });
    }

    // ------------------------------------------
    // MARK: üõ† showSettingsUI
    // ------------------------------------------

    function showSettingsUI() {
        // Ocultar modal de videos si existe, pero no eliminarlo
        let wasVideosModalOpen = false;
        if (videosOverlay && videosContainer) {
            videosOverlay.style.display = 'none';
            videosContainer.style.display = 'none';
            wasVideosModalOpen = true;
        }

        // Cerrar otros modales que no sean el de videos
        const existingModals = document.querySelectorAll('.ypp-modalOverlay');
        existingModals.forEach(modal => {
            if (modal !== videosOverlay) {
                modal.remove();
            }
        });

        const closeModal = () => {
            overlay.remove();
            document.body.style.overflow = '';

            // Restaurar modal de videos si estaba abierto
            if (wasVideosModalOpen && videosOverlay && videosContainer) {
                videosOverlay.style.display = '';
                videosContainer.style.display = '';
            }
        };

        // Crear overlay con tema din√°mico
        const overlay = createElement('div', {
            className: 'ypp-modalOverlay',
            atribute: { 'aria-modal': 'true', role: 'dialog' },
            onClickEvent: (e) => {
                if (e.target === overlay) closeModal();
            }
        });

        // Aplicar tema din√°mico
        applyThemeStyles(overlay);

        // Crear modal
        const modal = createElement('div', { className: 'ypp-modalBox' });
        const header = createElement('div', { className: 'ypp-modalHeader' });
        const titleEl = createElement('h3', { className: 'ypp-modalTitle', text: `‚öôÔ∏è ${t('settings')}` });
        const closeBtn = createElement('button', {
            className: 'ypp-btn ypp-btn-small ypp-btn-close',
            html: SVG_ICONS.close,
            atribute: { 'aria-label': t('close'), title: t('close'), type: 'button' },
            onClickEvent: closeModal
        });
        header.appendChild(titleEl);
        header.appendChild(closeBtn);

        // Crear body con scroll
        const body = createElement('div', { className: 'ypp-modalBody' });
        const content = createElement('div', { className: 'ypp-settingsContent' });

        // Contenido de configuraci√≥n existente...
        const toggleNotif = createElement('input', { atribute: { type: 'checkbox', id: 'showNotifications' } });
        const toggleButtons = createElement('input', { atribute: { type: 'checkbox', id: 'showFloatingButtons' } });
        const toggleProgressBarGradient = createElement('input', { atribute: { type: 'checkbox', id: 'enableProgressBarGradient' } });
        const intervalInput = createElement('input', { className: 'ypp-input-small', atribute: { type: 'number', id: 'minSeconds', min: 1, max: 9999 } });
        const staticFinishPercentInput = createElement('input', { className: 'ypp-input-small', atribute: { type: 'number', id: 'staticFinishPercent', min: 1, max: 99 } });
        const languageSelect = createElement('select', { className: 'ypp-select', id: 'languageSelect' });
        const alertStyleSelect = createElement('select', { className: 'ypp-select', id: 'alertStyleSelect' });

        // A√±adir opciones de idioma
        const sortedLanguages = Object.entries(LANGUAGE_FLAGS).sort((a, b) => a[1].name.localeCompare(b[1].name));
        sortedLanguages.forEach(([code, lang]) => {
            const option = createElement('option', { atribute: { value: code }, text: `${lang.emoji || 'üåê'} ${lang.name}` });
            languageSelect.appendChild(option);
        });

        // A√±adir estilos de alerta
        const alertStyles = [
            { value: 'iconText', text: 'üîî Icon + Text' },
            { value: 'iconOnly', text: 'üîî Icon Only' },
            { value: 'textOnly', text: 'üìù Text Only' },
            { value: 'hidden', text: 'üö´ Hidden' }
        ];
        alertStyles.forEach(style => {
            const option = createElement('option', { atribute: { value: style.value }, text: style.text });
            alertStyleSelect.appendChild(option);
        });

        // Crear checkboxes
        const languageLabel = createElement('label', { className: 'ypp-label ypp-label-language' });
        languageLabel.appendChild(createElement('span', { text: `${t('language')}: ` }));
        languageLabel.appendChild(languageSelect);

        const buttonsLabel = createElement('label', { className: 'ypp-label' });
        buttonsLabel.appendChild(toggleButtons);
        buttonsLabel.appendChild(createElement('span', { text: t('showFloatingButton') }));

        const gradientLabel = createElement('label', { className: 'ypp-label' });
        gradientLabel.appendChild(toggleProgressBarGradient);
        gradientLabel.appendChild(createElement('span', { text: t('enableProgressBarGradient') }));

        const notifLabel = createElement('label', { className: 'ypp-label' });
        notifLabel.appendChild(toggleNotif);
        notifLabel.appendChild(createElement('span', { text: t('showNotifications') }));

        const intervalLabel = createElement('label', { className: 'ypp-label' });
        intervalLabel.appendChild(createElement('span', { text: `${t('minSecondsBetweenSaves')}: ` }));
        intervalLabel.appendChild(intervalInput);

        const staticFinishPercentLabel = createElement('label', { className: 'ypp-label' });
        staticFinishPercentLabel.appendChild(createElement('span', { text: `${t('staticFinishPercent')}: ` }));
        staticFinishPercentLabel.appendChild(staticFinishPercentInput);
        staticFinishPercentLabel.appendChild(createElement('span', { className: 'ypp-percent-symbol', text: `%` }));


        const alertStyleLabel = createElement('label', { className: 'ypp-label' });
        alertStyleLabel.appendChild(createElement('span', { text: `${t('alertStyle')}: ` }));
        alertStyleLabel.appendChild(alertStyleSelect);

        // Checkboxes para tipo de videos
        const savingOptions = createElement('div', { className: 'ypp-saving-options' });

        const containerSavingOptions = createElement('div', { className: 'ypp-container-saving-options' });
        const savingOptionsTitle = createElement('h2', { text: `${t('enableSavingFor')}:` });
        const saveRegularVideosLabel = createElement('label', { className: 'ypp-label-save-type' });
        const saveRegularVideosCheckbox = createElement('input', { atribute: { type: 'checkbox', id: 'saveRegularVideos' } });
        saveRegularVideosLabel.appendChild(saveRegularVideosCheckbox);
        saveRegularVideosLabel.appendChild(createElement('span', { text: t('regularVideos') }));

        const saveShortsLabel = createElement('label', { className: 'ypp-label-save-type' });
        const saveShortsCheckbox = createElement('input', { atribute: { type: 'checkbox', id: 'saveShorts' } });
        saveShortsLabel.appendChild(saveShortsCheckbox);
        saveShortsLabel.appendChild(createElement('span', { text: t('shorts') }));

        const saveLiveStreamsLabel = createElement('label', { className: 'ypp-label-save-type' });
        const saveLiveStreamsCheckbox = createElement('input', { atribute: { type: 'checkbox', id: 'saveLiveStreams' } });
        saveLiveStreamsLabel.appendChild(saveLiveStreamsCheckbox);
        saveLiveStreamsLabel.appendChild(createElement('span', { text: t('liveStreams') }));

        // A√±adir todo al contenido
        const buttonsGroup = createElement('div');
        buttonsGroup.appendChild(languageLabel); // 
        buttonsGroup.appendChild(buttonsLabel);
        buttonsGroup.appendChild(gradientLabel);
        buttonsGroup.appendChild(intervalLabel);
        buttonsGroup.appendChild(staticFinishPercentLabel);


        containerSavingOptions.appendChild(savingOptionsTitle)
        containerSavingOptions.appendChild(saveRegularVideosLabel);
        containerSavingOptions.appendChild(saveShortsLabel);
        containerSavingOptions.appendChild(saveLiveStreamsLabel);
        savingOptions.appendChild(containerSavingOptions)

        savingOptions.appendChild(notifLabel);
        savingOptions.appendChild(intervalLabel);
        savingOptions.appendChild(alertStyleLabel);
        buttonsGroup.appendChild(savingOptions);

        content.appendChild(buttonsGroup);
        body.appendChild(content);

        // Crear footer fijo
        const footer = createElement('div', { className: 'ypp-btnGroup' });
        const saveBtn = createElement('button', {
            className: 'ypp-btn ypp-save-button sombra',
            id: 'saveBtn',
            text: t('save'),
            onClickEvent: async () => {
                const newSettings = {
                    showNotifications: toggleNotif.checked,
                    minSecondsBetweenSaves: Math.max(1, parseInt(intervalInput.value, 10)),
                    showFloatingButtons: toggleButtons.checked,
                    enableProgressBarGradient: toggleProgressBarGradient.checked,
                    staticFinishPercent: Math.max(1, Math.min(99, parseInt(staticFinishPercentInput.value, 10))),
                    saveRegularVideos: document.getElementById('saveRegularVideos').checked,
                    saveShorts: document.getElementById('saveShorts').checked,
                    saveLiveStreams: document.getElementById('saveLiveStreams').checked,
                    language: languageSelect.value,
                    alertStyle: alertStyleSelect.value,
                };
                await Settings.set(newSettings);
                // Actualizar cache inmediatamente para evitar problemas de timing
                cachedSettings = newSettings;
                await setLanguage(languageSelect.value);
                showFloatingToast(`‚úÖ ${t('configurationSaved')}`);
                location.reload();
            }
        });
        const viewBtn = createElement('button', {
            className: 'ypp-btn ypp-btn-outlined sombra',
            id: 'viewSavedBtn',
            text: `${t('savedVideos')}`,
            onClickEvent: () => {
                overlay.remove();
                showSavedVideosList();
            }
        });
        footer.appendChild(viewBtn);
        footer.appendChild(saveBtn);

        // Ensamblar modal
        modal.appendChild(header);
        modal.appendChild(body);
        modal.appendChild(footer);
        overlay.appendChild(modal);

        // Cargar configuraci√≥n actual
        Settings.get().then(settings => {
            toggleNotif.checked = settings.showNotifications;
            toggleButtons.checked = settings.showFloatingButtons;
            toggleProgressBarGradient.checked = settings.enableProgressBarGradient;
            intervalInput.value = settings.minSecondsBetweenSaves;
            staticFinishPercentInput.value = settings.staticFinishPercent;
            languageSelect.value = settings.language;
            alertStyleSelect.value = settings.alertStyle;
            saveRegularVideosCheckbox.checked = settings.saveRegularVideos;
            saveShortsCheckbox.checked = settings.saveShorts;
            saveLiveStreamsCheckbox.checked = settings.saveLiveStreams;
        });

        // A√±adir al DOM
        document.body.appendChild(overlay);
        document.body.style.overflow = 'hidden';
    }

    // ------------------------------------------
    // MARK: üì¢ Notify Seek or Progress
    // ------------------------------------------

    let cachedSettings = null;

    /**
    * Notifica al usuario sobre el progreso guardado o la posici√≥n de seek (reanudaci√≥n)
    * @param {number} time - Tiempo en segundos
    * @param {string} context - 'seek' o 'progress'
    * @param {object} options - Opciones adicionales
    *      @param {boolean} options.isForced - Indica si el seek fue forzado
    *      @param {object} options.saveResult - Resultado del guardado (solo para context='progress')
    */
    async function notifySeekOrProgress(time, context = 'progress', options = {}) {
        log('notifySeekOrProgress', 'Llamado con:', { time, context, options });

        // Para progreso, verificar que realmente se guard√≥
        if (context === 'progress') {
            if (!options.saveResult || !options.saveResult.success) {
                log('notifySeekOrProgress', 'No se notifica progreso: guardado fallido o no confirmado', options.saveResult);
                return;
            }
            log('notifySeekOrProgress', '‚úÖ Progreso guardado confirmado, procediendo con notificaci√≥n');
        }

        if (!cachedSettings) {
            Settings.get().then((settings) => {
                cachedSettings = settings;
            })
                .catch((error) => {
                    conError('notifySeekOrProgress', 'Error al cargar configuraci√≥n para notificaciones (usaran defaults):', error);
                    cachedSettings = CONFIG.defaultSettings;
                });
            log('notifySeekOrProgress', 'Cargando configuraci√≥n para notificaciones...');
            return;
        }

        if (cachedSettings.showNotifications === false || cachedSettings.alertStyle === 'hidden') {
            log('notifySeekOrProgress', 'Notificaciones deshabilitadas o estilo oculto, no se muestra mensaje');
            return;
        }

        // Bloquear notificaci√≥n de progreso si hay tiempo fijo o si hay un mensaje seek activo y video est√° pausado
        if (context === 'progress') {
            const videoId = YTHelper?.video.id || extractOrNormalizeVideoId(location.href)?.id;
            log('notifySeekOrProgress', 'Video ID:', videoId, 'YTHelper?.video.id:', YTHelper?.video.id, 'extractOrNormalizeVideoId(location.href)?.id:', extractOrNormalizeVideoId(location.href)?.id)

            // Usar el playlistId del saveResult si est√° disponible
            const playlistId = options.saveResult?.playlistId ||
                new URLSearchParams(location.search).get('list') ||
                null;
            log('notifySeekOrProgress', 'Playlist ID desde saveResult:', options.saveResult?.playlistId, 'Playlist ID desde URL:', new URLSearchParams(location.search).get('list'));

            // Peque√±o retraso para permitir que el mensaje seek se establezca
            await new Promise(resolve => setTimeout(resolve, 100));

            // Verificar si hay un mensaje seek activo y el video est√° pausado
            // Usar el video element actual que est√° siendo procesado para mayor precisi√≥n
            const activeVideoEl = currentVideoEl || getActiveVideoElement();
            const isVideoPaused = activeVideoEl?.paused || false;
            const currentMessage = timeDisplay?.innerHTML || '';
            const hasSeekMessage = /* currentMessage.includes('‚èØ'); */ !!currentMessage.includes('svgPlayOrPauseIcon')

            log('notifySeekOrProgress', `üîç Estado: videoPaused=${isVideoPaused}, currentMessage="${currentMessage}", hasSeekMessage=${hasSeekMessage}, currentVideoEl=${!!currentVideoEl}`);

            if (hasSeekMessage && isVideoPaused) {
                log('notifySeekOrProgress', '‚è∏ Video pausado con mensaje seek activo, omitiendo notificaci√≥n de progreso');
                return;
            }

            if (videoId) {
                const videoData = getSavedVideoData(videoId, playlistId);
                if (videoData?.forceResumeTime > 0) {
                    log('notifySeekOrProgress', 'Video con tiempo fijo, omitiendo notificaci√≥n de progreso.');
                    return;
                }
            }
        }

        const { isForced = false/* , videoType = 'normal' */ } = options;
        const timeStr = formatTime(normalizeSeconds((time)));

        let icon = '';
        let text = '';

        // Preparar los textos seg√∫n el contexto
        if (context === 'seek') {
            icon = isForced ? `${SVG_ICONS.timer}${SVG_ICONS.pin}` : SVG_ICONS.playOrPause;
            text = `${t(isForced ? 'alwaysStartFrom' : 'resumedAt')}: ${timeStr}`;
        } else {
            icon = SVG_ICONS.save;
            text = `${t('progressSaved')}: ${timeStr}`;
        }

        // Aplicar estilo seg√∫n alertStyle
        let message = '';
        switch (cachedSettings.alertStyle) {
            case 'iconOnly':
                message = `${icon} ${timeStr}`;
                break;
            case 'textOnly':
                message = text;
                break;
            case 'iconText':
            default:
                message = `${icon} ${text}`;
                break;
        }

        // Mostrar en toast o en barra de reproducci√≥n
        log('notifySeekOrProgress', 'Mostrando notificaci√≥n en tipo de p√°gina:', currentPageType);
        log('notifySeekOrProgress', `Mensaje generado: "${message}" | Contexto: ${context}`);

        if (currentPageType === 'shorts') {
            updateShortsMessage(message);
        } else if (currentPageType === 'watch' || currentPageType === 'embed') {
            updatePlaybackBarMessage(message);
        } else {
            warn('notifySeekOrProgress', 'Tipo de p√°gina no soportado:', currentPageType);
        }
    }


    // ------------------------------------------
    // MARK: üéµ Selecci√≥n de Videos
    // ------------------------------------------

    let selectedVideos = new Set(); // IDs de videos seleccionados
    let isSelectionMode = false; // Modo de selecci√≥n activo

    /**
     * Activa/desactiva el modo de selecci√≥n de videos
     */
    function toggleSelectionMode() {
        isSelectionMode = !isSelectionMode;
        selectedVideos.clear();

        // Actualizar la interfaz
        updateVideoList();
        updateSelectionUI();

        log('toggleSelectionMode', `Modo de selecci√≥n: ${isSelectionMode ? 'ACTIVADO' : 'DESACTIVADO'}`);
    }

    /**
     * Actualiza la interfaz seg√∫n el modo de selecci√≥n
     */
    function updateSelectionUI() {
        // Buscar el bot√≥n por su contenido o clase espec√≠fica
        const createPlaylistBtn = Array.from(document.querySelectorAll('.ypp-btn')).find(btn =>
            btn.innerHTML.includes(t('createPlaylist')) || btn.innerHTML.includes(t('selectVideos'))
        );

        if (createPlaylistBtn) {
            if (isSelectionMode) {
                setInnerHTML(createPlaylistBtn, `${SVG_ICONS.close} ${t('selectVideos')} (${selectedVideos.size})`);
                createPlaylistBtn.className = 'ypp-btn ypp-btn-danger sombra';
            } else {
                setInnerHTML(createPlaylistBtn, `${SVG_ICONS.playlist} ${t('createPlaylist')}`);
                createPlaylistBtn.className = 'ypp-btn ypp-btn-primary sombra';
            }
        }

        // Mostrar/ocultar √°rea de playlist y botones del footer
        updatePlaylistArea();
    }

    /**
     * Actualiza el √°rea de playlist integrada
     */
    function updatePlaylistArea() {
        const playlistArea = document.getElementById('ypp-playlist-area');
        const firstRow = document.querySelector('.ypp-footer-row:first-child');
        const secondRow = document.querySelector('.ypp-footer-row:last-child');

        if (!playlistArea) return;

        if (isSelectionMode) {
            // Mostrar √°rea de playlist y ocultar botones normales
            playlistArea.classList.add('active');
            if (playlistArea) {
                playlistArea.classList.add('active');
            }
            if (firstRow) {
                firstRow.classList.add('hidden');
            }
            if (secondRow) {
                secondRow.classList.add('hidden');
            }

            // Actualizar informaci√≥n si hay videos seleccionados
            if (selectedVideos.size > 0) {
                updatePlaylistContent();
            }
        } else {
            // Ocultar √°rea de playlist y mostrar botones normales
            playlistArea.classList.remove('active');
            if (playlistArea) {
                playlistArea.classList.remove('active');
            }
            if (firstRow) {
                firstRow.classList.remove('hidden');
            }
            if (secondRow) {
                secondRow.classList.remove('hidden');
            }

            // Limpiar contenido del √°rea de playlist
            clearPlaylistContent();
        }
    }

    /**
     * Actualiza el contenido del √°rea de playlist
     */
    function updatePlaylistContent() {
        const playlistInfo = document.getElementById('ypp-playlist-info');
        const playlistTextarea = document.getElementById('ypp-playlist-textarea');

        if (playlistInfo) {
            playlistInfo.textContent = `${t('selectedVideos')}: ${selectedVideos.size}`;
        }

        if (playlistTextarea) {
            if (selectedVideos.size > 0) {
                const videoIds = Array.from(selectedVideos);
                const playlistUrl = `https://www.youtube.com/watch_videos?video_ids=${videoIds.join(',')}`;
                playlistTextarea.value = playlistUrl;
            } else {
                playlistTextarea.value = '';
            }
        }
    }

    /**
     * Limpia el contenido del √°rea de playlist
     */
    function clearPlaylistContent() {
        const playlistInfo = document.getElementById('ypp-playlist-info');
        const playlistTextarea = document.getElementById('ypp-playlist-textarea');

        if (playlistInfo) {
            playlistInfo.textContent = `${t('selectedVideos')}: 0`;
        }

        if (playlistTextarea) {
            playlistTextarea.value = '';
        }
    }

    /**
     * Copia el enlace de playlist al portapapeles
     */
    function copyPlaylistLink() {
        const textarea = document.getElementById('ypp-playlist-textarea');
        if (!textarea || !textarea.value) {
            alert(t('selectAtLeastOne'));
            return;
        }

        copyToClipboard(textarea.value, document.getElementById('ypp-copy-playlist-btn'));
    }

    /**
     * Abre el enlace de playlist en una nueva pesta√±a
     */
    function openPlaylistLink() {
        const textarea = document.getElementById('ypp-playlist-textarea');
        if (!textarea || !textarea.value) {
            alert(t('selectAtLeastOne'));
            return;
        }

        window.open(textarea.value, '_blank');
    }

    /**
     * Copia texto al portapapeles
     */
    async function copyToClipboard(text, button) {
        try {
            await navigator.clipboard.writeText(text);
            const originalText = button.innerHTML;
            setInnerHTML(button, `${SVG_ICONS.check} ${t('linkCopied')}`);
            button.className = 'ypp-btn ypp-btn-success';

            setTimeout(() => {
                setInnerHTML(button, originalText);
                button.className = 'ypp-btn ypp-btn-primary';
            }, 2000);

            log('copyToClipboard', 'Enlace copiado al portapapeles');
        } catch (err) {
            console.error('Error al copiar al portapapeles:', err);
            // Fallback para navegadores que no soportan clipboard API
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);

            setInnerHTML(button, `${SVG_ICONS.check} ${t('linkCopied')}`);
            button.className = 'ypp-btn ypp-btn-success';

            setTimeout(() => {
                setInnerHTML(button, `${SVG_ICONS.copy} ${t('copyLink')}`);
                button.className = 'ypp-btn ypp-btn-primary';
            }, 2000);
        }
    }

    /**
     * Alterna la selecci√≥n de un video
     */
    function toggleVideoSelection(videoId) {
        if (selectedVideos.has(videoId)) {
            selectedVideos.delete(videoId);
            log('toggleVideoSelection', `Video ${videoId} deseleccionado`);
        } else {
            selectedVideos.add(videoId);
            log('toggleVideoSelection', `Video ${videoId} seleccionado`);
        }

        // Actualizar UI
        updateSelectionUI();

        // Actualizar el checkbox espec√≠fico
        const checkbox = document.querySelector(`input[data-video-id="${videoId}"]`);
        if (checkbox) {
            checkbox.checked = selectedVideos.has(videoId);
        }

        // Actualizar contenido de playlist
        updatePlaylistContent();
    }

    // ------------------------------------------
    // MARK: üì∫ Modal Videos
    // ------------------------------------------
    let currentVideoEl = null;
    let lastPlaylistId = null;
    let lastUrl = ''; // Rastrear la √∫ltima URL procesada
    let lastVideoUrl = ''; // URL del √∫ltimo video (para miniplayer en home)
    let lastSaveTime = 0; // Para controlar la frecuencia de guardado
    let lastResumeId = null;
    let currentlyProcessingVideoId = null;
    let currentTimeUpdateHandler = null; // Referencia al manejador actual para limpieza correcta

    const processVideo = async (playerToProcess, videoEl) => {
        log('processVideo', `Llegando a processVideo con player: ${typeof playerToProcess} | ¬øpermite getDuration?: ${typeof playerToProcess?.getDuration === 'function'}`);
        log('processVideo', `Llegando a processVideo con videoEl: ${videoEl?.constructor?.name} | src: ${videoEl?.src || 'N/A'}`);
        log('processVideo', `isNavigating: ${isNavigating}`);
        log('processVideo', `isResuming: ${isResuming} | Video paused: ${videoEl?.paused}`);
        log('processVideo', `üîç Estado inicial: isAdPlaying=${isAdPlaying}, cachedSettings=${!!cachedSettings}`);

        // Asegurar que cachedSettings est√© cargado
        if (!cachedSettings) {
            try {
                cachedSettings = await Settings.get();
            } catch (error) {
                conError('processVideo', 'Error al cargar configuraci√≥n, usando defaults:', error);
                cachedSettings = CONFIG.defaultSettings;
            }
        }
        log('processVideo', `‚úÖ cachedSettings cargado:`, cachedSettings);

        // Resetear isResuming si est√° stuck por mucho tiempo
        if (isResuming) {
            log('processVideo', '‚ö†Ô∏è isResuming estaba en true, reseteando por seguridad');
            isResuming = false;
        }

        const activeVideoCheck = await getActiveVideoElement();
        if (isNavigating && !activeVideoCheck) {
            log('processVideo', `isNavigating: ${isNavigating}`);
            log('processVideo', `getActiveVideoElement(): ${activeVideoCheck}`);
            log('processVideo', 'Navegaci√≥n en curso y no se encontr√≥ elemento de video, omitiendo procesamiento de video.');
            return;
        }

        let player = playerToProcess;

        // Asegurar que los elementos existen
        if (!player || !videoEl) {
            // Intentar obtenerlos autom√°ticamente si no se proporcionaron
            videoEl = await getActiveVideoElement();

            // Priorizar YouTube Helper API
            if (YTHelper?.apiProxy && typeof YTHelper.apiProxy.getDuration === 'function') {
                player = YTHelper.apiProxy;
                log('processVideo', '‚úÖ Usando YTHelper.apiProxy como player fallback');
            } else {
                // Fallback a m√©todos antiguos
                player = window.ytplayer || window.yt || {};
                warn('processVideo', '‚ö†Ô∏è YouTube Helper API no disponible, usando fallback antiguo');
            }

            log('processVideo', `Player fallback tiene getDuration: ${typeof player?.getDuration} | videoEl: ${!!videoEl}`);

            if (!videoEl) {
                warn('processVideo', 'No se encontr√≥ videoEl. Abortando.');
                return;
            }
        }

        // Determinar la URL correcta para extraer video ID
        let urlForVideoId = window.location.href;
        const pageType = getYouTubePageType();

        // Si estamos en home y hay un miniplayer activo, usar la √∫ltima URL de video guardada
        if (pageType === 'home' && lastVideoUrl && activeVideoCheck) {
            urlForVideoId = lastVideoUrl;
            log('processVideo', `üìç Usando lastVideoUrl para miniplayer: ${lastVideoUrl}`);
        }

        let videoData = extractOrNormalizeVideoId(urlForVideoId);
        let videoIdDetected = videoData?.id;

        // Validaci√≥n temprana: si no hay video ID, salir antes de procesar
        if (!videoIdDetected) {
            log('processVideo', `üö® No se pudo determinar el video_id desde ${urlForVideoId}. Abortando procesamiento temprano.`);
            return;
        }

        // Guardar la URL del video actual para uso en miniplayer
        if (videoIdDetected && pageType !== 'home') {
            lastVideoUrl = window.location.href;
            log('processVideo', `URL del video guardada para miniplayer: ${lastVideoUrl}`);
        }

        let plId = videoData?.list;

        log('processVideo', `URL del reproductor: ${window.location.href} | Video ID del reproductor: ${videoIdDetected}`);

        // Evitar reprocesar el mismo video
        if (currentlyProcessingVideoId === videoIdDetected) {
            log('processVideo', `El video ${videoIdDetected} ya est√° siendo procesado. Ignorando.`);
            return;
        }
        currentlyProcessingVideoId = videoIdDetected;

        try {
            // Detecci√≥n del tipo de video
            let type = getYouTubePageType()
            const isLive = isLiveVideo();
            log('processVideo', `üìã Tipo de p√°gina inicial: ${type}, isLive: ${isLive}`);

            // Si el tipo es 'watch' o 'embed' y el video est√° en vivo, cambia el tipo a 'live'.
            if ((type === 'watch' || type === 'embed') && isLive) {
                type = 'live';
                log('processVideo', `üîÑ Tipo cambiado a 'live' porque se detect√≥ video en vivo`);
            }
            log('processVideo', `üéá Tipo de video/p√°gina detectado: ${type}`);

            // Verificar si el tipo de video actual est√° deshabilitado en la configuraci√≥n
            const typeToSetting = {
                watch: 'saveRegularVideos',
                shorts: 'saveShorts',
                live: 'saveLiveStreams'
            };

            // Si el tipo de video actual est√° deshabilitado en la configuraci√≥n, sale de la funci√≥n
            if (!cachedSettings[typeToSetting[type]] && !(getYouTubePageType() === 'home' && activeVideoCheck)) {
                // Loguea un mensaje indicando que este tipo de video no se debe procesar
                log('processVideo', `üõë Tipo "${type}" no est√° habilitado para guardado, omitiendo.`);
                log('processVideo', `Es home con un video activo? ${!(getYouTubePageType() === 'home' && activeVideoCheck)}`);

                // Sale de la funci√≥n, evitando que el video se procese
                return;
            }

            // Buscar progreso previo
            let savedData = getSavedVideoData(videoIdDetected, plId);
            log('processVideo', `Datos guardados:`, savedData);
            log('processVideo', `Verificando reanudaci√≥n: savedData=${!!savedData}, videoId=${videoIdDetected}, lastResumeId=${lastResumeId}, iguales=${videoIdDetected === lastResumeId}`);

            // Verifica si hay datos guardados para el video y si el video detectado es diferente al √∫ltimo ID de video que se intent√≥ reanudar.
            if (savedData && videoIdDetected !== lastResumeId) {
                // Define si se debe reanudar la reproducci√≥n del video
                const shouldResume =
                    // La reanudaci√≥n est√° forzada si 'forceResumeTime' es mayor que cero,
                    // lo que indica un tiempo espec√≠fico programado para retomar el video.
                    savedData.forceResumeTime > 0 ||

                    // Alternativamente, se decide reanudar si el tiempo de visualizaci√≥n
                    // es mayor a minSeekDiff (1.5 segundos) y el video no se ha completado. 
                    // Esto evita reanudar videos que apenas se comenzaron y a√∫n no han capturado el inter√©s del usuario.
                    (savedData.timestamp > CONFIG.minSeekDiff && !savedData.isCompleted);

                log('processVideo', `shouldResume=${shouldResume} (forceResumeTime=${savedData.forceResumeTime}, timestamp=${savedData.timestamp}, isCompleted=${savedData.isCompleted})`);

                // resumePlayback con 200 ms de espera para "shorts"
                const debouncedResumePlayback = debounce(resumePlayback, 200);


                if (shouldResume) {
                    isResuming = true;
                    log('processVideo', `‚úÖ Reanudando ${videoIdDetected} (${type})...`);

                    if (type === 'short') {
                        // Espera 200 ms sin m√°s llamadas antes de reanudar
                        debouncedResumePlayback(
                            player,
                            videoIdDetected,
                            videoEl,
                            savedData,
                            Boolean(plId),
                            plId,
                            lastPlaylistId,
                            type
                        );
                    } else {
                        // Reanuda de inmediato para otros tipos
                        resumePlayback(
                            player,
                            videoIdDetected,
                            videoEl,
                            savedData,
                            Boolean(plId),
                            plId,
                            lastPlaylistId,
                            type
                        );
                    }

                    lastResumeId = videoIdDetected;
                }

                else {
                    isResuming = false;
                    log('processVideo', '‚è© No se cumple condici√≥n de reanudaci√≥n, reproducci√≥n normal');
                }
            } else {
                log('processVideo', '‚è© No hay datos guardados o video ya fue reanudado, reproducci√≥n normal');
            }

            // Handler para guardar progreso
            const handler = () => {
                try {
                    if (isNavigating) return;

                    // Verificar si hay anuncios activos usando el estado centralizado
                    if (isAdPlaying) {
                        log('handler', '‚è∏ Anuncio activo detectado, no procesando timeupdate');
                        return;
                    }

                    // Validar que a√∫n exista un video v√°lido
                    if (!videoIdDetected) {
                        conError('handler', 'No se encontr√≥ videoIdDetected al intentar guardar progreso.');
                        return;
                    }

                    // Diagnosticar si el video est√° pausado injustificadamente
                    if (videoEl && videoEl.paused && !isAdPlaying && !isResuming) {
                        log('handler', '‚ö†Ô∏è Video est√° pausado. No por anuncios ni reanudaci√≥n.');
                        // No intentar forzar reproducci√≥n - los navegadores modernos lo bloquean
                    }

                    const currentVid = videoIdDetected;
                    // Evitar convertir player a string porque puede contener Symbols (es un Proxy)
                    log('handler de processVideo', `Player tiene getDuration: ${typeof player?.getDuration}, isProxy: ${!!YTHelper?.apiProxy}`);

                    // Verificar si cambi√≥ de video durante la ejecuci√≥n
                    if (currentVid !== videoIdDetected) {
                        warn('handler', 'El ID del video cambi√≥ durante la ejecuci√≥n. Abortando guardado.');
                        return;
                    }

                    // Limpiar mensaje seek si el video comienza a reproducirse
                    const currentMessage = timeDisplay?.innerHTML || '';
                    log('handler', `currentMessage: ${currentMessage}`)
                    const hasSeekMessage = /* currentMessage.includes('‚èØ'); */ !!currentMessage.includes('svgPlayOrPauseIcon');
                    if (hasSeekMessage && !videoEl.paused) {
                        log('handler', 'üé¨ Video comenz√≥ a reproducirse, limpiando mensaje seek');
                        clearPlaybackBarMessage();
                        clearShortsMessage();
                    }

                    // L√≥gica de guardado de progreso
                    const now = Date.now();
                    const minInterval = (cachedSettings?.minSecondsBetweenSaves || CONFIG.defaultSettings.minSecondsBetweenSaves) * 1000;

                    if (now - lastSaveTime >= minInterval) {
                        log('processVideo', `üíæ Guardando progreso con updateStatus para ${videoIdDetected} (${type})...`);

                        // Llamar a updateStatus y esperar el resultado
                        updateStatus(player, videoEl, type, plId).then(saveResult => {
                            if (saveResult?.success) {
                                log('processVideo', `‚úÖ Progreso guardado exitosamente para ${videoIdDetected}`);

                                // Notificar solo si realmente se guard√≥
                                const currentTime = player.getCurrentTime ? player.getCurrentTime() : (videoEl?.currentTime || 0);
                                notifySeekOrProgress(currentTime, 'progress', { saveResult });
                            } else {
                                log('processVideo', `‚ö†Ô∏è No se guard√≥ progreso para ${videoIdDetected}:`, saveResult?.reason);
                            }

                            // Actualizar barra de progreso con colores (independientemente del guardado)
                            try {
                                const currentTime = player.getCurrentTime ? player.getCurrentTime() : (videoEl?.currentTime || 0);
                                const duration = getVideoDuration(player, videoEl);
                                updateProgressBarGradient(currentTime, duration, type);
                            } catch (error) {
                                // Silenciar errores para no afectar el funcionamiento principal
                            }
                        }).catch(error => {
                            conError('processVideo', 'Error al guardar progreso:', error);
                        });

                        lastSaveTime = now;
                    }
                } catch (err) {
                    conError('handler', 'Error en el handler de timeupdate:', err);
                }
            };

            // Antes de agregar el nuevo handler, elimina el anterior si exist√≠a
            if (currentVideoEl && currentTimeUpdateHandler) {
                try {
                    currentVideoEl.removeEventListener('timeupdate', currentTimeUpdateHandler);
                    log('processVideo', 'üßπ Handler anterior removido correctamente.');
                } catch (err) {
                    warn('processVideo', `No se pudo remover el handler anterior: ${err.message}`);
                }
            }
            // Adjuntar el nuevo handler
            currentTimeUpdateHandler = handler;
            currentVideoEl = videoEl;
            videoEl.addEventListener('timeupdate', handler);

            lastPlaylistId = plId;
        } catch (error) {
            conError('processVideo', `Error al procesar el video ${videoIdDetected}:`, error);
        } finally {
            setTimeout(() => (currentlyProcessingVideoId = null), 100);
        }
    };

    // ------------------------------------------
    // MARK: ‚èØ Seek
    // ------------------------------------------

    const applySeek = async (player, videoEl, time, options = {}) => {
        const { bypassMinDiff = false, isForced = false, type = 'normal' } = options;
        // Si es un tiempo forzado (manual), autom√°ticamente bypass minSeekDiff
        const effectiveBypassMinDiff = bypassMinDiff || isForced;
        const TIMEOUT_MS = 5000; // Timeout m√°ximo para el seek
        const NEAR_THRESHOLD = 0.5; // Consideramos seek completado si estamos a menos de 0.5s

        if (!player && !videoEl) {
            warn('applySeek', 'No se proporcion√≥ player ni videoEl. Abortando.');
            return;
        }

        // Normalizar tiempo
        if (typeof time !== 'number') {
            if (typeof time === 'string') time = parseTimeToSeconds(time.trim());
            else {
                warn('applySeek', 'Tiempo inv√°lido:', time);
                return;
            }
        }

        log('applySeek', `Seek hacia ${time}s | Forzado: ${isForced} | BypassMinDiff: ${effectiveBypassMinDiff} | Tipo: ${type}`);

        // Verificar si el seek es necesario
        try {
            const current = videoEl?.currentTime ?? player?.getCurrentTime?.() ?? 0;
            const diff = Math.abs(current - time);

            if (!effectiveBypassMinDiff && diff <= CONFIG.minSeekDiff) {
                log('applySeek', `Diferencia m√≠nima (${diff}s). Omitiendo seek.`);
                return;
            }
        } catch (e) {
            warn('applySeek', 'Error al obtener tiempo actual:', e);
        }

        // Validar estado del player antes del seek
        const isPlayerReady = () => {
            try {
                if (player?.seekTo) {
                    // Verificar que el player tenga m√©todos esenciales y duraci√≥n v√°lida
                    const duration = player.getDuration?.();
                    const currentTime = player.getCurrentTime?.();
                    return duration > 0 && typeof currentTime === 'number';
                }
                return videoEl && !isNaN(videoEl.duration) && videoEl.duration > 0;
            } catch (e) {
                return false;
            }
        };

        // Esperar a que el player est√© listo si no lo est√°
        if (!isPlayerReady()) {
            log('applySeek', 'Player no est√° listo, esperando...');
            await new Promise(resolve => {
                let attempts = 0;
                const maxAttempts = 10;
                const checkReady = () => {
                    attempts++;
                    if (isPlayerReady() || attempts >= maxAttempts) {
                        log('applySeek', `Player listo despu√©s de ${attempts} intentos`);
                        resolve();
                    } else {
                        setTimeout(checkReady, 200);
                    }
                };
                checkReady();
            });
        }

        // Ejecutar el seek con retry logic
        let seekSuccess = false;
        let retryCount = 0;
        const maxRetries = 3;

        while (!seekSuccess && retryCount < maxRetries) {
            try {
                if (player?.seekTo && isPlayerReady()) {
                    log('applySeek', `Usando player.seekTo(${time}, true) - Intento ${retryCount + 1}`);
                    player.seekTo(time, true);
                    seekSuccess = true;
                } else if (videoEl && !isNaN(videoEl.duration)) {
                    log('applySeek', `Asignando videoEl.currentTime = ${time} - Intento ${retryCount + 1}`);
                    videoEl.currentTime = time;
                    seekSuccess = true;
                } else {
                    throw new Error('Player o videoEl no disponible');
                }
            } catch (e) {
                retryCount++;
                if (retryCount < maxRetries) {
                    warn('applySeek', `Error en intento ${retryCount}, reintentando en 300ms:`, e);
                    await new Promise(resolve => setTimeout(resolve, 300));
                } else {
                    conError('applySeek', 'Error al ejecutar seek despu√©s de todos los reintentos:', e);
                    return;
                }
            }
        }

        // Esperar confirmaci√≥n del seek con respaldo m√∫ltiple y timeout
        await new Promise(resolve => {
            let seekCompleted = false;

            const completeSeek = () => {
                if (!seekCompleted) {
                    seekCompleted = true;
                    log('applySeek', 'Seek completado.');
                    cleanup();
                    resolve();
                }
            };

            const cleanup = () => {
                clearInterval(checkInterval);
                clearTimeout(timeoutId);
                videoEl?.removeEventListener('seeked', onSeeked);
                videoEl?.removeEventListener('timeupdate', onTimeUpdate);
            };

            const onSeeked = () => {
                log('applySeek', 'Evento "seeked" detectado.');
                completeSeek();
            };

            const onTimeUpdate = () => {
                try {
                    const currentTime = videoEl?.currentTime ?? player?.getCurrentTime?.();
                    if (Math.abs(currentTime - time) <= NEAR_THRESHOLD) {
                        log('applySeek', `Seek detectado por timeupdate. Diferencia: ${Math.abs(currentTime - time)}s`);
                        completeSeek();
                    }
                } catch (e) {
                    // ignorar errores de lectura
                }
            };

            // Intervalo de verificaci√≥n como respaldo
            const checkInterval = setInterval(() => {
                try {
                    const currentTime = videoEl?.currentTime ?? player?.getCurrentTime?.();
                    if (Math.abs(currentTime - time) <= NEAR_THRESHOLD) {
                        log('applySeek', `Seek detectado por intervalo. Diferencia: ${Math.abs(currentTime - time)}s`);
                        completeSeek();
                    }
                } catch (e) {
                    // ignorar
                }
            }, 200);

            // Timeout final con l√≥gica mejorada
            const timeoutId = setTimeout(() => {
                warn('applySeek', `Timeout de ${TIMEOUT_MS}ms alcanzado. Verificando estado final...`);
                try {
                    const currentTime = videoEl?.currentTime ?? player?.getCurrentTime?.() ?? 0;
                    const diff = Math.abs(currentTime - time);

                    // Ser m√°s tolerante durante navegaci√≥n r√°pida
                    const tolerance = isNavigating ? 2.0 : 1.0;

                    if (diff <= tolerance) {
                        log('applySeek', `Seek completado con tolerancia. Diferencia final: ${diff}s`);
                    } else {
                        warn('applySeek', `Seek incompleto. Diferencia final: ${diff}s`);

                        // √öltimo intento de seek directo si el player est√° disponible
                        if (player?.seekTo && isPlayerReady()) {
                            log('applySeek', '√öltimo intento de seek en timeout...');
                            try {
                                player.seekTo(time, true);
                            } catch (e) {
                                warn('applySeek', 'Fall√≥ √∫ltimo intento de seek:', e);
                            }
                        }
                    }
                } catch (e) {
                    warn('applySeek', 'Error al verificar estado final:', e);
                }
                completeSeek();
            }, TIMEOUT_MS);

            // Listeners de eventos
            videoEl?.addEventListener('seeked', onSeeked, { once: true });
            videoEl?.addEventListener('timeupdate', onTimeUpdate);
        });

        // Notificaci√≥n final
        notifySeekOrProgress(time, 'seek', { isForced });

        // Resetear flag de reanudaci√≥n para permitir notificaciones de progreso
        isResuming = false;

        log('applySeek', 'applySeek finalizado. isResuming reseteado a false.');
    };

    // ------------------------------------------
    // MARK: üìÇ Sort UI
    // ------------------------------------------

    function createSortSelector(currentValue, onChange) {
        const wrapper = document.createElement('div');
        const label = createElement('label', { className: 'ypp-label', text: `${t('sortBy')} :`, atribute: { for: 'sort-selector' } });
        const select = createElement('select', {
            className: 'ypp-sort-select', id: 'sort-selector', html: `
        <option value="recent" ${currentValue === 'recent' ? 'selected' : ''}>üìÖ ${t('mostRecent')}</option>
        <option value="oldest" ${currentValue === 'oldest' ? 'selected' : ''}>üìÜ ${t('oldest')}</option>
        <option value="title" ${currentValue === 'title' ? 'selected' : ''}>üî§ ${t('titleAZ')}</option>`
        });
        select.onchange = () => onChange(select.value);
        label.appendChild(select);
        wrapper.appendChild(label);
        return wrapper;
    }

    // ------------------------------------------
    // MARK: üìÇ Filters UI
    // ------------------------------------------

    // nota futuro yo: <option> no soporta SVG
    function createFilterSelector(currentValue, onChange) {
        const wrapper = createElement('div', { className: 'ypp-d-flex' });
        const label = createElement('label', { className: 'ypp-label', text: `${t('filterByType')} :`, atribute: { for: 'filter-selector' } });
        const select = createElement('select', {
            className: 'ypp-filter-select', id: 'filter-selector', html: `
        <option value="all" ${currentValue === 'all' ? 'selected' : ''}>üîé ${t('all')}</option>
        <option value="watch" ${currentValue === 'watch' ? 'selected' : ''}>‚ñ∂Ô∏è ${t('videos')}</option>
        <option value="shorts" ${currentValue === 'shorts' ? 'selected' : ''}>üì± ${t('shorts')}</option>
        <option value="live" ${currentValue === 'live' ? 'selected' : ''}>üî¥ ${t('liveStreams')}</option>
        <option value="playlist" ${currentValue === 'playlist' ? 'selected' : ''}>üìÅ ${t('playlist')}</option>
        <option value="completed" ${currentValue === 'completed' ? 'selected' : ''}>‚úÖ ${t('completedVideos')}</option>
        <option value="fixedTime" ${currentValue === 'fixedTime' ? 'selected' : ''}>‚è±Ô∏èüìå ${t('videosWithFixedTime')}</option>`
        });
        select.addEventListener('change', () => onChange(select.value));
        wrapper.appendChild(label);
        wrapper.appendChild(select);
        return wrapper;
    }

    function createSearchInput(currentValue, onChange) {
        const wrapper = createElement('div', { className: 'ypp-d-flex' });
        const input = createElement('input', {
            className: 'ypp-search-input',
            id: 'search-input',
            atribute: {
                'aria-label': t('searchByTitleOrAuthor'),
                title: t('searchByTitleOrAuthor'),
                placeholder: `üîç ${t('searchByTitleOrAuthor')}`,
                type: 'text'
            }
        });
        input.value = currentValue;
        
        // Aplicar debounce para no procesar cada tecla inmediatamente
        const debouncedOnChange = debounce((value) => onChange(value), 300);
        input.addEventListener('input', () => debouncedOnChange(input.value.trim()));
        
        wrapper.appendChild(input);
        return wrapper;
    }

    async function saveFilters(newValues) {
        const currentRaw = await GM_getValue(CONFIG.userFiltersKey, '{}');
        const current = JSON.parse(currentRaw);
        const updated = { ...current, ...newValues };
        await GM_setValue(CONFIG.userFiltersKey, JSON.stringify(updated));
    }

    async function getSavedFilters() {
        const raw = await GM_getValue(CONFIG.userFiltersKey, '{}');
        try {
            const saved = raw ? JSON.parse(raw) : {};
            const merged = { ...CONFIG.defaultFilters, ...saved };
            return merged;
        } catch (e) {
            conError('getSavedFilters', 'Error parsing filtros guardados:', e);
            return { ...CONFIG.defaultFilters };
        }
    }

    // ------------------------------------------
    // MARK: üìÇ Video List UI
    // ------------------------------------------

    let videosOverlay = null;
    let videosContainer = null;
    let listContainer = null;
    let currentOrderBy, currentFilterBy, currentSearchQuery;

    function updateVideoList() {
        const keys = Storage.keys().filter(k => !k.startsWith('userSettings') && !k.startsWith('playlist_meta_'));
        setInnerHTML(listContainer, ''); // Limpiar contenido previo

        // Cargar metadata de playlists para referencia
        const playlistMetas = {};
        Storage.keys().filter(k => k.startsWith('playlist_meta_')).forEach(metaKey => {
            const meta = Storage.get(metaKey);
            if (meta?.playlistId) {
                playlistMetas[meta.playlistId] = meta;
            }
        });

        let allItems = [];
        keys.forEach(key => {
            const data = Storage.get(key);
            log('updateVideoList', `Data for ${key}:`, JSON.stringify(data))

            if (!data) return;

            // Compatibilidad con formato antiguo (playlists anidadas)
            if (data.videos) {
                const playlistTitle = data.title || key;
                const lastWatchedVideoId = data.lastWatchedVideoId || null;
                log('updateVideoList', `üîç Formato antiguo detectado: playlist ${key} con ${Object.keys(data.videos).length} videos`);
                Object.entries(data.videos).forEach(([videoId, info]) => {
                    allItems.push({
                        type: 'playlist-video',
                        videoId,
                        info,
                        playlistKey: key,
                        playlistTitle,
                        lastWatchedVideoId
                    });
                });
                return;
            }

            // Formato FreeTube: todos los videos son entradas independientes
            const videoId = data.videoId || key;
            const playlistId = data.lastViewedPlaylistId;
            const playlistTitle = playlistId && playlistMetas[playlistId]
                ? playlistMetas[playlistId].title || playlistId
                : null;

            allItems.push({
                type: playlistId ? 'playlist-video' : 'regular-video',
                videoId,
                info: data,
                playlistKey: playlistId,
                playlistTitle,
                lastWatchedVideoId: playlistMetas[playlistId]?.lastWatchedVideoId || null // Usar metadata de playlist
            });
        });

        // No deduplicar: mismo video en diferentes contextos (playlist vs individual) son entradas v√°lidas separadas
        // Esto es consistente con FreeTube que mantiene entradas por contexto de visualizaci√≥n

        let filteredItems = allItems.filter(item => {
            if (currentFilterBy === 'completed') return item.info.isCompleted === true;
            if (currentFilterBy === 'fixedTime') return item.info.forceResumeTime && item.info.forceResumeTime > 0;
            if (currentFilterBy === 'playlist') return item.type === 'playlist-video';
            if (currentFilterBy === 'all') return true;
            return item.info.videoType === currentFilterBy;
        }).filter(item => {
            if (!currentSearchQuery) return true;
            const query = currentSearchQuery.toLowerCase();
            return (item.info.title || '').toLowerCase().includes(query) ||
                (item.info.author || '').toLowerCase().includes(query) ||
                (item.playlistTitle || '').toLowerCase().includes(query);
        });

        const getSortValue = (item) => {
            if (currentOrderBy === 'title') return (item.info.title || item.videoId).toLowerCase();
            if (currentOrderBy === 'oldest') return item.info.savedAt || 0;
            return -(item.info.savedAt || 0);
        };
        filteredItems.sort((a, b) => {
            const valA = getSortValue(a);
            const valB = getSortValue(b);
            if (typeof valA === 'string') return valA.localeCompare(valB);
            return valA - valB;
        });

        let lastRenderedPlaylistKey = null;
        filteredItems.forEach(item => {
            if (item.type === 'playlist-video') {
                if (item.playlistKey !== lastRenderedPlaylistKey) {
                    // Si hay un √∫ltimo video visto, enlazar a ese video + playlist (para mixes de YT)
                    // Si no, enlazar a la playlist completa
                    const playlistUrl = item.lastWatchedVideoId
                        ? `https://www.youtube.com/watch?v=${item.lastWatchedVideoId}&list=${item.playlistKey}`
                        : `https://www.youtube.com/playlist?list=${item.playlistKey}`;

                    const h3 = createElement('a', {
                        className: 'ypp-playlistTitle',
                        html: `${SVG_ICONS.folder} ${t('playlistPrefix')}: ${item.playlistTitle}`,
                        atribute: {
                            href: playlistUrl,
                            target: '_blank',
                            rel: 'noopener noreferrer'
                        }
                    });
                    listContainer.appendChild(h3);
                    lastRenderedPlaylistKey = item.playlistKey;
                }
                listContainer.appendChild(createVideoEntry(item.videoId, item.info, item.playlistKey, item.playlistTitle));
            } else {
                listContainer.appendChild(createVideoEntry(item.videoId, item.info, null));
            }
        });

        if (filteredItems.length === 0) {
            const p = createElement('p', { className: 'ypp-emptyMsg', text: t('noSavedVideos') });
            listContainer.appendChild(p);
        }
    }

    function closeModalVideos() {
        if (videosOverlay) {
            videosOverlay.remove();
            videosOverlay = null;
        }
        if (videosContainer) {
            videosContainer.remove();
            videosContainer = null;
        }
        if (listContainer) {
            listContainer.remove();
            listContainer = null;
        }
        document.body.style.overflow = '';
    }

    // ------------------------------------------
    // MARK: üîò Floating Button
    // ------------------------------------------

    const createFloatingButton = async () => {
        const settings = await Settings.get();

        if (!settings.showFloatingButtons) return;

        const wrapper = createElement('div', { className: 'ypp-floatingBtnContainer' });
        const btnConfig = createElement('div', {
            className: 'ypp-btn ypp-btn-secondary sombra',
            html: `${SVG_ICONS.settings} ${t('youtubePlaybackPlox')}`,
            onClickEvent: showSettingsUI
        });
        wrapper.appendChild(btnConfig);
        document.body.appendChild(wrapper);

        const updateVisibility = () => {
            const isFullscreen = !!document.fullscreenElement;
            wrapper.style.display = isFullscreen ? 'none' : 'flex';
        };
        document.addEventListener('fullscreenchange', updateVisibility);
        window.addEventListener('yt-navigate-finish', updateVisibility);
        updateVisibility();
    };

    // ------------------------------------------
    // MARK: üìÇ Show Saved Videos List
    // ------------------------------------------

    async function showSavedVideosList() {
        // Siempre cerrar el modal existente para asegurar un estado limpio
        closeModalVideos();

        // Cargar filtros guardados para asegurar sincronizaci√≥n
        const saved = await getSavedFilters();

        // Usar los filtros pasados como par√°metro o los guardados
        currentOrderBy = saved.orderBy ?? CONFIG.defaultFilters.orderBy;
        currentFilterBy = saved.filterBy ?? CONFIG.defaultFilters.filterBy;
        currentSearchQuery = saved.searchQuery ?? CONFIG.defaultFilters.searchQuery;

        // Crear elementos del modal
        videosOverlay = createElement('div', { className: 'ypp-modalOverlay' });
        videosContainer = createElement('div', { className: 'ypp-videosContainer' });

        // Aplicar tema din√°mico
        applyThemeStyles(videosOverlay);
        applyThemeStyles(videosContainer);

        listContainer = createElement('div', { id: 'video-list-container' });

        const header = createElement('div', { className: 'ypp-header' });
        const title = createElement('h2', { text: t('youtubePlaybackPlox') });
        const closeBtn = createElement('button', {
            className: 'ypp-btn ypp-btn-small ypp-btn-close',
            html: SVG_ICONS.close,
            atribute: { 'aria-label': t('close') },
            onClickEvent: closeModalVideos
        });

        header.appendChild(title);
        header.appendChild(closeBtn);
        videosContainer.appendChild(header);

        const filtersContainer = createElement('div', { className: 'ypp-filters' });
        filtersContainer.appendChild(createSortSelector(currentOrderBy, async (selected) => {
            currentOrderBy = selected;
            await saveFilters({ orderBy: selected });
            updateVideoList();
        }));
        filtersContainer.appendChild(createFilterSelector(currentFilterBy, async (selected) => {
            currentFilterBy = selected;
            await saveFilters({ filterBy: selected });
            updateVideoList();
        }));
        filtersContainer.appendChild(createSearchInput(currentSearchQuery, async (query) => {
            currentSearchQuery = query;
            await saveFilters({ searchQuery: query });
            updateVideoList();
        }));
        videosContainer.appendChild(filtersContainer);

        videosContainer.appendChild(listContainer);

        const footer = createElement('div', { className: 'ypp-footer' });

        // Primera fila: Botones de exportaci√≥n/importaci√≥n
        const firstRow = createElement('div', { className: 'ypp-footer-row' });

        const btnExport = createElement('button', {
            className: 'ypp-btn ypp-btn-secondary sombra',
            html: `${SVG_ICONS.upload} ${t('export')} (JSON)`,
            onClickEvent: exportDataToFile
        });
        const btnImport = createElement('button', {
            className: 'ypp-btn ypp-btn-secondary sombra',
            html: `${SVG_ICONS.download} ${t('import')} (JSON)`,
            onClickEvent: importDataFromFile
        });
        const btnExportFreeTube = createElement('button', {
            className: 'ypp-btn ypp-btn-secondary sombra',
            html: `${SVG_ICONS.upload} ${t('export')} (FreeTube)`,
            onClickEvent: exportToFreeTube
        });
        const btnImportFreeTube = createElement('button', {
            className: 'ypp-btn ypp-btn-secondary sombra',
            html: `${SVG_ICONS.download} ${t('import')} (FreeTube)`,
            onClickEvent: importFromFreeTube
        });

        const btnCreatePlaylist = createElement('button', {
            className: 'ypp-btn ypp-btn-primary sombra',
            html: `${SVG_ICONS.playlist} ${t('createPlaylist')}`,
            onClickEvent: toggleSelectionMode
        });

        firstRow.appendChild(btnExport);
        firstRow.appendChild(btnImport);
        firstRow.appendChild(btnExportFreeTube);
        firstRow.appendChild(btnImportFreeTube);
        firstRow.appendChild(btnCreatePlaylist);

        // Segunda fila: Eliminar todo (izquierda) y Configuraciones (derecha)
        const secondRow = createElement('div', { className: 'ypp-footer-row ypp-footer-row-bottom' });

        const btnClearAll = createElement('button', {
            className: 'ypp-btn ypp-btn-danger sombra',
            html: `${SVG_ICONS.trash} ${t('clearAll')}`,
            onClickEvent: clearAllData
        });

        const btnSettings = createElement('button', {
            className: 'ypp-btn ypp-btn-secondary sombra',
            html: `${SVG_ICONS.settings} ${t('settings')}`,
            onClickEvent: showSettingsUI
        });

        secondRow.appendChild(btnClearAll);
        secondRow.appendChild(btnSettings);

        // √Årea de creaci√≥n de playlist integrada
        const playlistArea = createElement('div', {
            className: 'ypp-playlist-creation-area',
            id: 'ypp-playlist-area'
        });

        const playlistTitle = createElement('h4', {
            html: `${SVG_ICONS.playlist} ${t('playlistLinkGenerated')}`,
            styles: { marginBottom: '10px' }
        });

        const playlistInfo = createElement('p', {
            id: 'ypp-playlist-info',
            text: `${t('selectedVideos')}: 0`,
            styles: { marginBottom: '10px', fontWeight: 'bold' }
        });

        const playlistTextarea = createElement('textarea', {
            className: 'ypp-playlist-textarea',
            id: 'ypp-playlist-textarea',
            atribute: {
                readonly: true,
                rows: 2,
                placeholder: t('playlistLinkGenerated')
            }
        });

        const playlistActions = createElement('div', {
            className: 'ypp-playlist-actions'
        });

        const copyBtn = createElement('button', {
            className: 'ypp-btn ypp-btn-primary',
            html: `${SVG_ICONS.copy} ${t('copyLink')}`,
            id: 'ypp-copy-playlist-btn',
            onClickEvent: copyPlaylistLink
        });

        const openBtn = createElement('button', {
            className: 'ypp-btn ypp-btn-secondary',
            html: `${SVG_ICONS.externalLink} ${t('openPlaylist')}`,
            id: 'ypp-open-playlist-btn',
            onClickEvent: openPlaylistLink
        });

        const cancelBtn = createElement('button', {
            className: 'ypp-btn ypp-btn-danger',
            html: `${SVG_ICONS.close} ${t('cancel')}`,
            onClickEvent: () => toggleSelectionMode()
        });

        playlistActions.appendChild(copyBtn);
        playlistActions.appendChild(openBtn);
        playlistActions.appendChild(cancelBtn);

        playlistArea.appendChild(playlistTitle);
        playlistArea.appendChild(playlistInfo);
        playlistArea.appendChild(playlistTextarea);
        playlistArea.appendChild(playlistActions);

        footer.appendChild(firstRow);
        footer.appendChild(secondRow);
        footer.appendChild(playlistArea);
        videosContainer.appendChild(footer);

        videosOverlay.addEventListener('click', (e) => {
            if (e.target === videosOverlay) closeModalVideos();
        });
        document.body.appendChild(videosOverlay);
        document.body.appendChild(videosContainer);

        // Actualizar la lista de videos con los filtros actuales
        updateVideoList();
    }

    // ------------------------------------------
    // MARK: üìÇ Video Entry
    // ------------------------------------------

    /**
     * Genera un color √∫nico basado en el hash de una cadena
     * @param {string} str - Cadena para generar el color
     * @returns {string} Color en formato HSL
     */
    function generatePlaylistColor(str) {
        if (!str) return 'var(--color-bg-secondary)';

        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }

        // Generar un tono entre 0-360, con saturaci√≥n y luminosidad fijas para consistencia
        const hue = Math.abs(hash) % 360;
        return `hsl(${hue}, 45%, 95%)`; // Colores suaves para el fondo
    }

    /**
     * Genera un color de borde m√°s intenso para la playlist
     * @param {string} str - Cadena para generar el color
     * @returns {string} Color en formato HSL
     */
    function generatePlaylistBorderColor(str) {
        if (!str) return 'var(--color-border)';

        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }

        const hue = Math.abs(hash) % 360;
        return `hsl(${hue}, 60%, 70%)`; // Color m√°s intenso para el borde
    }

    function createVideoEntry(videoId, info, playlistKey = null, playlistTitle = null) {
        log('createVideoEntry', `üîç Info completo para ${videoId}:`, JSON.stringify(info));
        log('createVideoEntry', `üîç Playlist info: playlistKey=${playlistKey}, playlistTitle=${playlistTitle}`);
        const isCompleted =
            info.isCompleted ||
            // Verificar si el video est√° completado (m√°s de 95% reproducido)
            (info.timestamp && info.duration && normalizeSeconds(info.timestamp) >= normalizeSeconds(info.duration) - 1) ||
            false;
        const videoTime = formatTime(normalizeSeconds(info.timestamp));
        const rawDuration = info.duration;
        let duration = normalizeSeconds(info.duration);

        // Si duracion es 0, el video fue guardado sin duraci√≥n (antiguo)
        // Los videos nuevos siempre guardan duraci√≥n gracias a los fallbacks mejorados
        if (duration === 0 && rawDuration === 0) {
            log('createVideoEntry', `‚ö†Ô∏è Video ${videoId} sin duraci√≥n guardada (formato antiguo)`);
        }

        log('createVideoEntry', `üîç Depuraci√≥n duration: rawDuration=${rawDuration} (type: ${typeof rawDuration}), duration=${duration} (type: ${typeof duration})`);
        const watched = normalizeSeconds(info.timestamp);
        const remaining = Math.max(duration - watched, 0);
        const percent = duration ? Math.min(100, Math.round((watched / duration) * 100)) : null;
        log('createVideoEntry', `üîç Depuraci√≥n porcentaje: videoId=${videoId}, duration=${duration}, watched=${watched}, percent=${percent}, isCompleted=${isCompleted}`);
        // Aplicar estilos √∫nicos por playlist
        const isPlaylistItem = !!playlistKey;
        let finalPlaylistTitle = isPlaylistItem ? (playlistTitle || info.playlistTitle || playlistKey) : null;

        // Manejo especial para playlists mix (RDxxxx)
        if (isPlaylistItem && finalPlaylistTitle === playlistKey && playlistKey?.startsWith('RD')) {
            finalPlaylistTitle = `Mix - ${info.title || 'Playlist autom√°tica'}`;
        }

        // Limpiar undefined del t√≠tulo de playlist
        if (finalPlaylistTitle && finalPlaylistTitle.includes('undefined')) {
            finalPlaylistTitle = finalPlaylistTitle.replace(/undefined/g, '').trim();
        }

        log('createVideoEntry', `üîç Final playlist title: "${finalPlaylistTitle}" para ${videoId}`);

        const wrapper = createElement('div', {
            className: `ypp-videoWrapper ${isPlaylistItem ? 'playlist-item' : 'regular-item'}${isSelectionMode ? ' selection-mode' : ''}`
        });

        // Agregar checkbox si est√° en modo de selecci√≥n
        if (isSelectionMode) {
            const checkbox = createElement('input', {
                atribute: {
                    type: 'checkbox',
                    'data-video-id': videoId
                },
                className: 'ypp-video-checkbox',
                props: {
                    checked: selectedVideos.has(videoId)
                },
                onClickEvent: (e) => {
                    e.stopPropagation();
                    toggleVideoSelection(videoId);
                }
            });
            wrapper.appendChild(checkbox);
        }

        // Aplicar colores √∫nicos por playlist
        if (isPlaylistItem) {
            const bgColor = generatePlaylistColor(playlistKey);
            const borderColor = generatePlaylistBorderColor(playlistKey);
            wrapper.style.backgroundColor = bgColor;
            wrapper.style.borderLeft = `4px solid ${borderColor}`;
            wrapper.style.position = 'relative';
        }
        loadYouTubeThumbnail(videoId).then((thumbnailUrl) => {
            const thumb = createElement('img', {
                className: 'ypp-thumb',
                atribute: {
                    title: info.title || videoId,
                    loading: 'lazy',
                    alt: info.title || 'Miniatura',
                    src: thumbnailUrl
                },
                props: { draggable: false }
            })
            wrapper.prepend(thumb);
        });

        const infoDiv = createElement('div', { className: 'ypp-infoDiv' });
        const titleLink = createElement('a', {
            className: 'ypp-titleLink', text: info.title || videoId,
            atribute: {
                title: info.title || videoId,
                href: `https://www.youtube.com/watch?v=${videoId}${playlistKey ? '&list=' + playlistKey : ''}`
            },
            props: { target: '_blank', rel: 'noopener noreferrer' }
        });

        // Autor: hacer clickeable si hay authorId disponible
        const authorText = info.author || t('unknown');
        const author = info.authorId
            ? createElement('a', {
                className: 'ypp-author ypp-author-link',
                text: authorText,
                atribute: {
                    title: `${t('openChannel')}: ${authorText}`,
                    href: `https://www.youtube.com/channel/${info.authorId}`
                },
                props: { target: '_blank', rel: 'noopener noreferrer' }
            })
            : createElement('div', { className: 'ypp-author', text: authorText });

        const views = createElement('div', { className: 'ypp-views', text: `${info.viewsNumber} ${t('views')}` || `${info.views} ${t('views')}` || t('notAvailable') });

        // Determinar texto y clase del timestamp
        const hasFixedTime = info.forceResumeTime > 0;
        const fixedTimeStr = hasFixedTime
            ? `${SVG_ICONS.timer} ${t('alwaysStartFrom')}: ${formatTime(normalizeSeconds(info.forceResumeTime))} ${SVG_ICONS.locked}`
            : null;

        let timestampText;
        let timestampClass;

        if (isCompleted) {
            timestampClass = 'completed';
            timestampText = hasFixedTime
                ? `${fixedTimeStr} ${SVG_ICONS.check}`
                : `${SVG_ICONS.check} ${t('completed')}`;
        } else if (hasFixedTime) {
            timestampClass = 'forced';
            timestampText = fixedTimeStr;
        } else {
            timestampClass = 'progress';
            timestampText = `${t('progress')} ${videoTime}`;
        }

        const timestamp = createElement('div', {
            className: `ypp-timestamp ${timestampClass}`,
            html: timestampText
        });

        infoDiv.appendChild(titleLink);

        // Agregar indicador de playlist si es parte de una
        if (isPlaylistItem && finalPlaylistTitle) {
            const playlistIndicator = createElement('div', {
                className: 'ypp-playlist-indicator',
                html: `${SVG_ICONS.folder} ${finalPlaylistTitle}`,
                atribute: {
                    title: `${t('playlist')}: ${finalPlaylistTitle} (${playlistKey})`
                }
            });

            // Aplicar color del borde como color de texto
            const borderColor = generatePlaylistBorderColor(playlistKey);
            playlistIndicator.style.color = borderColor;
            playlistIndicator.style.fontWeight = 'bold';
            playlistIndicator.style.fontSize = '0.85em';
            playlistIndicator.style.marginTop = '2px';

            // Agregar bot√≥n de acceso directo a la playlist
            // Para playlists mix (RDxxxx), usar URL del video con el par√°metro list
            // Para playlists regulares, usar URL de playlist est√°ndar
            const playlistUrl = playlistKey?.startsWith('RD')
                ? `https://www.youtube.com/watch?v=${videoId}&list=${playlistKey}`
                : `https://www.youtube.com/playlist?list=${playlistKey}`;

            const playlistLink = createElement('a', {
                className: 'ypp-playlist-link',
                html: `${SVG_ICONS.externalLink}`,
                atribute: {
                    title: `${t('openPlaylist')}: ${finalPlaylistTitle}`,
                    href: playlistUrl
                },
                props: { target: '_blank', rel: 'noopener noreferrer' },
                styles: {
                    marginLeft: '8px',
                    color: borderColor,
                    textDecoration: 'none',
                    fontSize: '0.9em'
                }
            });

            playlistIndicator.appendChild(playlistLink);
            infoDiv.appendChild(playlistIndicator);
        }

        infoDiv.appendChild(author);
        infoDiv.appendChild(views);
        infoDiv.appendChild(timestamp);
        log('createVideoEntry', `üîç Verificando mostrar porcentaje de ${videoId}: percent=${percent}, isCompleted=${isCompleted}, condici√≥n=${percent !== null && !isCompleted}`);
        if (percent !== null && !isCompleted) {
            const progressColor = getProgressColor(percent);
            const progressInfo = createElement('div', {
                className: 'ypp-progressInfo',
                html: `${SVG_ICONS.chart} ${percent} ${t('percentWatched')} (${formatTime(normalizeSeconds((remaining)))} ${t('remaining')})`,
                styles: { color: progressColor, fontWeight: 'bold' }
            });
            infoDiv.appendChild(progressInfo);
            log('createVideoEntry', `‚úÖ Porcentaje agregado: ${percent}%`);
        } else {
            log('createVideoEntry', `‚ùå No se mostr√≥ porcentaje: percent=${percent}, isCompleted=${isCompleted}`);
        }
        wrapper.appendChild(infoDiv);

        const buttonContainer = createElement('div', { className: 'ypp-containerButtonsTime' });

        const btnForceTime = createElement('button', {
            className: 'ypp-btn ypp-btn-small',
            html: SVG_ICONS.timer,
            atribute: { title: info.forceResumeTime ? t('changeOrRemoveStartTime', { time: formatTime(normalizeSeconds((info.forceResumeTime))) }) : t('setStartTime') },
            onClickEvent: () => {
                const promptText = info.forceResumeTime
                    ? `${t('enterStartTimeOrEmpty')}:`
                    : `${t('enterStartTime')}:`;
                const timeStr = prompt(promptText, info.forceResumeTime ? formatTime(normalizeSeconds((info.forceResumeTime))) : '');

                if (timeStr === null) { // Usuario cancel√≥
                    return;
                }

                const timeSec = parseTimeToSeconds(timeStr);

                // Determinar si es formato antiguo (playlist anidada) o nuevo (video individual)
                const playlistData = Storage.get(playlistKey);
                const isOldFormat = playlistData?.videos && typeof playlistData.videos === 'object';

                if (isOldFormat && playlistKey) {
                    // Formato antiguo: video est√° dentro de playlist.videos
                    if (playlistData?.videos?.[videoId]) {
                        if (timeSec > 0) {
                            playlistData.videos[videoId].forceResumeTime = timeSec;
                            showFloatingToast(`${SVG_ICONS.check} ${t('startTimeSet')} ${formatTime(normalizeSeconds((timeSec)))}`);
                        } else {
                            delete playlistData.videos[videoId].forceResumeTime;
                            showFloatingToast(`üîì ${t('fixedTimeRemoved')}`);
                        }
                        Storage.set(playlistKey, playlistData);
                    }
                } else {
                    // Formato nuevo: video es entrada individual (con o sin playlistId)
                    const data = Storage.get(videoId);
                    if (data) {
                        if (timeSec > 0) {
                            data.forceResumeTime = timeSec;
                            showFloatingToast(`${SVG_ICONS.check} ${t('startTimeSet')} ${formatTime(normalizeSeconds((timeSec)))}`);
                        } else {
                            delete data.forceResumeTime;
                            showFloatingToast(`üîì ${t('fixedTimeRemoved')}`);
                        }
                        Storage.set(videoId, data);
                    }
                }
                updateVideoList();
            }
        });
        buttonContainer.appendChild(btnForceTime);

        const btnDelete = createElement('button', {
            className: 'ypp-btn ypp-btn-delete ypp-btn-small',
            atribute: { title: t('deleteEntry') },
            html: SVG_ICONS.trash,
            onClickEvent: () => {
                const title = info.title || videoId;
                const itemData = { videoId, info, playlistKey };

                const performDelete = () => {
                    if (playlistKey) {
                        const playlist = Storage.get(playlistKey);
                        if (playlist?.videos && typeof playlist.videos === 'object') {
                            // Formato antiguo: borrar dentro de la playlist
                            if (playlist.videos[videoId]) {
                                delete playlist.videos[videoId];
                                Object.keys(playlist.videos).length
                                    ? Storage.set(playlistKey, playlist)
                                    : Storage.del(playlistKey);
                            }
                        } else {
                            // Formato FreeTube: entrada individual por videoId
                            Storage.del(videoId);
                        }
                    } else {
                        Storage.del(videoId);
                    }
                    updateVideoList();
                };

                const undoDelete = () => {
                    if (playlistKey) {
                        const playlist = Storage.get(playlistKey);
                        if (playlist?.videos && typeof playlist.videos === 'object') {
                            // Restaurar en formato antiguo
                            const pl = playlist || { lastWatchedVideoId: '', videos: {}, title: '' };
                            pl.videos[videoId] = itemData.info;
                            Storage.set(playlistKey, pl);
                        } else {
                            // Restaurar entrada individual (FreeTube)
                            Storage.set(videoId, itemData.info);
                        }
                    } else {
                        Storage.set(videoId, itemData.info);
                    }
                    updateVideoList();
                };

                performDelete();
                showFloatingToast(`${SVG_ICONS.trash} "${title}" ${t('itemDeleted')}`, 5000, {
                    action: {
                        label: t('undo'),
                        callback: undoDelete
                    }
                });
            }
        });
        buttonContainer.appendChild(btnDelete);
        wrapper.appendChild(buttonContainer);

        return wrapper;
    }

    // ------------------------------------------
    // MARK: üóëÔ∏è Clear All Data
    // ------------------------------------------

    let clearedData = null; // Para almacenar datos eliminados y poder deshacer

    function clearAllData() {
        if (!confirm('¬øEst√°s seguro de que quieres eliminar todos los datos?')) return;

        // Guardar datos para posible deshacer
        // No incluir keys de userSettings (contienen configuraci√≥n/idioma) para evitar dejar la UI inaccesible
        const allKeys = Storage.keys().filter(k => !k.startsWith('userSettings'));
        clearedData = {};

        allKeys.forEach(k => {
            clearedData[k] = Storage.get(k);
        });

        log('clearAllData', 'üóëÔ∏è Datos a eliminar:', allKeys, clearedData);

        // Eliminar todos los datos (excepto userSettings)
        allKeys.forEach(k => Storage.del(k));

        // Mostrar toast con opci√≥n de deshacer (usar la propiedad "callback" que espera showFloatingToast)
        showFloatingToast('‚úÖ Todos los datos eliminados', 10000, {
            persistent: true,
            keep: true,
            action: {
                label: 'Deshacer',
                callback: undoClearAll
            }
        });

        // Actualizar UI si es necesario
        updateVideoList();
    }

    function undoClearAll() {
        if (!clearedData || Object.keys(clearedData).length === 0) {
            showFloatingToast('‚ùå No hay datos para restaurar');
            return;
        }

        log('undoClearAll', '‚è™ Restaurando datos:', clearedData);

        // Restaurar datos
        Object.entries(clearedData).forEach(([key, value]) => {
            if (value !== null) {
                Storage.set(key, value);
            }
        });

        showFloatingToast('‚úÖ Datos restaurados correctamente');

        // Limpiar referencia
        clearedData = null;

        // Actualizar UI
        updateVideoList();
    }

    // ------------------------------------------
    // MARK: ‚öôÔ∏è Menu Commands
    // ------------------------------------------

    // Funci√≥n para registrar los comandos del men√∫ con traducciones
    function registerMenuCommands() {
        GM_registerMenuCommand(`‚öôÔ∏è ${t('settings')}`, showSettingsUI);
        /* GM_registerMenuCommand(`üìã ${t('savedVideos')}`, showSavedVideosList); */
        GM_registerMenuCommand(`üìö ${t('viewAllHistory')}`, async () => {
            // Guardar filtros y esperar a que se complete
            await saveFilters({ filterBy: 'all', searchQuery: '' });
            // Establecer filtro global y mostrar lista
            currentFilterBy = 'all';
            showSavedVideosList();
        });
        GM_registerMenuCommand(`‚úÖ ${t('viewCompletedVideos')}`, async () => {
            await saveFilters({ filterBy: 'completed' });
            currentFilterBy = 'completed';
            showSavedVideosList();
        });
    }

    // ------------------------------------------
    // MARK: üì¢ Ad Monitor 
    // ------------------------------------------

    let isAdPlaying = false;

    // Observer centralizado para detectar anuncios
    function createAdStateMonitor() {
        const target = getActiveContainer();
        if (!target) {
            warn('createAdStateMonitor', '‚ö†Ô∏è No se pudo obtener container activo, monitor no inicializado');
            return null;
        }

        // Selectores espec√≠ficos de anuncios activos
        const adSelectors = [
            // Selectores comunes para videos regulares
            '.ytp-ad-player-overlay:not([hidden]):not([style*="display: none"])',
            '.ytp-ad-module:not([hidden]):not([style*="display: none"])',
            '.ytp-ad-text:not([hidden]):not([style*="display: none"])', // Texto del anuncio
            '.ytp-ad-preview:not([hidden]):not([style*="display: none"])', // Preview del anuncio
            '.ytp-ad-skip-button-container:not([hidden]):not([style*="display: none"])',
            '.ytp-ad-preview-container:not([hidden]):not([style*="display: none"])',
            '.ytp-ad-image-overlay:not([hidden]):not([style*="display: none"])',
            '.ytp-ad-overlay-container:not([hidden]):not([style*="display: none"])', // Contenedor overlay
            '.video-ads:not([hidden]):not([style*="display: none"])', // Contenedor general de anuncios
            'ytd-in-feed-ad-layout-renderer' // Anuncios en feed
        ].join(',');

        let observer = null;

        const checkAdState = () => {
            // 1. Verificaci√≥n principal: YTHelper API (m√°s confiable)
            const ytHelperAd = YTHelper?.player?.isPlayingAds;

            log('checkAdState', '‚úÖ Verificaci√≥n principal: YTHelper API', ytHelperAd);

            if (ytHelperAd) {
                log('checkAdState', '‚úÖ Anuncio detectado por YTHelper API');
                isAdPlaying = true;
                return true;
            }

            // 2. Verificaci√≥n de clases en el playerObject (m√©todo del Helper API)
            const playerObject = YTHelper?.player?.playerObject;
            const shouldAvoidUnstarted = playerObject?.classList.contains('unstarted-mode');
            const hasAdClassOnPlayer = !shouldAvoidUnstarted && (
                playerObject?.classList.contains('ad-showing') ||
                playerObject?.classList.contains('ad-interrupting')
            );

            log('checkAdState', '‚úÖ Verificaci√≥n de clases en el playerObject', hasAdClassOnPlayer);

            if (hasAdClassOnPlayer) {
                log('checkAdState', '‚úÖ Anuncio detectado por clases en el playerObject');
                isAdPlaying = true;
                return true;
            }

    

            // 3. Verificaci√≥n de elementos visuales DOM
            const adElement = target.querySelector(adSelectors);
            let adVisible = false;
            
            if (adElement) {
                const styles = getComputedStyle(adElement); // Cachear resultado para evitar m√∫ltiples llamadas
                adVisible = 
                    adElement.offsetParent !== null && // Visible en el DOM
                    styles.display !== 'none' && // No oculto por CSS
                    styles.visibility !== 'hidden' && // No invisible
                    adElement.getBoundingClientRect().height > 0; // Tiene altura
            }

            log('checkAdState', '‚úÖ Verificaci√≥n de elementos visuales DOM', adVisible);

            if (adVisible) {
                log('checkAdState', '‚úÖ Anuncio detectado por elementos visuales DOM');
                isAdPlaying = true;
                return true;
            }

            // 4. Verificaci√≥n para Shorts
            // Validaci√≥n independiente de t√≠tulo/autor sospechoso
            const videoTitle = YTHelper?.video?.title || '';
            const videoAuthor = YTHelper?.video?.author || '';
            const authorLower = videoAuthor.toLowerCase();
            
            // Patrones de autores de anuncios
            const isAdChannel = authorLower.includes('ad upload channel') || 
                               authorLower.includes('video ad');
            const isSuspiciousAuthor = authorLower.includes('game') || 
                                      authorLower.includes('app') ||
                                      authorLower.includes('download') ||
                                      authorLower.includes('install') ||
                                      authorLower.match(/\d{3,}/); // IDs num√©ricos largos
            
            const isGenericTitle = videoTitle === 'YouTube' || videoTitle === 'Advertisement';
            
            const shortsPlayer = document.querySelector('#shorts-player');
            const hasAdCreatedClass = shortsPlayer?.classList.contains('ad-created');
            const isInShortsPage = window.location.pathname.includes('/shorts/');
            
            log('checkAdState', '‚úÖ Verificaci√≥n para Shorts | isInShortsPage', isInShortsPage);
            log('checkAdState', '‚úÖ Verificaci√≥n para Shorts | hasAdCreatedClass', hasAdCreatedClass);
            log('checkAdState', '‚úÖ Verificaci√≥n para Shorts | isAdChannel', isAdChannel);
            log('checkAdState', '‚úÖ Verificaci√≥n para Shorts | isSuspiciousAuthor', isSuspiciousAuthor);
            log('checkAdState', '‚úÖ Verificaci√≥n para Shorts | isGenericTitle', isGenericTitle);
            
            // Anuncio en shorts detectado si:
            let hasAdClassShorts = false;
            if (isInShortsPage) {
                const videoEl = YTHelper?.player?.videoElement;
                const duration = videoEl?.duration || 0;
                
                // 1. Autor claramente de anuncios
                if (isAdChannel) {
                    hasAdClassShorts = true;
                }
                // 2. T√≠tulo gen√©rico "YouTube" es un indicador MUY fuerte de anuncio
                // La mayor√≠a de shorts reales tienen t√≠tulos descriptivos
                else if (isGenericTitle && duration > 0 && duration <= 60) {
                    // Solo NO es anuncio si tiene autor muy largo (contenido real tiende a tener nombres creativos)
                    const hasRealAuthorName = videoAuthor.length > 20 && !isSuspiciousAuthor;
                    hasAdClassShorts = !hasRealAuthorName;
                }
                // 3. Clase ad-created + YTHelper confirma
                else if (hasAdCreatedClass && ytHelperAd) {
                    hasAdClassShorts = true;
                }
            }

            log('checkAdState', '‚úÖ Verificaci√≥n para Shorts | hasAdClassShorts', hasAdClassShorts);

           if (hasAdClassShorts) {
                log('checkAdState', '‚úÖ Anuncio detectado | hasAdClassShorts', hasAdClassShorts);
                isAdPlaying = true;
                return true;
            }
        

            // 5. Fallback: Comparaci√≥n de duraciones (m√©todo del Helper API)
            let durationMismatch = false;
            if (YTHelper?.apiProxy) {
                try {
                    const progressState = YTHelper.apiProxy.getProgressState?.();
                    const reportedDuration = progressState?.duration;
                    const realDuration = YTHelper.apiProxy.getDuration?.();
                    if (reportedDuration && realDuration) {
                        durationMismatch = Math.trunc(realDuration) !== Math.trunc(reportedDuration);
                    }
                } catch (e) {
                    // Silenciar errores del fallback
                }
            }

            log('checkAdState', '‚úÖ Verificaci√≥n para Shorts | durationMismatch', durationMismatch);

            // 6. Detecci√≥n por duraci√≥n corta + elementos de anuncio visibles
            let shortDurationWithAdElements = false;
            const videoEl = YTHelper?.player?.videoElement;
            if (videoEl && videoEl.duration > 0 && videoEl.duration <= 90) {
                // Anuncios pueden ser hasta 90s, especialmente en videos regulares
                const hasAdElements = document.querySelector('.ytp-ad-text, .ytp-ad-skip-button-container, .ytp-ad-preview');
                shortDurationWithAdElements = !!hasAdElements;
            }

            log('checkAdState', '‚úÖ Verificaci√≥n para Shorts | shortDurationWithAdElements', shortDurationWithAdElements);

            const newState = ytHelperAd || hasAdClassOnPlayer || adVisible || hasAdClassShorts || durationMismatch || shortDurationWithAdElements;

            if (newState !== isAdPlaying) {
                const prevState = isAdPlaying;
                isAdPlaying = newState;
                log('adStateMonitor', isAdPlaying ? '‚èπ Anuncio detectado' : '‚úÖ Anuncio finalizado');
                // Log detallado para diagn√≥stico
                const diagDetails = isInShortsPage ? 
                    ` (title:"${videoTitle.substring(0, 20)}", author:"${videoAuthor.substring(0, 25)}", dur:${YTHelper?.player?.videoElement?.duration?.toFixed(1) || 0}s, genTitle:${isGenericTitle})` : '';
                log('adStateMonitor', `Estado cambi√≥: ${prevState} ‚Üí ${newState} | ytHelper: ${ytHelperAd}, playerClass: ${hasAdClassOnPlayer}, visible: ${adVisible}, shorts: ${hasAdClassShorts}${diagDetails}, duration: ${durationMismatch}, shortWithAd: ${shortDurationWithAdElements}`);
                // Disparar eventos para que otras partes del c√≥digo reaccionen
                if (isAdPlaying) {
                    window.dispatchEvent(new CustomEvent('adStateChanged', { detail: { isPlaying: true } }));
                } else {
                    window.dispatchEvent(new CustomEvent('adStateChanged', { detail: { isPlaying: false } }));
                }
            }
        };

        // Usar la funci√≥n debounce centralizada
        const debouncedCheck = debounce(checkAdState, 100);

        const start = () => {
            if (observer) return;
            log('adStateMonitor', 'Iniciando monitor centralizado de anuncios');

            checkAdState();

            observer = new MutationObserver(debouncedCheck);
            observer.observe(target, {
                attributes: true,
                attributeFilter: ['class', 'hidden'],
                childList: true,
                subtree: true
            });
            
            // Log peri√≥dico para verificar que el monitor est√° activo (solo durante anuncios)
            const periodicCheck = setInterval(() => {
                if (isAdPlaying) {
                    log('adStateMonitor', `üîÑ Monitor activo, anuncio a√∫n presente (ytHelper: ${YTHelper?.player?.isPlayingAds})`);
                }
            }, 5000);
            
            // Guardar referencia para limpiarlo despu√©s
            observer._periodicCheck = periodicCheck;
        };

        const stop = () => {
            if (observer) {
                if (observer._periodicCheck) {
                    clearInterval(observer._periodicCheck);
                }
                observer.disconnect();
                observer = null;
                log('adStateMonitor', 'Monitor de anuncios detenido');
            }
        };

        return { start, stop };
    }

    // Iniciar el monitor global
    let adMonitor = null;

    function initAdMonitor() {
        if (adMonitor) {
            log('initAdMonitor', 'üîÑ Deteniendo monitor previo');
            adMonitor.stop();
        }
        adMonitor = createAdStateMonitor();
        if (adMonitor) {
            adMonitor.start();
            log('initAdMonitor', '‚úÖ Monitor de anuncios iniciado correctamente');
        } else {
            warn('initAdMonitor', '‚ùå No se pudo crear el monitor de anuncios');
        }
    }

    // ------------------------------------------
    // MARK: üñê handleNavigation
    // ------------------------------------------

    let waitingForAdEnd = false; // Variable de control para evitar listeners duplicados

    const handleNavigation = () => {
        if (isAdPlaying) {
            // Si ya hay un listener esperando, no agregar otro
            if (waitingForAdEnd) {
                log('handleNavigation', '‚è∏ Ya hay un listener esperando el fin del anuncio.');
                return;
            }
            
            log('handleNavigation', '‚ùå Anuncio en curso, esperando a que finalice...');
            waitingForAdEnd = true;
            
            // Configurar listener para procesar cuando el anuncio termine
            const handleAdEndForNavigation = (event) => {
                if (!event.detail.isPlaying) {
                    log('handleNavigation', '‚ñ∂Ô∏è Anuncio finalizado, reanudando navegaci√≥n.');
                    window.removeEventListener('adStateChanged', handleAdEndForNavigation);
                    waitingForAdEnd = false; // Resetear flag
                    handleNavigation(); // Reintentar navegaci√≥n
                }
            };
            
            window.addEventListener('adStateChanged', handleAdEndForNavigation);
            return;
        }
        const currentUrl = location.href;
        if (currentUrl === lastUrl) return;

        // Limpiar cach√© de video info para asegurar datos frescos
        clearVideoInfoCache();
        
        // Reinicializar monitor de anuncios en cada navegaci√≥n para asegurar que est√© activo
        initAdMonitor();

        isNavigating = true;
        log('handleNavigation', `Navegando a: ${currentUrl} desde ${lastUrl}`);

        // Cancelar cualquier navegaci√≥n pendiente
        if (navigationDebounceTimeout) clearTimeout(navigationDebounceTimeout);

        // Programar nueva limpieza y b√∫squeda de video (50ms de delay optimizado)
        navigationDebounceTimeout = setTimeout(() => {
            currentPageType = getYouTubePageType();
            log('handleNavigation', `Tipo de p√°gina: ${currentPageType}`);

            // Si navegando a home con miniplayer activo, no limpiar ni reprocesar
            // Solo actualizar estados y salir
            if (currentPageType === 'home' && YTHelper?.player?.videoElement) {
                // Verificar que el miniplayer sea realmente visible y activo
                const videoEl = YTHelper.player.videoElement;
                const rect = videoEl.getBoundingClientRect();
                const isVisible = rect.width > 100 && rect.height > 50 && rect.top >= 0; // No oculto arriba
                const isInMiniplayerContainer = videoEl.closest('.ytp-miniplayer-ui, #miniplayer, ytd-miniplayer');

                if (isVisible && isInMiniplayerContainer) {
                    log('handleNavigation', 'üéµ Miniplayer activo en home, manteniendo procesamiento actual');
                    isNavigating = false;
                    lastUrl = currentUrl;
                    return;
                } else {
                    log('handleNavigation', 'üö´ Video detectado pero no es miniplayer visible, continuando navegaci√≥n normal');
                }
            }

            cleanupAll();

            // Verificar si YTHelper ya est√° listo
            const processIfReady = () => {
                if (!YTHelper?.player?.videoElement) {
                    log('handleNavigation', '‚è≥ Esperando evento yt-helper-api-ready...');
                    
                    // Usar evento del Helper API en lugar de polling
                    const handleHelperReady = () => {
                        log('handleNavigation', '‚úÖ YouTube Helper API listo (via evento)');
                        
                        // Verificar de nuevo el estado del anuncio (pudo haber cambiado)
                        if (!isAdPlaying) {
                            log('handleNavigation', '‚ñ∂Ô∏è Anuncio ya finaliz√≥, procesando inmediatamente');
                        }
                        
                        processVideoOrWaitForAd();
                    };
                    
                    YTHelper?.eventTarget?.addEventListener('yt-helper-api-ready', handleHelperReady, { once: true });
                    
                    // Fallback timeout solo por seguridad (5 segundos)
                    setTimeout(() => {
                        YTHelper?.eventTarget?.removeEventListener('yt-helper-api-ready', handleHelperReady);
                        if (YTHelper?.player?.videoElement) {
                            log('handleNavigation', '‚ö†Ô∏è Helper listo pero evento no se dispar√≥');
                            processVideoOrWaitForAd();
                        } else {
                            warn('handleNavigation', '‚ùå Timeout esperando Helper API');
                        }
                    }, 5000);
                    return;
                }

                log('handleNavigation', '‚úÖ YouTube Helper API ya est√° listo');
                processVideoOrWaitForAd();
            };

            // Funci√≥n separada para manejar anuncios y procesar video
            const processVideoOrWaitForAd = () => {
                // Usar el estado centralizado del monitor de anuncios
                if (isAdPlaying) {
                    log('handleNavigation', '‚è∏ Anuncio activo detectado, esperando...');
                    
                    // Esperar evento de cambio de estado de anuncio
                    const handleAdEnd = (event) => {
                        // Solo procesar cuando el anuncio termina (isPlaying: false)
                        if (!event.detail.isPlaying) {
                            log('handleNavigation', '‚ñ∂Ô∏è Anuncio finalizado, procesando video.');
                            window.removeEventListener('adStateChanged', handleAdEnd);
                            processVideoFromHelper();
                        }
                    };
                    
                    window.addEventListener('adStateChanged', handleAdEnd);
                } else {
                    log('handleNavigation', '‚úÖ No hay anuncio, procesando video...');
                    processVideoFromHelper();
                }
            };

            const processVideoFromHelper = async () => {
                try {
                    // Usar getActiveVideoElement que ya tiene todos los fallbacks
                    const videoEl = await getActiveVideoElement();
                    if (!videoEl) {
                        log('handleNavigation', '‚ö†Ô∏è No se encontr√≥ elemento de video, abortando procesamiento');
                        return;
                    }

                    // Verificar si YTHelper est√° disponible
                    const hasYTHelper = typeof YTHelper !== 'undefined' && YTHelper !== null;
                    const hasValidApi = hasYTHelper && YTHelper?.apiProxy && typeof YTHelper?.apiProxy.getDuration === 'function';

                    log('handleNavigation', `YTHelper disponible: ${hasYTHelper}`);
                    log('handleNavigation', `YTHelper.apiProxy disponible: ${!!hasValidApi}`);

                    let player;

                    if (hasValidApi) {
                        // Usar YTHelper.apiProxy (mejor opci√≥n)
                        player = YTHelper.apiProxy;
                    } else if (hasYTHelper && YTHelper.player?.videoElement) {
                        // Fallback a YTHelper sin apiProxy
                        player = {
                            getVideoData: () => ({
                                video_id: YTHelper?.video.id,
                                title: YTHelper?.video?.title || getVideoTittle(null) || null,
                                author: YTHelper?.video?.author || getVideoAuthor(null) || null
                            }),
                            getCurrentTime: () => YTHelper?.player.videoElement?.currentTime || 0,
                            getDuration: () => YTHelper?.video.lengthSeconds || 0,
                            play: () => YTHelper?.player.videoElement?.play(),
                            pause: () => YTHelper?.player.videoElement?.pause()
                        };
                    } else {
                        // Fallback completo sin YTHelper: usar DOM nativo
                        warn('handleNavigation', 'YTHelper no disponible, usando fallback DOM nativo');
                        const urlParams = new URLSearchParams(window.location.search);
                        const videoId = urlParams.get('v') || extractOrNormalizeVideoId(window.location.href)?.id;

                        player = {
                            getVideoData: () => ({
                                video_id: videoId,
                                title: getVideoTittle(null) || null,
                                author: getVideoAuthor(null) || null
                            }),
                            getCurrentTime: () => videoEl.currentTime || 0,
                            getDuration: () => videoEl.duration || 0,
                            play: () => videoEl.play(),
                            pause: () => videoEl.pause()
                        };
                    }

                    log('handleNavigation', `Player a usar tiene getDuration: ${typeof player.getDuration}`);
                    log('handleNavigation', `Video element encontrado: ${videoEl.constructor.name}`);
                    processVideo(player, videoEl);
                    log('handleNavigation', '‚úÖ processVideo ejecutado correctamente');
                } catch (error) {
                    conError('handleNavigation', 'Error al procesar video:', error);
                } finally {
                    isNavigating = false;
                    lastUrl = currentUrl;
                }
            };

            // Iniciar verificaci√≥n
            processIfReady();
        }, 50); // Delay m√≠nimo para estabilidad del DOM
    };

    // ------------------------------------------
    // MARK: üßπ cleanupAll
    // ------------------------------------------

    // Funci√≥n para limpiar todos los observadores y estados
    const cleanupAll = () => {
        log('cleanupAll', 'Iniciando limpieza de observadores, intervalos y estados');

        // Limpiar timers/intervals
        const timers = [
            { ref: navigationDebounceTimeout, fn: clearTimeout, name: 'navigationDebounceTimeout' }
        ];

        timers.forEach(({ ref, fn, name }) => {
            if (ref) {
                fn(ref);
                log('cleanupAll', `${name} limpiado`);
            }
        });

        // Resetear estados
        navigationDebounceTimeout = null;
        isAdPlaying = false;
        currentlyProcessingVideoId = null;
        lastPlaylistId = null;
        isResuming = false;
        lastResumeId = null;
        lastVideoUrl = ''; // Limpiar URL del video guardada
        log('cleanupAll', 'Estados internos reseteados');

        // Limpiar eventos del video SOLO si no hay miniplayer activo
        // Si hay miniplayer, mantener los listeners para continuar guardando progreso
        const hasActiveMiniplayer = YTHelper?.player?.videoElement &&
            getYouTubePageType() === 'home';

        if (currentVideoEl && !hasActiveMiniplayer) {
            if (currentTimeUpdateHandler) {
                currentVideoEl.removeEventListener('timeupdate', currentTimeUpdateHandler);
                currentTimeUpdateHandler = null;
            }
            delete currentVideoEl._cachedPlayerEl;
            currentVideoEl = null;
            log('cleanupAll', 'Eventos del video eliminados');
        } else if (hasActiveMiniplayer) {
            log('cleanupAll', 'Miniplayer activo detectado, manteniendo event listeners para continuar guardando progreso');
        }

        // No limpiar mensajes si estamos a punto de reanudar (evita borrar mensajes seek antes de establecerlos)
        if (!isResuming) {
            clearPlaybackBarMessage();
            clearShortsMessage();
        } else {
            log('cleanupAll', 'üîÑ Omitiendo limpieza de mensajes durante reanudaci√≥n');
        }

        const container = document.querySelector('.ypp-toast-container');
        if (container?.hasChildNodes()) {
            const toasts = container.querySelectorAll('.ypp-toast');
            let removed = 0;

            toasts.forEach(toast => {
                log('cleanupAll', toast.textContent);
                log('cleanupAll tiene svgsaveicon?', toast.querySelector('.svgSaveIcon'), 'tiene pin icon?', toast.querySelector('.svgPinIcon'), 'tiene timer icon?', toast.querySelector('.svgTimerIcon'), 'tiene play or pause icon?', toast.querySelector('.svgPlayOrPauseIcon'));
                if (/* /[‚èØ]/.test(toast.textContent) || */ toast.querySelector('.svgSaveIcon, .svgPinIcon, .svgTimerIcon, .svgPlayOrPauseIcon')
                ) {
                    toast.remove();
                    removed++;
                }
            });

            if (removed > 0) log('cleanupAll', `${removed} toasts removidos`);
        }
        log('cleanupAll', 'Limpieza completa realizada');
    };

    // ------------------------------------------
    // MARK: üîÑ Migraci√≥n de Datos
    // ------------------------------------------

    /**
     * Migra datos del formato antiguo (playlists anidadas) al nuevo formato FreeTube
     * Esta funci√≥n se ejecuta autom√°ticamente una vez al inicio
     */
    async function migrateToFreeTubeFormat() {
        const MIGRATION_VERSION = 1; // Incrementar solo si cambia la l√≥gica/estructura de migraci√≥n
        const MIGRATION_KEY = 'ypp_migration_freetube_format_version';

        // Verificar si la migraci√≥n ya se realiz√≥ para esta versi√≥n
        const lastMigrationVersion = await GM_getValue(MIGRATION_KEY, 0);
        if (lastMigrationVersion >= MIGRATION_VERSION) {
            log('migrateToFreeTubeFormat', `‚úÖ Migraci√≥n ya aplicada (versi√≥n ${lastMigrationVersion})`);
            return { migrated: 0, skipped: 0 };
        }

        log('migrateToFreeTubeFormat', 'üîÑ Iniciando migraci√≥n de datos al formato FreeTube...');

        let migrated = 0;
        let skipped = 0;
        const keys = Storage.keys().filter(k => !k.startsWith('userSettings') && !k.startsWith('playlist_meta_'));

        for (const key of keys) {
            const data = Storage.get(key);
            if (!data) continue;

            // Si tiene la estructura de playlist anidada (formato antiguo)
            if (data.videos && typeof data.videos === 'object') {
                const playlistId = key;
                const playlistTitle = data.title || playlistId;

                log('migrateToFreeTubeFormat', `üì¶ Migrando playlist ${playlistId} con ${Object.keys(data.videos).length} videos`);

                // Crear metadata de la playlist
                const playlistMetaKey = `playlist_meta_${playlistId}`;
                Storage.set(playlistMetaKey, {
                    playlistId: playlistId,
                    title: playlistTitle,
                    lastWatchedVideoId: data.lastWatchedVideoId || null,
                    lastUpdated: Date.now()
                });

                // Migrar cada video de la playlist
                Object.entries(data.videos).forEach(([videoId, videoData]) => {
                    // Crear entrada de video en formato FreeTube
                    const migratedVideo = {
                        videoId: videoId,
                        timestamp: videoData.timestamp,
                        lastUpdated: videoData.lastUpdated || videoData.savedAt,
                        videoType: videoData.videoType,
                        isCompleted: videoData.isCompleted,
                        duration: videoData.duration,
                        title: videoData.title,
                        author: videoData.author,
                        thumb: videoData.thumb,
                        viewsNumber: videoData.viewsNumber,
                        savedAt: videoData.savedAt,
                        authorId: videoData.authorId,
                        published: videoData.published,
                        description: videoData.description,
                        isLive: videoData.isLive,
                        lastViewedPlaylistId: playlistId,
                        lastViewedPlaylistType: 'channel',
                        lastViewedPlaylistItemId: null,
                        // Preservar campos opcionales si existen
                        forceResumeTime: videoData.forceResumeTime
                    };

                    Storage.set(videoId, migratedVideo);
                    migrated++;
                    log('migrateToFreeTubeFormat', `‚úÖ Video ${videoId} migrado`);
                });

                // Eliminar la entrada antigua de playlist
                Storage.del(key);
                log('migrateToFreeTubeFormat', `‚úÖ Playlist ${playlistId} migrada completamente`);
            } else if (data.videoId || data.timestamp !== undefined) {
                // Ya est√° en formato correcto (o cercano), verificar que tenga campos FreeTube
                if (!data.lastViewedPlaylistId && !data.lastViewedPlaylistType) {
                    // Agregar campos FreeTube faltantes
                    const updated = {
                        ...data,
                        videoId: data.videoId || key,
                        lastViewedPlaylistId: null,
                        lastViewedPlaylistType: '',
                        lastViewedPlaylistItemId: null
                    };
                    Storage.set(key, updated);
                    migrated++;
                }
                skipped++;
            }
        }

        // Marcar la migraci√≥n como completada para esta versi√≥n
        await GM_setValue(MIGRATION_KEY, MIGRATION_VERSION);

        log('migrateToFreeTubeFormat', `‚úÖ Migraci√≥n completada: ${migrated} videos migrados, ${skipped} ya estaban en formato correcto`);
        return { migrated, skipped };
    }

    // ------------------------------------------
    // MARK: üöÄ Init
    // ------------------------------------------

    // Variables de control de inicializaci√≥n
    let isGloballyInitialized = false;
    let initializationPromise = null;

    // Inicializaci√≥n global (solo una vez)
    const initializeGlobal = async () => {
        if (isGloballyInitialized) {
            log('initializeGlobal', '‚úÖ Ya inicializado globalmente, omitiendo...');
            return;
        }

        if (initializationPromise) {
            log('initializeGlobal', '‚è≥ Inicializaci√≥n en progreso, esperando...');
            return await initializationPromise;
        }

        initializationPromise = (async () => {
            log('initializeGlobal', 'üöÄ Iniciando inicializaci√≥n global...');

            // --- Inicializar YouTube Helper API ---
            try {
                YTHelper = await waitForHelper();
                log('initializeGlobal', '‚úÖ Referencia a YouTube Helper API obtenida');
            } catch (error) {
                conError('initializeGlobal', '‚ùå Helper API no disponible:', error);
            }

            // --- Cargar traducciones ---
            try {
                const externalTranslations = await loadTranslations();
                if (externalTranslations && Object.keys(externalTranslations).length > 0) {
                    log('initializeGlobal', '‚úÖ Traducciones externas cargadas correctamente');
                    LANGUAGE_FLAGS = externalTranslations.flags || FALLBACK_FLAGS;
                    TRANSLATIONS = externalTranslations.translations || FALLBACK_TRANSLATIONS;
                } else {
                    warn('initializeGlobal', '‚ö†Ô∏è Traducciones externas incompletas, usando fallback');
                    LANGUAGE_FLAGS = FALLBACK_FLAGS;
                    TRANSLATIONS = FALLBACK_TRANSLATIONS;
                }
            } catch (error) {
                conError('initializeGlobal', '‚ùå Error al cargar traducciones:', error);
                LANGUAGE_FLAGS = FALLBACK_FLAGS;
                TRANSLATIONS = FALLBACK_TRANSLATIONS;
            }

            // --- Cargar configuraci√≥n y establecer idioma ---
            try {
                cachedSettings = await Settings.get();
                log('initializeGlobal', 'Settings cargados:', cachedSettings);

                let langToUse;

                if (cachedSettings.language && TRANSLATIONS[cachedSettings.language] && cachedSettings.language !== CONFIG.defaultSettings.language) {
                    // Idioma guardado por el usuario y v√°lido
                    langToUse = cachedSettings.language;
                    log('initializeGlobal', `Idioma guardado v√°lido: ${langToUse}`);
                } else {
                    // Primera carga o idioma no configurado, usar navegador si existe
                    const browserLang = detectBrowserLanguage();
                    langToUse = TRANSLATIONS[browserLang] ? browserLang : CONFIG.defaultSettings.language;
                    log('initializeGlobal', `Idioma detectado o fallback: ${langToUse}`);
                }

                await setLanguage(langToUse);
                log('initializeGlobal', `üåê Idioma configurado: ${langToUse}`);

                // Guardar preferencia si era primera carga
                if (!cachedSettings.language || cachedSettings.language === CONFIG.defaultSettings.language) {
                    cachedSettings.language = langToUse;
                    await Settings.set(cachedSettings);
                    log('initializeGlobal', `Idioma guardado en settings: ${langToUse}`);
                }
            } catch (error) {
                conError('initializeGlobal', '‚ùå Error al cargar settings o establecer idioma:', error);
            }

            // --- Normalizar almacenamiento ---
            try {
                if (typeof normalizeYouTubeStorageKeys === 'function') {
                    await normalizeYouTubeStorageKeys();
                    log('initializeGlobal', 'üßπ Storage normalizado correctamente.');
                } else {
                    warn('initializeGlobal', '‚ö†Ô∏è normalizeYouTubeStorageKeys no definida a√∫n.');
                }
            } catch (err) {
                conError('initializeGlobal', '‚ùå Error al normalizar Storage:', err);
            }

            // --- Migrar datos al formato FreeTube ---
            try {
                const migrationResult = await migrateToFreeTubeFormat();
                if (migrationResult.migrated > 0) {
                    log('initializeGlobal', `‚úÖ Migraci√≥n completada: ${migrationResult.migrated} videos migrados`);
                }
            } catch (err) {
                conError('initializeGlobal', '‚ùå Error durante la migraci√≥n de datos:', err);
            }

            // --- Registrar comandos e inyectar estilos ---
            try {
                registerMenuCommands();
                injectStyles();
                injectProgressBarCSS();
                log('initializeGlobal', '‚úÖ Comandos y estilos registrados');
                // Crear bot√≥n flotante si est√° habilitado en settings
                if (typeof createFloatingButton === 'function') {
                    await createFloatingButton();
                }
            } catch (error) {
                conError('initializeGlobal', '‚ùå Error al registrar men√∫ o inyectar estilos:', error);
            }

            // --- Iniciar monitor de anuncios ---
            // Nota: El primer intento puede fallar si el DOM no est√° listo
            // handleNavigation lo reiniciar√° cuando sea necesario
            try {
                initAdMonitor();
                log('initializeGlobal', '‚úÖ Intento inicial de monitor de anuncios');
            } catch (error) {
                warn('initializeGlobal', '‚ö†Ô∏è Primer intento de monitor fall√≥ (normal si DOM no est√° listo):', error);
            }

            // --- Configurar eventos de navegaci√≥n ---
            const debouncedNavigation = debounce(handleNavigation, 50);
            window.addEventListener('yt-navigate-finish', debouncedNavigation);
            log('initializeGlobal', '‚úÖ Event listeners configurados');
            
            // --- Ejecutar handleNavigation inicial para procesar p√°gina actual ---
            setTimeout(() => {
                log('initializeGlobal', 'üîÑ Ejecutando navegaci√≥n inicial...');
                handleNavigation();
            }, 500); // Esperar a que el DOM est√© completamente listo

            isGloballyInitialized = true;
            log('initializeGlobal', '‚ú® Inicializaci√≥n global completada');
        })();

        return await initializationPromise;
    };

    // Inicializaci√≥n por p√°gina (se ejecuta en cada navegaci√≥n)
    const initializePage = async () => {
        log('initializePage', 'üìÑ Iniciando inicializaci√≥n de p√°gina...');
        await initializeGlobal();
        log('initializePage', '‚úÖ P√°gina inicializada');
    };

    // Funci√≥n principal de inicializaci√≥n
    const init = async () => {
        try {
            await initializePage();

            // Procesar p√°gina inicial
            log('init', '‚ú® Script completamente inicializado');

            // Forzar inicializaci√≥n de la p√°gina actual, ya que 'yt-navigate-finish'
            // puede no dispararse en la carga inicial.
            setTimeout(() => handleNavigation(), 500);
        } catch (error) {
            conError('init', '‚ùå Error durante la inicializaci√≥n:', error);
        }
    };

    init();
})();