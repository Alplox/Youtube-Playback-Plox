// ==UserScript==
// @name         YouTube Playback Plox
// @name:en      YouTube Playback Plox
// @name:es      YouTube Reproducci√≥n Plox
// @name:fr      YouTube Lecture Plox
// @name:de      YouTube Wiedergabe Plox
// @name:it      YouTube Riproduzione Plox
// @name:pt-BR   YouTube Reprodu√ß√£o Plox
// @name:nl      YouTube Afspelen Plox
// @name:pl      YouTube Odtwarzanie Plox
// @name:sv      YouTube Uppspelning Plox
// @name:da      YouTube Afspilning Plox
// @name:no      YouTube Avspilling Plox
// @name:fi      YouTube Toisto Plox
// @name:cs      YouTube P≈ôehr√°v√°n√≠ Plox
// @name:sk      YouTube Prehr√°vanie Plox
// @name:hu      YouTube Lej√°tsz√°s Plox
// @name:ro      YouTube Redare Plox
// @name:be      YouTube –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ Plox
// @name:bg      YouTube –í—ä–∑–ø—Ä–æ–∏–∑–≤–µ–∂–¥–∞–Ω–µ Plox
// @name:el      YouTube ŒëŒΩŒ±œÄŒ±œÅŒ±Œ≥œâŒ≥ŒÆ Plox
// @name:sr      YouTube –†–µ–ø—Ä–æ–¥—É–∫—Ü–∏—ò–∞ Plox
// @name:hr      YouTube Reprodukcija Plox
// @name:sl      YouTube Predvajanje Plox
// @name:lt      YouTube Grotuvas Plox
// @name:lv      YouTube Atska≈Üo≈°ana Plox
// @name:uk      YouTube –í—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è Plox
// @name:ru      YouTube –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ Plox
// @name:tr      YouTube Oynatma Plox
// @name:ar      ŸäŸàÿ™ŸäŸàÿ® ÿ®ŸÑÿßŸäÿ®ÿßŸÉ Plox
// @name:fa      ŸæÿÆÿ¥ €åŸàÿ™€åŸàÿ® Plox
// @name:he      YouTube ◊î◊©◊û◊¢◊î Plox
// @name:hi      YouTube ‡§™‡•ç‡§≤‡•á‡§¨‡•à‡§ï Plox
// @name:bn      YouTube ‡¶™‡ßç‡¶≤‡ßá‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï Plox
// @name:te      YouTube ‡∞™‡±ç‡∞≤‡±á‡∞¨‡±ç‡∞Ø‡∞æ‡∞ï‡±ç Plox
// @name:ta      YouTube ‡Æ™‡Æø‡Æ≥‡Øá‡Æ™‡Ææ‡Æï‡Øç Plox
// @name:mr      YouTube ‡§™‡•ç‡§≤‡•á‡§¨‡•Ö‡§ï Plox
// @name:zh-CN   YouTube Êí≠Êîæ Plox
// @name:zh-TW   YouTube Êí≠Êîæ Plox
// @name:zh-HK   YouTube Êí≠Êîæ Plox
// @name:ja      YouTube ÂÜçÁîü Plox
// @name:ko      YouTube Ïû¨ÏÉù Plox
// @name:th      YouTube ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠ Plox
// @name:vi      YouTube Ph√°t l·∫°i Plox
// @name:id      YouTube Pemutaran Plox
// @name:ms      YouTube Main Semula Plox
// @name:tl      YouTube Playback Plox
// @name:my      YouTube ·Äñ·Äú·Ä±·Ä∑·Äò·ÄÄ·Ä∫ Plox
// @name:sw      YouTube Uchezesha Plox
// @name:am      ·ã®YouTube ·â∞·å´·ãã·âΩ Plox
// @name:ha      YouTube Playback Plox
// @name:ur      YouTube ŸæŸÑ€í ÿ®€å⁄© Plox
// @name:ca      YouTube Reproducci√≥ Plox
// @name:zu      YouTube Playback Plox
// @name:yue      YouTube Êí≠Êîæ Plox
// @name:es-419      YouTube Reproducci√≥n Plox
// @description  Guarda y retoma autom√°ticamente el progreso de v√≠deos en YouTube sin necesidad de iniciar sesi√≥n.
// @description:en  Automatically saves and resumes video playback progress on YouTube without needing to log in.
// @description:es  Guarda y retoma autom√°ticamente el progreso de v√≠deos en YouTube sin necesidad de iniciar sesi√≥n.
// @description:fr  Enregistre et reprend automatiquement la progression de la lecture des vid√©os sur YouTube sans avoir besoin de se connecter.
// @description:de  Speichert und setzt den Fortschritt von YouTube-Videos automatisch fort, ohne dass eine Anmeldung erforderlich ist.
// @description:it  Salva e riprende automaticamente la riproduzione dei video su YouTube senza bisogno di accedere.
// @description:pt-BR  Salva e retoma automaticamente o progresso da reprodu√ß√£o de v√≠deos no YouTube sem precisar fazer login.
// @description:nl  Slaat automatisch de voortgang van video's op YouTube op en hervat deze zonder in te loggen.
// @description:pl  Automatycznie zapisuje i wznawia postƒôp odtwarzania wideo na YouTube bez logowania.
// @description:sv  Sparar och √•terupptar automatiskt videoframsteg p√• YouTube utan att beh√∂va logga in.
// @description:da  Gemmer og genoptager automatisk videoafspilning p√• YouTube uden at logge ind.
// @description:no  Lagrer og gjenopptar automatisk videofremdrift p√• YouTube uten √• logge inn.
// @description:fi  Tallentaa ja jatkaa automaattisesti YouTube-videoiden toistopistett√§ ilman kirjautumista.
// @description:cs  Automaticky ukl√°d√° a obnovuje postup p≈ôehr√°v√°n√≠ vide√≠ na YouTube bez nutnosti p≈ôihl√°≈°en√≠.
// @description:sk  Automaticky uklad√° a obnovuje priebeh prehr√°vania vide√≠ na YouTube bez potreby prihl√°senia.
// @description:hu  Automatikusan menti √©s folytatja a YouTube-vide√≥k lej√°tsz√°si el≈ërehalad√°s√°t bejelentkez√©s n√©lk√ºl.
// @description:ro  SalveazƒÉ »ôi reia automat progresul redƒÉrii videoclipurilor pe YouTube fƒÉrƒÉ a fi nevoie sƒÉ te conectezi.
// @description:be  –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–±–µ—Ä—ñ–≥–∞—î —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª—é—î –ø—Ä–æ–≥—Ä–µ—Å –≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤—ñ–¥–µ–æ –Ω–∞ YouTube –±–µ–∑ –≤—Ö–æ–¥—É –≤ –∞–∫–∞—É–Ω—Ç.
// @description:bg  –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞–ø–∏—Å–≤–∞ –∏ –≤—ä–∑–æ–±–Ω–æ–≤—è–≤–∞ –ø—Ä–æ–≥—Ä–µ—Å–∞ –Ω–∞ –≤–∏–¥–µ–æ—Ç–æ –≤ YouTube –±–µ–∑ –Ω—É–∂–¥–∞ –æ—Ç –≤—Ö–æ–¥.
// @description:el  ŒëœÄŒøŒ∏Œ∑Œ∫ŒµœçŒµŒπ Œ∫Œ±Œπ œÉœÖŒΩŒµœáŒØŒ∂ŒµŒπ Œ±œÖœÑœåŒºŒ±œÑŒ± œÑŒ∑ŒΩ œÄœÅœåŒøŒ¥Œø Œ±ŒΩŒ±œÄŒ±œÅŒ±Œ≥œâŒ≥ŒÆœÇ Œ≤ŒØŒΩœÑŒµŒø œÉœÑŒø YouTube œáœâœÅŒØœÇ ŒΩŒ± œáœÅŒµŒπŒ¨Œ∂ŒµœÑŒ±Œπ œÉœçŒΩŒ¥ŒµœÉŒ∑.
// @description:sr  –ê—É—Ç–æ–º–∞—Ç—Å–∫–∏ —á—É–≤–∞ –∏ –Ω–∞—Å—Ç–∞–≤—ô–∞ –Ω–∞–ø—Ä–µ–¥–∞–∫ —Ä–µ–ø—Ä–æ–¥—É–∫—Ü–∏—ò–µ –≤–∏–¥–µ–æ –∑–∞–ø–∏—Å–∞ –Ω–∞ YouTube-—É –±–µ–∑ –ø—Ä–∏—ò–∞–≤—ô–∏–≤–∞—ö–∞.
// @description:hr  Automatski sprema i nastavlja napredak reprodukcije videozapisa na YouTubeu bez prijave.
// @description:sl  Samodejno shrani in nadaljuje napredek predvajanja videoposnetkov na YouTubu brez prijave.
// @description:lt  Automati≈°kai i≈°saugo ir atnaujina YouTube vaizdo ƒØra≈°≈≥ atk≈´rimo pa≈æangƒÖ be prisijungimo.
// @description:lv  AutomƒÅtiski saglabƒÅ un atsƒÅk video atska≈Üo≈°anas progresu YouTube bez pieteik≈°anƒÅs.
// @description:uk  –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–±–µ—Ä—ñ–≥–∞—î —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª—é—î –ø—Ä–æ–≥—Ä–µ—Å –≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤—ñ–¥–µ–æ –Ω–∞ YouTube –±–µ–∑ –≤—Ö–æ–¥—É –≤ –∞–∫–∞—É–Ω—Ç.
// @description:ru  –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏ –≤–æ–∑–æ–±–Ω–æ–≤–ª—è–µ—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –≤–∏–¥–µ–æ –Ω–∞ YouTube –±–µ–∑ –≤—Ö–æ–¥–∞ –≤ –∞–∫–∫–∞—É–Ω—Ç.
// @description:tr  YouTube'daki video oynatma ilerlemesini otomatik olarak kaydeder ve devam ettirir, giri≈ü yapmaya gerek yok.
// @description:ar  ŸäŸÇŸàŸÖ ÿ®ÿ≠ŸÅÿ∏ Ÿàÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ ÿ™ŸÇÿØŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ ÿπŸÑŸâ ŸäŸàÿ™ŸäŸàÿ® ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ÿØŸàŸÜ ÿßŸÑÿ≠ÿßÿ¨ÿ© ŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ.
// @description:fa  Ÿæ€åÿ¥ÿ±ŸÅÿ™ ŸæÿÆÿ¥ Ÿà€åÿØ€åŸàŸáÿß ÿØÿ± €åŸàÿ™€åŸàÿ® ÿ±ÿß ÿ®Ÿá ÿµŸàÿ±ÿ™ ÿÆŸàÿØ⁄©ÿßÿ± ÿ∞ÿÆ€åÿ±Ÿá Ÿà ÿßÿØÿßŸÖŸá ŸÖ€å‚ÄåÿØŸáÿØ ÿ®ÿØŸàŸÜ ŸÜ€åÿßÿ≤ ÿ®Ÿá Ÿàÿ±ŸàÿØ.
// @description:he  ◊©◊ï◊û◊® ◊ï◊û◊ó◊ì◊© ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊ê◊™ ◊î◊™◊ß◊ì◊û◊ï◊™ ◊î◊†◊ô◊í◊ï◊ü ◊©◊ú ◊°◊®◊ò◊ï◊†◊ô◊ù ◊ë◊ô◊ï◊ò◊ô◊ï◊ë ◊ú◊ú◊ê ◊¶◊ï◊®◊ö ◊ë◊î◊™◊ó◊ë◊®◊ï◊™.
// @description:hi  YouTube ‡§™‡§∞ ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§™‡•ç‡§≤‡•á‡§¨‡•à‡§ï ‡§ï‡•Ä ‡§™‡•ç‡§∞‡§ó‡§§‡§ø ‡§ï‡•ã ‡§∏‡•ç‡§µ‡§ö‡§æ‡§≤‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§∏‡§π‡•á‡§ú‡•á‡§Ç ‡§î‡§∞ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§æ‡§∞‡§Ç‡§≠ ‡§ï‡§∞‡•á‡§Ç, ‡§≤‡•â‡§ó‡§ø‡§® ‡§ï‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ ‡§®‡§π‡•Ä‡§Ç‡•§ 
// @description:bn  YouTube ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì ‡¶™‡ßç‡¶≤‡ßá‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶∞ ‡¶Ö‡¶ó‡ßç‡¶∞‡¶ó‡¶§‡¶ø ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£ ‡¶è‡¶¨‡¶Ç ‡¶™‡ßÅ‡¶®‡¶∞‡¶æ‡¶Ø‡¶º ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®, ‡¶≤‡¶ó‡¶á‡¶®‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶® ‡¶®‡ßá‡¶á‡•§ 
// @description:te  YouTube ‡∞µ‡±Ä‡∞°‡∞ø‡∞Ø‡±ã ‡∞™‡±ç‡∞≤‡±á‡∞¨‡±ç‡∞Ø‡∞æ‡∞ï‡±ç ‡∞™‡±Å‡∞∞‡±ã‡∞ó‡∞§‡∞ø‡∞®‡∞ø ‡∞Ü‡∞ü‡±ã‡∞Æ‡±á‡∞ü‡∞ø‡∞ï‡±ç‚Äå‡∞ó‡∞æ ‡∞∏‡±á‡∞µ‡±ç ‡∞ö‡±á‡∞∏‡∞ø, ‡∞§‡∞ø‡∞∞‡∞ø‡∞ó‡∞ø ‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø, ‡∞≤‡∞æ‡∞ó‡∞ø‡∞®‡±ç ‡∞Ö‡∞µ‡∞∏‡∞∞‡∞Ç ‡∞≤‡±á‡∞¶‡±Å.
// @description:ta  YouTube ‡Æµ‡ØÄ‡Æü‡Æø‡ÆØ‡Øã‡Æï‡Øç‡Æï‡Æ≥‡Æø‡Æ©‡Øç ‡Æ™‡Æø‡Æ≥‡Øá‡Æ™‡Ææ‡Æï‡Øç ‡ÆÆ‡ØÅ‡Æ©‡Øç‡Æ©‡Øá‡Æ±‡Øç‡Æ±‡Æ§‡Øç‡Æ§‡Øà ‡Æ§‡Ææ‡Æ©‡Ææ‡Æï‡Æö‡Øç ‡Æö‡Øá‡ÆÆ‡Æø‡Æ§‡Øç‡Æ§‡ØÅ ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç, ‡Æâ‡Æ≥‡Øç‡Æ®‡ØÅ‡Æ¥‡Øà‡Æµ‡ØÅ ‡Æ§‡Øá‡Æµ‡Øà‡ÆØ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà.
// @description:mr  YouTube ‡§µ‡•ç‡§π‡§ø‡§°‡§ø‡§ì ‡§™‡•ç‡§≤‡•á‡§¨‡•Ö‡§ï ‡§™‡•ç‡§∞‡§ó‡§§‡•Ä ‡§Ü‡§™‡•ã‡§Ü‡§™ ‡§ú‡§§‡§® ‡§ï‡§∞‡§§‡•á ‡§Ü‡§£‡§ø ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§∏‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§§‡•á, ‡§≤‡•â‡§ó‡§ø‡§® ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§®‡§æ‡§π‡•Ä.
// @description:zh-CN Ëá™Âä®‰øùÂ≠òÂπ∂ÊÅ¢Â§ç YouTube ËßÜÈ¢ëÁöÑÊí≠ÊîæËøõÂ∫¶ÔºåÊó†ÈúÄÁôªÂΩï„ÄÇ
// @description:zh-TW  Ëá™ÂãïÂÑ≤Â≠òÂèäÁπºÁ∫å YouTube ÂΩ±ÁâáÊí≠ÊîæÈÄ≤Â∫¶ÔºåÁÑ°ÈúÄÁôªÂÖ•„ÄÇ
// @description:zh-HK  Ëá™ÂãïÂÑ≤Â≠òÂèäÁπºÁ∫å YouTube ÂΩ±ÁâáÊí≠ÊîæÈÄ≤Â∫¶ÔºåÁÑ°ÈúÄÁôªÂÖ•„ÄÇ
// @description:ja  YouTube „ÅÆÂãïÁîªÂÜçÁîü„ÅÆÈÄ≤Ë°åÁä∂Ê≥Å„ÇíËá™Âãï„Åß‰øùÂ≠ò„ÉªÂÜçÈñã„Åó„Åæ„Åô„ÄÇ„É≠„Ç∞„Ç§„É≥„ÅØ‰∏çË¶Å„Åß„Åô„ÄÇ
// @description:ko  YouTube ÎèôÏòÅÏÉÅ Ïû¨ÏÉù ÏßÑÌñâ ÏÉÅÌô©ÏùÑ ÏûêÎèôÏúºÎ°ú Ï†ÄÏû•ÌïòÍ≥† Ïù¥Ïñ¥ÏÑú Ïû¨ÏÉùÌï©ÎãàÎã§. Î°úÍ∑∏Ïù∏ Î∂àÌïÑÏöî.
// @description:th  ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ö‡∏ô YouTube ‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö.
// @description:vi  T·ª± ƒë·ªông l∆∞u v√† ti·∫øp t·ª•c ti·∫øn tr√¨nh ph√°t video tr√™n YouTube m√† kh√¥ng c·∫ßn ƒëƒÉng nh·∫≠p.
// @description:id  Menyimpan dan melanjutkan kemajuan pemutaran video di YouTube secara otomatis tanpa perlu login.
// @description:ms  Menyimpan dan menyambung semula kemajuan main balik video di YouTube secara automatik tanpa perlu log masuk.
// @description:tl  Awtomatikong ini-save at ipinagpapatuloy ang progreso ng video playback sa YouTube nang hindi nagla-log in.
// @description:my  YouTube ·Äó·ÄÆ·Äí·ÄÆ·Äö·Ä≠·ÄØ·Äñ·Äú·Ä±·Ä∑·Äò·ÄÄ·Ä∫ ·Äê·Ä≠·ÄØ·Ä∏·Äê·ÄÄ·Ä∫·Äô·Äæ·ÄØ·ÄÄ·Ä≠·ÄØ ·Ä°·Äú·Ä≠·ÄØ·Ä°·Äú·Äª·Ä±·Ä¨·ÄÄ·Ä∫ ·Äû·Ä≠·Äô·Ä∫·Ä∏·ÄÜ·Ää·Ä∫·Ä∏·Äï·Äº·ÄÆ·Ä∏ ·Äë·Äï·Ä∫·Äô·Ä∂·ÄÖ·Äê·ÄÑ·Ä∫·Äî·Ä≠·ÄØ·ÄÑ·Ä∫·Äû·Ää·Ä∫·Åã ·Äù·ÄÑ·Ä∫·Äõ·Ä±·Ä¨·ÄÄ·Ä∫·Äõ·Äî·Ä∫ ·Äô·Äú·Ä≠·ÄØ·Ä°·Äï·Ä∫·Äï·Ä´·Åã
// @description:sw  Hifadhi na endelea kwa kiotomatiki maendeleo ya uchezaji wa video kwenye YouTube bila kuingia.
// @description:am  ·â†YouTube ·àã·ã≠ ·ã®·â™·ã≤·ãÆ ·àò·å´·ãà·âª ·ä•·ãµ·åà·âµ·äï ·â†·à´·à± ·ã´·àµ·âÄ·àù·å£·àç ·ä•·äì ·ã´·âÄ·å•·àã·àç ·â†·àò·åç·â£·âµ ·ã´·àµ·çà·àç·åã·àç·ç¢
// @description:ha  Ajiye kuma ci gaba da ci gaban kallon bidiyo a YouTube ta atomatik ba tare da shiga ba.
// @description:ur  YouTube Ÿæÿ± Ÿà€å⁄à€åŸàÿ≤ ⁄©€å ŸæŸÑ€í ÿ®€å⁄© ⁄©€å Ÿæ€åÿ¥ ÿ±ŸÅÿ™ ⁄©Ÿà ÿÆŸàÿØ⁄©ÿßÿ± ÿ∑ÿ±€åŸÇ€í ÿ≥€í ŸÖÿ≠ŸÅŸàÿ∏ ÿßŸàÿ± ÿØŸàÿ®ÿßÿ±€Å ÿ¥ÿ±Ÿàÿπ ⁄©ÿ±€å⁄∫ÿå ŸÑÿß⁄Ø ÿßŸÜ ⁄©€å ÿ∂ÿ±Ÿàÿ±ÿ™ ŸÜ€Å€å⁄∫€î 
// @description:ca  Desa i repr√®n autom√†ticament el progr√©s de reproducci√≥ de v√≠deos a YouTube sense necessitat d'iniciar sessi√≥.
// @description:zu  Igcina futhi uqhubeke ngokuzenzakalelayo nokuqhubeka kwevidiyo ku-YouTube ngaphandle kokungena.
// @description:yue  Ëá™ÂãïÂÑ≤Â≠òÂèäÁπºÁ∫å YouTube ÂΩ±ÁâáÊí≠ÊîæÈÄ≤Â∫¶ÔºåÁÑ°ÈúÄÁôªÂÖ•„ÄÇ
// @description:es-419  Guarda y reanuda autom√°ticamente el progreso de reproducci√≥n de videos en YouTube sin necesidad de iniciar sesi√≥n.
// @homepage     https://github.com/Alplox/Youtube-Playback-Plox
// @supportURL   https://github.com/Alplox/Youtube-Playback-Plox/issues
// @version      0.0.6-6
// @author       Alplox
// @match        https://www.youtube.com/*
// @icon         https://raw.githubusercontent.com/Alplox/StartpagePlox/refs/heads/main/assets/favicon/favicon.ico
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_registerMenuCommand
// @grant        GM_xmlhttpRequest
// @run-at       document-end
// @namespace    youtube-playback-plox
// @license      MIT
// @downloadURL  https://raw.githubusercontent.com/Alplox/Youtube-Playback-Plox/refs/heads/main/youtube-playback-plox.user.js
// @updateURL    https://raw.githubusercontent.com/Alplox/Youtube-Playback-Plox/refs/heads/main/youtube-playback-plox.meta.js
// @require      https://update.greasyfork.org/scripts/549881/1684270/YouTube%20Helper%20API.js
// ==/UserScript==

// ------------------------------------------
// MARK: üîç SISTEMA DE LOGGING
// ------------------------------------------

(function () {
    'use strict';

    // 1. Determinar si el modo debug est√° activo
    const DEBUG = true; // Cambiar a 'false' para desactivar los logs de depuraci√≥n en producci√≥n

    // 2. Crear el objeto del logger en el √°mbito global (window)
    window.MyScriptLogger = {
        log: (context, ...args) => {
            if (DEBUG) {
                console.log(`%c[${context}]`, 'color: #6a9955;', ...args);
            }
        },
        warn: (context, ...args) => {
            if (DEBUG) {
                console.warn(`%c[${context}]`, 'color: #ce9178; font-weight: bold;', ...args);
            }
        },
        error: (context, ...args) => {
            // Los errores siempre se muestran
            console.error(`%c[${context}]`, 'color: #f44747; font-weight: bold;', ...args);
        }
    };

})();

// Atajo para no tener que escribir window.MyScriptLogger cada vez
const { log, warn, error: conError } = window.MyScriptLogger;

// --- INICIO CARGA L√ìGICA PRINCIPAL DEL USERSCRIPT ---

(() => {
    'use strict';

    // ------------------------------------------
    // MARK: üåê Carga de Traducciones
    // ------------------------------------------

    // URL del archivo de traducciones
    const TRANSLATIONS_URL = 'https://raw.githubusercontent.com/Alplox/Youtube-Playback-Plox/refs/heads/main/translations.json';
    const TRANSLATIONS_URL_BACKUP = 'https://cdn.jsdelivr.net/gh/Alplox/Youtube-Playback-Plox@refs/heads/main/translations.json';

    // Variables globales para las traducciones
    let TRANSLATIONS = {};
    let LANGUAGE_FLAGS = {};

    // Traducciones b√°sicas de fallback en caso de error
    const FALLBACK_FLAGS = {
        "en-US": {
            "emoji": "üá∫üá∏",
            "code": "en-US",
            "name": "English (US)"
        },
        "es-ES": {
            "emoji": "üá™üá∏",
            "code": "es-ES",
            "name": "Espa√±ol"
        },
        "fr": {
            "emoji": "üá´üá∑",
            "code": "fr",
            "name": "Fran√ßais"
        }
    };

    const FALLBACK_TRANSLATIONS = {
        "en-US": {
            "settings": "Settings",
            "savedVideos": "View saved videos",
            "close": "Close",
            "save": "Save",
            "cancel": "Cancel",
            "delete": "Delete",
            "undo": "Undo",
            "enableSavingFor": "Enable saving for",
            "regularVideos": "Regular videos",
            "shorts": "Shorts",
            "liveStreams": "Live streams",
            "showNotifications": "Show save notifications",
            "minSecondsBetweenSaves": "Minimum seconds between saves",
            "showFloatingButton": "Show floating button",
            "language": "Language",
            "alertStyle": "Alert style in playback bar",
            "alertIconText": "Icon + Text",
            "alertIconOnly": "Icon Only",
            "alertTextOnly": "Text Only",
            "alertHidden": "Hidden",
            "noSavedVideos": "No saved videos.",
            "sortBy": "Sort by",
            "mostRecent": "Most recent",
            "oldest": "Oldest",
            "titleAZ": "Title (A-Z)",
            "filterByType": "Filter by type",
            "all": "All",
            "videos": "Videos",
            "playlist": "Playlist",
            "searchByTitleOrAuthor": "Search by title or author...",
            "export": "Export",
            "import": "Import",
            "progressSaved": "Progress saved",
            "dataExported": "Data exported",
            "itemsImported": "Imported {count} items",
            "importError": "Error importing. Make sure the file is valid.",
            "configurationSaved": "Configuration saved",
            "startTimeSet": "Start time set to",
            "fixedTimeRemoved": "Fixed time removed.",
            "itemDeleted": "deleted.",
            "unknownError": "Unknown error",
            "modulesFailed": "{count} module(s) failed: {names}",
            "retryNow": "Retry now",
            "retryCompleted": "Retry completed",
            "progress": "Progress",
            "alwaysStartFrom": "Always start from",
            "resumedAt": "Resumed at",
            "locked": "üîí",
            "percentWatched": "% watched",
            "remaining": "remaining",
            "setStartTime": "Set start time",
            "changeOrRemoveStartTime": "Always start from {time} (Click to change or remove)",
            "enterStartTime": "Enter the start time you always want to use (example: 1:23)",
            "enterStartTimeOrEmpty": "Enter the start time you always want to use (example: 1:23) or leave empty to remove",
            "deleteEntry": "Delete entry",
            "youtubePlaybackPlox": "YouTube Playback Plox",
            "playlistPrefix": "Playlist",
            "unknown": "Unknown",
            "notAvailable": "N/A",
            "clearAll": "Clear all",
            "clearAllConfirm": "Are you sure you want to delete ALL saved videos? This action can be undone.",
            "allItemsCleared": "All items cleared",
            "undoClearAll": "Undo",
            "viewAllHistory": "View all history",
            "viewCompletedVideos": "View completed videos",
            "completed": "Completed",
            "completedVideos": "Completed videos"
        },
        "es-ES": {
            "settings": "Configuraci√≥n",
            "savedVideos": "Ver videos guardados",
            "close": "Cerrar",
            "save": "Guardar",
            "cancel": "Cancelar",
            "delete": "Eliminar",
            "undo": "Deshacer",
            "enableSavingFor": "Activar guardado para",
            "regularVideos": "Videos regulares",
            "shorts": "Shorts",
            "liveStreams": "Directos (Livestreams)",
            "showNotifications": "Mostrar notificaciones de guardado",
            "minSecondsBetweenSaves": "Intervalo segundos m√≠nimos entre guardados",
            "showFloatingButton": "Mostrar bot√≥n flotante",
            "language": "Idioma",
            "alertStyle": "Estilo de alertas en la barra de reproducci√≥n",
            "alertIconText": "Icono + Texto",
            "alertIconOnly": "Solo Icono",
            "alertTextOnly": "Solo Texto",
            "alertHidden": "Oculto",
            "noSavedVideos": "No hay videos guardados.",
            "sortBy": "Ordenar por",
            "mostRecent": "M√°s recientes",
            "oldest": "M√°s antiguos",
            "titleAZ": "T√≠tulo (A-Z)",
            "filterByType": "Filtrar por tipo",
            "all": "Todos",
            "videos": "Videos",
            "playlist": "Playlist",
            "searchByTitleOrAuthor": "Buscar por t√≠tulo o autor...",
            "export": "Exportar",
            "import": "Importar",
            "progressSaved": "Progreso guardado",
            "dataExported": "Datos exportados",
            "itemsImported": "Importados {count} elementos",
            "importError": "Error al importar. Aseg√∫rate de que el archivo sea v√°lido.",
            "configurationSaved": "Configuraci√≥n guardada",
            "startTimeSet": "Tiempo de inicio establecido en",
            "fixedTimeRemoved": "Tiempo fijo eliminado.",
            "itemDeleted": "eliminado.",
            "unknownError": "Error desconocido",
            "modulesFailed": "{count} m√≥dulo(s) fallaron: {names}",
            "retryNow": "Reintentar ahora",
            "retryCompleted": "Reintentos completados",
            "progress": "Progreso",
            "alwaysStartFrom": "Siempre desde",
            "resumedAt": "Reanudado en",
            "locked": "üîí",
            "percentWatched": "% visto",
            "remaining": "restantes",
            "setStartTime": "Establecer tiempo de inicio",
            "changeOrRemoveStartTime": "Siempre empezar en {time} (Click para cambiar o eliminar)",
            "enterStartTime": "Introduce el tiempo de inicio que siempre quieres usar (ejemplo: 1:23)",
            "enterStartTimeOrEmpty": "Introduce el tiempo de inicio que siempre quieres usar (ejemplo: 1:23) o deja vac√≠o para eliminar",
            "deleteEntry": "Eliminar entrada",
            "youtubePlaybackPlox": "YouTube Playback Plox",
            "playlistPrefix": "Playlist",
            "unknown": "Desconocido",
            "notAvailable": "N/A",
            "clearAll": "Eliminar todo",
            "clearAllConfirm": "¬øEst√°s seguro de que quieres eliminar TODOS los videos guardados? Esta acci√≥n se puede deshacer.",
            "allItemsCleared": "Todos los elementos eliminados",
            "undoClearAll": "Deshacer",
            "viewAllHistory": "Ver todo el historial",
            "viewCompletedVideos": "Ver videos completados",
            "completed": "Completado",
            "completedVideos": "Videos completados"
        },
        "fr": {
            "settings": "Param√®tres",
            "savedVideos": "Voir les vid√©os enregistr√©es",
            "close": "Fermer",
            "save": "Enregistrer",
            "cancel": "Annuler",
            "delete": "Supprimer",
            "undo": "Annuler",
            "enableSavingFor": "Activer la sauvegarde pour",
            "regularVideos": "Vid√©os r√©guli√®res",
            "shorts": "Shorts",
            "liveStreams": "Diffusions en direct",
            "showNotifications": "Afficher les notifications de sauvegarde",
            "minSecondsBetweenSaves": "Secondes minimales entre les sauvegardes",
            "showFloatingButton": "Afficher le bouton flottant",
            "language": "Langue",
            "alertStyle": "Style d'alerte dans la barre de lecture",
            "alertIconText": "Ic√¥ne + Texte",
            "alertIconOnly": "Ic√¥ne uniquement",
            "alertTextOnly": "Texte uniquement",
            "alertHidden": "Masqu√©",
            "noSavedVideos": "Aucune vid√©o enregistr√©e.",
            "sortBy": "Trier par",
            "mostRecent": "Plus r√©cent",
            "oldest": "Plus ancien",
            "titleAZ": "Titre (A-Z)",
            "filterByType": "Filtrer par type",
            "all": "Tous",
            "videos": "Vid√©os",
            "playlist": "Playlist",
            "searchByTitleOrAuthor": "Rechercher par titre ou auteur...",
            "export": "Exporter",
            "import": "Importer",
            "progressSaved": "Progr√®s enregistr√©",
            "dataExported": "Donn√©es export√©es",
            "itemsImported": "{count} √©l√©ments import√©s",
            "importError": "Erreur lors de l'importation. Assurez-vous que le fichier est valide.",
            "configurationSaved": "Configuration enregistr√©e",
            "startTimeSet": "Heure de d√©but d√©finie √†",
            "fixedTimeRemoved": "Heure fixe supprim√©e.",
            "itemDeleted": "supprim√©.",
            "unknownError": "Erreur inconnue",
            "modulesFailed": "{count} module(s) ont √©chou√© : {names}",
            "retryNow": "R√©essayer maintenant",
            "retryCompleted": "R√©essais termin√©s",
            "progress": "Progr√®s",
            "alwaysStartFrom": "Toujours commencer √†",
            "resumedAt": "Repris √†",
            "locked": "üîí",
            "percentWatched": "% regard√©",
            "remaining": "restant",
            "setStartTime": "D√©finir l'heure de d√©but",
            "changeOrRemoveStartTime": "Toujours commencer √† {time} (Cliquez pour changer ou supprimer)",
            "enterStartTime": "Entrez l'heure de d√©but que vous souhaitez toujours utiliser (exemple: 1:23)",
            "enterStartTimeOrEmpty": "Entrez l'heure de d√©but que vous souhaitez toujours utiliser (exemple: 1:23) ou laissez vide pour supprimer",
            "deleteEntry": "Supprimer l'entr√©e",
            "youtubePlaybackPlox": "YouTube Playback Plox",
            "playlistPrefix": "Playlist",
            "unknown": "Inconnu",
            "notAvailable": "N/A",
            "clearAll": "Tout effacer",
            "clearAllConfirm": "√ätes-vous s√ªr de vouloir supprimer TOUTES les vid√©os enregistr√©es ? Cette action peut √™tre annul√©e.",
            "allItemsCleared": "Tous les √©l√©ments effac√©s",
            "undoClearAll": "Annuler",
            "viewAllHistory": "Voir tout l'historique",
            "viewCompletedVideos": "Voir les vid√©os termin√©es",
            "completed": "Termin√©",
            "completedVideos": "Vid√©os termin√©es"
        }
    };

    // Funci√≥n para cargar las traducciones desde el archivo JSON externo
    async function loadTranslations() {
        return new Promise((resolve) => {
            // Funci√≥n para intentar cargar desde una URL espec√≠fica
            function tryLoadFromUrl(url, isSecondAttempt = false) {
                GM_xmlhttpRequest({
                    method: 'GET',
                    url: url,
                    timeout: 5000,
                    onload: function (response) {
                        try {
                            const data = JSON.parse(response.responseText);

                            if (data.LANGUAGE_FLAGS && Object.keys(data.LANGUAGE_FLAGS).length > 0 &&
                                data.TRANSLATIONS && Object.keys(data.TRANSLATIONS).length > 0) {
                                log('loadTranslations', 'Traducciones externas cargadas correctamente desde: ' + url);
                                resolve(data);
                            } else {
                                if (!isSecondAttempt) {
                                    conError('loadTranslations', 'No se pudieron cargar las traducciones desde el primer enlace, intentando con el segundo...');
                                    tryLoadFromUrl(TRANSLATIONS_URL_BACKUP, true);
                                } else {
                                    conError('loadTranslations', 'No se pudieron cargar las traducciones desde ning√∫n enlace, usando fallback');
                                    resolve({
                                        LANGUAGE_FLAGS: FALLBACK_FLAGS,
                                        TRANSLATIONS: FALLBACK_TRANSLATIONS
                                    });
                                }
                            }
                        } catch (error) {
                            conError('loadTranslations', 'Error al procesar el archivo de traducciones desde ' + url + ':', error);
                            if (!isSecondAttempt) {
                                warn('loadTranslations', 'Intentando con el segundo enlace de traducciones...');
                                tryLoadFromUrl(TRANSLATIONS_URL_BACKUP, true);
                            } else {
                                resolve({
                                    LANGUAGE_FLAGS: FALLBACK_FLAGS,
                                    TRANSLATIONS: FALLBACK_TRANSLATIONS
                                });
                            }
                        }
                    },
                    onerror: function (error) {
                        conError('loadTranslations', 'Error al cargar el archivo de traducciones desde ' + url + ':', error);
                        if (!isSecondAttempt) {
                            warn('loadTranslations', 'Intentando con el segundo enlace de traducciones...');
                            tryLoadFromUrl(TRANSLATIONS_URL_BACKUP, true);
                        } else {
                            resolve({
                                LANGUAGE_FLAGS: FALLBACK_FLAGS,
                                TRANSLATIONS: FALLBACK_TRANSLATIONS
                            });
                        }
                    },
                    ontimeout: function () {
                        conError('loadTranslations', 'Timeout al cargar el archivo de traducciones desde ' + url);
                        if (!isSecondAttempt) {
                            warn('loadTranslations', 'Intentando con el segundo enlace de traducciones...');
                            tryLoadFromUrl(TRANSLATIONS_URL_BACKUP, true);
                        } else {
                            resolve({
                                LANGUAGE_FLAGS: FALLBACK_FLAGS,
                                TRANSLATIONS: FALLBACK_TRANSLATIONS
                            });
                        }
                    }
                });
            }

            // Iniciar el proceso con el primer enlace
            tryLoadFromUrl(TRANSLATIONS_URL);
        });
    }

    // ------------------------------------------
    // MARK: üì¶ Config
    // ------------------------------------------

    const CONFIG = {
        /** Diferencia m√≠nima (en segundos) para considerar un cambio de posici√≥n como v√°lido */
        minSeekDiff: 1.5,

        /** Tiempo desde el final del video (en segundos) para considerarlo como "finalizado" */
        staticFinishSec: 90,

        /** Prefijo para claves en localStorage */
        storagePrefix: 'YT_PLAYBACK_PLOX_',

        /** Enumeraci√≥n de estilos de alerta */
        alertStylesSettings: {
            icon_only: 'iconOnly',
            text_only: 'textOnly',
            icon_and_text: 'iconText',
            no_icon_no_text: 'hidden'
        },

        /** Clave para guardar configuraciones del usuario en GM_* */
        userSettingsKey: 'YT_PLAYBACK_PLOX_userSettings',

        /** Valores predeterminados para configuraciones del usuario */
        defaultSettings: {
            showNotifications: true,
            minSecondsBetweenSaves: 1,
            showFloatingButtons: false,
            saveRegularVideos: true, // Por defecto, guardar videos regulares
            saveShorts: false, // Por defecto, no guardar Shorts
            saveLiveStreams: false, // Por defecto, no guardar directos de URL tipo /live, si es /watch lo toma como regular
            language: 'en-US', // Idioma predeterminado
            alertStyle: 'iconText', // Estilo de alerta predeterminado
        },

        /** Clave para guardar filtros del usuario en GM_* */
        userFiltersKey: 'YT_PLAYBACK_PLOX_userFilters',

        /** Valores predeterminados para filtros del usuario */
        defaultFilters: {
            orderBy: "recent",
            filterBy: "all",
            searchQuery: ""
        }
    };

    // ------------------------------------------
    // MARK: üåê Funciones de traducci√≥n
    // ------------------------------------------

    let currentLanguage = CONFIG.defaultSettings.language; // Idioma predeterminado

    // Funci√≥n para obtener el texto traducido
    function t(key, params = {}) {
        if (!TRANSLATIONS[currentLanguage] || !TRANSLATIONS[currentLanguage][key]) {
            // Si no hay traducci√≥n, intentar con ingl√©s
            if (TRANSLATIONS.en && TRANSLATIONS.en[key]) {
                return replaceParams(TRANSLATIONS.en[key], params);
            }
            // Si no hay ni en ingl√©s, devolver la clave
            return key;
        }
        return replaceParams(TRANSLATIONS[currentLanguage][key], params);
    }

    // Funci√≥n para reemplazar par√°metros en las traducciones
    function replaceParams(text, params) {
        if (!text || typeof text !== 'string') return text;
        return text.replace(/{(\w+)}/g, (match, param) => {
            return params[param] !== undefined ? params[param] : match;
        });
    }

    // Funci√≥n para cambiar el idioma
    async function setLanguage(lang) {
        log('setLanguage', 'lang que llega:', lang);
        let validLang = lang;

        if (!TRANSLATIONS[validLang]) {
            const primary = lang.split('-')[0];
            validLang = Object.keys(TRANSLATIONS).find(k => k === primary || k.startsWith(primary + '-'));
        }

        if (!validLang) validLang = CONFIG.defaultSettings.language;

        currentLanguage = validLang;

        const settings = await Settings.get();
        settings.language = validLang;
        await Settings.set(settings);

        log('setLanguage', 'lang que sale:', validLang);
        return true;
    }

    // Funci√≥n para detectar el idioma del navegador
    function detectBrowserLanguage() {
        const browserLang = navigator.language || navigator.userLanguage; // "es-ES" o "en"
        log('detectBrowserLanguage', 'browserLang:', browserLang);

        // Coincidencia exacta
        log('detectBrowserLanguage', 'TRANSLATIONS[browserLang]:', TRANSLATIONS[browserLang])
        if (TRANSLATIONS[browserLang]) return browserLang;

        // Coincidencia por prefijo (ejemplo: "es" -> "es-ES" o "es-419")
        const primary = browserLang.split('-')[0];
        const matched = Object.keys(TRANSLATIONS).find(k => k === primary || k.startsWith(primary + '-'));
        log('detectBrowserLanguage', 'matched:', matched);
        if (matched) return matched;

        warn(`Idioma del navegador '${browserLang}' no soportado, usando default.`);
        return CONFIG.defaultSettings.language;
    }

    // ------------------------------------------
    // MARK: üé® Styles
    // ------------------------------------------

    function injectStyles() {
        if (document.getElementById('youtube-playback-plox-styles')) return; // evitar duplicados

        const style = document.createElement('style');
        style.id = 'youtube-playback-plox-styles';
        style.textContent = `
:root {
  /* Paleta base */
  --color-bg: #fff;
  --color-text: #222;
  --color-muted: #555;
  --color-light: #888;
  --color-link: #065fd4;
  --color-danger: #dc2626;
  --color-success: #16a34a;
  --color-success-dark: #15803d;
  --color-overlay: rgba(0, 0, 0, 0.4);
  --color-toast: #333;
  --color-primary: #2563eb;
  --color-primary-dark: #1e40af;
  --color-border: #ccc;
  --color-playlist-bg: #f0f8ff; /* Fondo sutil para items de playlist */

  /* Tipograf√≠a */
  --font-base: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;

  /* Espaciado */
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;

  /* Sombra */
  --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.2);
  --shadow-modal: 0 4px 16px rgba(0, 0, 0, 0.25);

  /* Z-index */
  --z-overlay: 9999;
  --z-modal: 10000;
}

/* =========================
   Contenedores y Overlays
========================= */

.ypp-overlay,
.ypp-modalOverlay {
  position: fixed;
  top: 0;
  left: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100vw;
  height: 100vh;
  background: var(--color-overlay);
  z-index: var(--z-overlay);
}

.ypp-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--color-bg);
  border-radius: 8px;
  box-shadow: var(--shadow-md);
  padding: 0; /* Padding manejado por hijos */
  z-index: var(--z-modal);
  width: 550px; /* Un poco m√°s ancho para los nuevos botones */
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  font-family: var(--font-base);
  color: var(--color-text);
}

/* =========================
   Header, Footer, Layout
========================= */

.ypp-header,
.ypp-modalHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--spacing-sm);
  border-bottom: 1px solid var(--color-border);
  flex-shrink: 0;
}

.ypp-filters {
  padding: var(--spacing-md) var(--spacing-lg);
  border-bottom: 1px solid var(--color-border);
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  flex-shrink: 0;
}

.ypp-footer {
  padding: var(--spacing-md) var(--spacing-lg);
  border-top: 2px solid var(--color-border);
  display: flex;
  justify-content: space-between;
  z-index: 10;
  flex-shrink: 0;
}

#video-list-container {
  flex-grow: 1; /* Ocupar el espacio restante */
  overflow-y: auto; /* Hacer scrollable solo esta parte */
  padding: var(--spacing-md) var(--spacing-lg);
}

.ypp-settingsContent {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  max-height: 60vh;
  overflow-y: auto;
}

.ypp-btnGroup {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

/* =========================
   Tipograf√≠a
========================= */

.ypp-emptyMsg {
  text-align: center;
  color: #666;
}

.ypp-playlistTitle {
  margin: var(--spacing-md) 0 var(--spacing-sm);
  color: var(--color-muted);
  cursor: pointer;
  text-decoration: none;
  display: block;
}

.ypp-playlistTitle:hover {
  text-decoration: underline;
}

.ypp-titleLink {
  font-weight: 600;
  font-size: 1.4rem;
  color: var(--color-link);
  text-decoration: none;
  display: block;
  margin-bottom: 2px;
}

.ypp-titleLink:hover {
  text-decoration: underline;
}

.ypp-author,
.ypp-views {
  font-size: 1.1rem;
  color: var(--color-muted);
}

.ypp-timestamp,
.ypp-progressInfo {
  font-size: 1.3rem;
  margin-top: 4px;
}

.ypp-timestamp {
  color: var(--color-muted);
}

.ypp-timestamp.forced {
    color: var(--color-primary-dark);
    font-weight: bold;
}

.ypp-timestamp.completed {
    color: var(--color-success);
    font-weight: bold;
}

.ypp-timestamp.forced.completed {
    /* Video con tiempo fijo Y completado: color mixto */
    color: #15803d;
    font-weight: bold;
    background: linear-gradient(90deg, var(--color-primary-dark) 0%, var(--color-success) 100%);
    background-clip: text;
}

.ypp-progressInfo {
  color: red;
}

/* =========================
   Video List
========================= */

.ypp-videoWrapper {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-md);
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--spacing-sm);
}

.ypp-videoWrapper.playlist-item {
  background-color: var(--color-playlist-bg);
  border-radius: 4px;
  padding: var(--spacing-sm);
  border: 1px solid #ddeeff;
}

.ypp-thumb {
  width: 90px;
  height: 50px;
  object-fit: cover;
  border-radius: 4px;
  margin-right: var(--spacing-sm);
  flex-shrink: 0;
}

.ypp-infoDiv {
  flex-grow: 1;
  min-width: 0; /* Permite que el contenedor se encoja correctamente */
}

.ypp-containerButtonsTime {
    display: flex;
    gap: 5px;
    flex-shrink: 0;
    align-items: center;
    min-width: max-content;
}

/* =========================
   Botones
========================= */

.ypp-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.5em 1em;
  font-weight: 500;
  color: var(--color-bg);
  background-color: var(--color-muted);
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s ease;
  font-size: 1.2em;

  &:hover {
    background-color: var(--color-text);
  }
}

.ypp-btn-small {
    padding: 0.3em 0.6em;
    width: 32px;
    height: 32px;
    flex-shrink: 0;
}

.ypp-btn-outlined {
  background: transparent;
  border: 1px solid currentColor;
  color: var(--color-primary);

  &:hover {
    background-color: var(--color-primary);
    color: var(--color-bg);
  }
}

.ypp-btn-delete {
  background-color: transparent;
  color: var(--color-danger);

  &:hover {
    background-color: var(--color-danger);
    color: var(--color-bg);
  }
}

.ypp-btn-danger {
  background-color: var(--color-danger);
  color: var(--color-bg);
  font-weight: bold;

  &:hover {
    background-color: #c53030;
    transform: scale(1.02);
  }
}

.ypp-save-button {
  background-color: var(--color-success);

  &:hover {
    background-color: var(--color-success-dark);
  }
}

/* =========================
   Toasts
========================= */

.ypp-toast-container {
  position: fixed;
  top: var(--spacing-md);
  right: var(--spacing-md);
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  z-index: var(--z-overlay);
}

.ypp-toast {
  background: var(--color-toast);
  color: white;
  padding: 0.75rem 1rem;
  border-radius: 4px;
  opacity: 0;
  transition: opacity 0.3s ease;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.ypp-toast.persistent {
  background: var(--color-muted);
}

.ypp-toast-action {
    background: var(--color-primary);
    border: none;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    margin-left: auto;
}

/* =========================
   Modal
========================= */

.ypp-modalBox {
  background: var(--color-bg);
  border: 1px solid var(--color-border);
  border-radius: 8px;
  padding: var(--spacing-lg);
  color: var(--color-text);
  max-width: 400px;
  width: 100%;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: var(--shadow-modal);
}

.ypp-modalTitle {
  font-weight: 600;
  color: #111;
  font-size: large;
}

.ypp-modalBody {
  font-size: 1.4rem;
  padding: var(--spacing-sm) var(--spacing-md);
}

/* =========================
   Inputs y Forms
========================= */

.ypp-label {
  display: flex;
  align-items: center;
  gap: 8px;
  color: #333;
}

.ypp-input {
  width: 100%;
  padding: 6px 2px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  margin-top: 5px;
}

.ypp-input-small {
  width: 60px;
}

/* =========================
   Floating Button
========================= */

.ypp-floatingBtnContainer {
  position: fixed;
  bottom: var(--spacing-md);
  right: var(--spacing-md);
  z-index: var(--z-overlay);
  display: flex;
  gap: 10px;
}

/* =========================
   Selector de Idioma con Banderas
========================= */

.ypp-language-selector {
  display: flex;
  align-items: center;
  gap: 8px;
}

.ypp-language-flag {
  font-size: 1.2em;
  margin-right: 5px;
}
`;
        document.head.appendChild(style);
    }

    // ------------------------------------------
    // MARK: üíæ Storage + Settings
    // ------------------------------------------

    const Storage = {
        get(key) {
            try {
                const raw = localStorage.getItem(`${CONFIG.storagePrefix}${key}`);
                return raw ? JSON.parse(raw) : null;
            } catch (error) {
                conError('Storage', `Storage.get: Error al parsear la clave "${key}"`, error);
                return null;
            }
        },
        set(key, value) {
            try {
                const serialized = JSON.stringify(value);
                localStorage.setItem(`${CONFIG.storagePrefix}${key}`, serialized);
            } catch (error) {
                conError('Storage', `Storage.set: Error al guardar la clave "${key}"`, error);
            }
        },
        del(key) {
            try {
                localStorage.removeItem(`${CONFIG.storagePrefix}${key}`);
            } catch (error) {
                conError('Storage', `Storage.del: Error al eliminar la clave "${key}"`, error);
            }
        },
        keys() {
            return Object.keys(localStorage)
                .filter((fullKey) => fullKey.startsWith(CONFIG.storagePrefix))
                .map((fullKey) => fullKey.slice(CONFIG.storagePrefix.length));
        }
    };

    const Settings = {
        async get() {
            try {
                const raw = await GM_getValue(CONFIG.userSettingsKey, null);
                const parsed = raw ? JSON.parse(raw) : {};
                return { ...CONFIG.defaultSettings, ...parsed };
            } catch (error) {
                conError('Settings', 'Error al cargar configuraci√≥n del usuario:', error);
                return { ...CONFIG.defaultSettings };
            }
        },
        async set(settings) {
            try {
                const serialized = JSON.stringify(settings);
                await GM_setValue(CONFIG.userSettingsKey, serialized);
            } catch (error) {
                conError('Settings', 'Error al guardar configuraci√≥n del usuario:', error);
            }
        }
    };

    // ------------------------------------------
    // MARK: üìä Variables
    // ------------------------------------------

    // Variables para controlar el estado de inicializaci√≥n
    let regularPlayerInitialized = false;
    let navigationTimeout = null;
    let isNavigating = false;
    let navigationDebounceTimeout = null;
    let playerCheckInterval = null;
    let isResuming = false;

    let YTHelper = null; // YouTube Helper API, Redeclarada en waitForHelper
    let pageTypeListener = null; // Suscrito a cambios din√°micos de tipo de p√°gina
    let currentPageType = null; // Tipo de p√°gina actual

    // ------------------------------------------
    // MARK: üîß Utils
    // ------------------------------------------

    // MARK: üîß Formateo de Tiempo
    /**
    * Formatea un valor de tiempo (en segundos o string) a un string en formato "MM:SS" o "HH:MM:SS".
    *
    * @param {number|string} input - Valor de tiempo a formatear.
    * @returns {string} - String con el tiempo formateado.
    * Ejemplos:
    * formatTime(65)         // "01:05"
    * formatTime("5:30")     // "05:30"
    * formatTime("1:05:30")  // "01:05:30"
    * formatTime("invalid")  // "00:00"
    */
    const formatTime = (input) => {
        let seconds;

        // Si es un n√∫mero, lo usa directamente
        if (typeof input === 'number' && !isNaN(input)) {
            seconds = input;
        }
        // Si es un string, intenta convertirlo
        else if (typeof input === 'string') {
            // Maneja formatos como "5:30" o "05:30"
            if (input.includes(':')) {
                const parts = input.split(':').map(part => parseInt(part, 10));

                // Si es MM:SS
                if (parts.length === 2) {
                    seconds = parts[0] * 60 + parts[1];
                }
                // Si es HH:MM:SS
                else if (parts.length === 3) {
                    seconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
                } else {
                    conError('Formato de tiempo no v√°lido:', input);
                    return '00:00';
                }
            }
            // Intenta convertir directamente a n√∫mero
            else {
                seconds = parseFloat(input);
            }
        }
        // Caso por defecto
        else {
            conError('Valor de entrada no v√°lido:', input);
            return '00:00';
        }

        // Validaci√≥n final
        if (typeof seconds !== 'number' || isNaN(seconds) || seconds < 0) {
            conError('Valor de segundos no v√°lido:', input);
            return '00:00';
        }

        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);

        return hours > 0
            ? `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
            : `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };

    /**
    * Parsea un string de tiempo en formato "MM:SS" o "HH:MM:SS" a segundos.
    *
    * @param {string} timeStr - String con el tiempo en formato "MM:SS" o "HH:MM:SS".
    * @returns {number} N√∫mero de segundos correspondiente al string. Retorna 0 si el formato es inv√°lido.
    *
    * @example
    * // Formato MM:SS ‚Üí minutos y segundos
    * parseTimeToSeconds("5:30");      // ‚Üí 330
    *
    * @example
    * // Formato HH:MM:SS ‚Üí horas, minutos y segundos
    * parseTimeToSeconds("1:05:30");   // ‚Üí 3930
    *
    * @example
    * // Formato inv√°lido ‚Üí 0
    * parseTimeToSeconds("invalid");   // ‚Üí 0
    *
    * @example
    * // Cadena vac√≠a o no string ‚Üí 0
    * parseTimeToSeconds("");          // ‚Üí 0
    * parseTimeToSeconds(null);        // ‚Üí 0
    */
    const parseTimeToSeconds = (timeStr) => {
        if (typeof timeStr !== 'string' || !timeStr.includes(':')) return 0;

        const parts = timeStr.split(':').map(Number);

        // Retorna 0 si alg√∫n valor es NaN
        if (parts.some(isNaN)) return 0;

        if (parts.length === 2) return parts[0] * 60 + parts[1];
        if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];

        return 0;
    };

    /**
    * Normaliza un valor de tiempo a segundos.
    *
    * @param {number|string} value - Valor de tiempo a normalizar.
    *                              Puede ser un n√∫mero (ya en segundos)
    *                              o una cadena en formato "SS", "MM:SS" o "HH:MM:SS".
    * @returns {number} N√∫mero de segundos (0 si el valor es inv√°lido o no existe).
    *
    * @example
    * // N√∫mero directo ‚Üí devuelve el mismo n√∫mero
    * normalizeSeconds(65);        // ‚Üí 65
    *
    * @example
    * // "MM:SS" ‚Üí minutos y segundos
    * normalizeSeconds("5:30");    // ‚Üí 330
    *
    * @example
    * // "HH:MM:SS" ‚Üí horas, minutos y segundos
    * normalizeSeconds("1:05:30"); // ‚Üí 3930
    *
    * @example
    * // Sin argumento o null ‚Üí 0
    * normalizeSeconds();          // ‚Üí 0
    * normalizeSeconds(null);      // ‚Üí 0
    *
    * @example
    * // Valor inv√°lido ‚Üí 0
    * normalizeSeconds("invalid"); // ‚Üí 0
    */
    const normalizeSeconds = (value) => {
        if (!value) return 0;
        if (typeof value === 'number') return value;
        if (typeof value === 'string') return parseTimeToSeconds(value.trim());
        return 0;
    };

    // MARK: üîß SetInnerHTML
    /**
    * Asigna HTML de forma segura para compatibilidad con Trusted Types (Chrome)
    *
    * @param {HTMLElement} element - Elemento HTML al que se le asignar√° el HTML.
    * @param {string} html - HTML a asignar en su innerHTML.
    */
    function setInnerHTML(element, html) {
        if (window.trustedTypes && window.trustedTypes.createPolicy) {
            try {
                const policy = window.trustedTypes.createPolicy('youtube-playback-plox', {
                    createHTML: (string) => string
                });
                element.innerHTML = policy.createHTML(html);
            } catch (e) {
                // Si la creaci√≥n de la pol√≠tica falla, usar innerHTML directamente
                element.innerHTML = html;
            }
        } else {
            // Si TrustedHTML no est√° soportado, usar innerHTML
            element.innerHTML = html;
        }
    }

    // MARK: üîß Crear Elemento
    /**
    * Crea un elemento HTML con varias opciones de configuraci√≥n.
    * 
    * @param {string} tag - Nombre del tag HTML a crear, e.g., 'div', 'span'.
    * @param {Object} [options] - Opciones para configurar el elemento.
    * @param {string} [options.className] - Clases CSS del elemento.
    * @param {string} [options.id] - ID del elemento.
    * @param {string} [options.text] - Texto interno del elemento.
    * @param {string} [options.html] - HTML interno del elemento (usa setInnerHTML seguro).
    * @param {Function} [options.onClickEvent] - Funci√≥n legacy para el evento click.
    * @param {Object.<string, Function>} [options.events] - Eventos a a√±adir, e.g., { click: fn, mouseover: fn }.
    * @param {Object.<string, string>} [options.atribute] - Atributos HTML a a√±adir, e.g., { src: 'img.png' }.
    * @param {Object.<string, any>} [options.props] - Propiedades del elemento, e.g., { value: '123' }.
    * @param {Array<string|Node>} [options.children] - Hijos a a√±adir al elemento, strings o nodos.
    * @returns {HTMLElement} - El elemento HTML creado y configurado.
    */
    function createElement(tag, {
        className = '',
        id = '',
        text = '',
        html = '',
        onClickEvent = null,
        events = {},
        atribute = {},
        props = {},
        children = []
    } = {}) {
        const el = document.createElement(tag);

        if (className) el.className = className;
        if (id) el.id = id;
        if (text) el.textContent = text;
        if (html) setInnerHTML(el, html);

        // Soporte legacy (funci√≥n onClickEvent)
        if (onClickEvent && typeof onClickEvent === 'function') {
            el.addEventListener('click', onClickEvent);
        }

        // Soporte para m√∫ltiples eventos
        if (events && typeof events === 'object') {
            Object.entries(events).forEach(([event, handler]) => {
                if (typeof handler === 'function') {
                    el.addEventListener(event, handler);
                }
            });
        }

        // Atributos
        if (atribute && typeof atribute === 'object') {
            Object.entries(atribute).forEach(([k, v]) => el.setAttribute(k, v));
        }

        // Propiedades directas
        if (props && typeof props === 'object') {
            Object.entries(props).forEach(([k, v]) => {
                if (k in el) el[k] = v;
            });
        }

        // A√±adir children
        if (Array.isArray(children)) {
            children.forEach(child => {
                if (typeof child === 'string') {
                    el.appendChild(document.createTextNode(child));
                } else if (child instanceof Node) {
                    el.appendChild(child);
                }
            });
        }

        return el;
    }

    // MARK: üîß Detener Verificaci√≥n
    /**
    * Detiene el intervalo de verificaci√≥n del reproductor.
    */
    const stopChecking = () => {
        log('stopChecking', 'Deteniendo intervalo de verificaci√≥n del reproductor');
        log('stopChecking', `Intervalo actual: ${playerCheckInterval}`);
        if (playerCheckInterval) {
            clearInterval(playerCheckInterval);
            playerCheckInterval = null;
            log('stopChecking', 'Intervalo detenido correctamente');
            log('stopChecking', `Intervalo final: ${playerCheckInterval}`)
        }
    };

    // MARK: üîß YouTube Helper API
    /**
    * Espera a que YouTube Helper API est√© listo.
    *
    * @param {number} retries - N√∫mero de reintentos (opcional, por defecto 0).
    * @returns {Promise} - Promesa que se resuelve cuando YouTube Helper API est√° listo.
    */
    function waitForHelper(retries = 0) {
        return new Promise((resolve, reject) => {
            const MAX_RETRIES = 10;
            const RETRY_INTERVAL = 1000;

            const helper = window.youtubeHelperApi;

            if (helper) {
                // Si ya est√° inicializado completamente
                if (helper.player?.api) return resolve(helper);

                // Si existe pero a√∫n no se inicializ√≥
                helper.eventTarget.addEventListener('yt-helper-api-ready', (e) => {
                    resolve(e.detail);
                }, { once: true });
                return;
            }

            // Si no existe todav√≠a, reintenta
            if (retries < MAX_RETRIES) {
                warn('init', `[YTHelper] No disponible, reintentando... (${retries + 1}/${MAX_RETRIES})`);
                setTimeout(() => resolve(waitForHelper(retries + 1)), RETRY_INTERVAL);
            } else {
                reject(new Error("YouTube Helper API no disponible tras varios intentos"));
            }
        });
    }

    // ------------------------------------------
    // MARK: üì∫ Helpers
    // ------------------------------------------

    // MARK: üì∫ Obtiene datos guardados de un video
    /**
    * Obtiene datos guardados de un video, intentando todas las combinaciones posibles.
    * Soporta tanto videos individuales como en playlist.
    *
    * @param {string} videoId - ID del video
    * @param {string|null} playlistId - ID de la playlist (opcional)
    * @returns {Object|null} - Datos guardados o null si no se encuentra
    */
    function getSavedVideoData(videoId, playlistId = null) {
        log('getSavedVideoData', `Buscando datos guardados para ID: ${videoId} | Playlist ID: ${playlistId}`);
        if (!videoId) return null;

        // Si hay playlistId, intenta primero dentro de la playlist
        if (playlistId) {
            const playlist = Storage.get(playlistId);
            const inPlaylist = playlist?.videos?.[videoId];
            if (inPlaylist) return inPlaylist;
        }

        // Luego busca como video independiente
        const standalone = Storage.get(videoId);
        if (standalone) return standalone;

        // B√∫squeda flexible: por si alguna vez se guard√≥ con prefijos raros o en shorts
        // (ej. "shorts-VIDEO_ID" o "watch-VIDEO_ID")
        const keys = Storage.keys?.() || [];
        const altKey = keys.find(k => k.endsWith(videoId) || k.includes(videoId));
        if (altKey) return Storage.get(altKey);

        // Nada encontrado
        return null;
    }

    // MARK: üì∫ Normaliza las claves de almacenamiento de YouTube
    /**
    * Normaliza las claves de almacenamiento de YouTube.
    */
    function normalizeYouTubeStorageKeys() {
        if (typeof Storage?.keys !== 'function') {
            conError('normalizeYouTubeStorageKeys', 'Storage.keys() no disponible.');
            return;
        }

        const allKeys = Storage.keys();
        let changes = 0;

        for (const key of allKeys) {
            const newKey = extractOrNormalizeVideoId(key)?.id;
            log('normalizeYouTubeStorageKeys', `Clave original: ${key} | Clave nueva: ${newKey}`);

            if (newKey && newKey !== key) {
                const data = Storage.get(key);
                if (!Storage.get(newKey)) {
                    Storage.set(newKey, data);
                    Storage.remove(key);
                    log('normalizeYouTubeStorageKeys', `‚úÖ Migrado: "${key}" -> "${newKey}"`);
                    changes++;
                } else {
                    log('normalizeYouTubeStorageKeys', `‚ö†Ô∏è Duplicado detectado: "${key}" ya existe como "${newKey}"`);
                }
            }
        }

        log('normalizeYouTubeStorageKeys', `üîÅ Normalizaci√≥n completa. ${changes} claves migradas.`);
    }

    // MARK: üì∫ Llama a resumePlayback con delay 
    /**
    * Llama a resumePlayback con el delay apropiado seg√∫n el tipo
    * @param {string} type - Tipo de video ('short', 'regular', 'live')
    * @param {Function} resumeFn - Funci√≥n a ejecutar
    * @param {number} shortDelay - Delay para shorts (default 200ms)
    */
    function callResumeWithDelay(type, resumeFn, shortDelay = 200) {
        if (type === 'short') {
            setTimeout(resumeFn, shortDelay);
        } else {
            resumeFn();
        }
    }


    function getYouTubePageType() {
        const path = window.location.pathname;
        if (path === '/') return 'home';
        if (path.startsWith('/shorts')) return 'shorts';
        if (path.startsWith('/watch')) return 'watch';
        if (path.startsWith('/embed')) return 'embed';
        if (path.startsWith('/playlist')) return 'playlist';
        if (path.startsWith('/results')) return 'search';
        if (path.endsWith('/UC-9-kyTW8ZkZNDHQJ6FgpwQ')) return 'music';
        if (path.startsWith('/gaming')) return 'gaming';
        if (path.endsWith('/UCYfdidRxbB8Qhf0Nx7ioOYw')) return 'news';
        if (path.endsWith('/UCEgdi0XIXXZ-qJOFPf4JSKw')) return 'sports';
        if (path.endsWith('/UCtFRv9O2AHqOZjjynzrv-xg')) return 'learning';
        if (path.endsWith('/feed/you')) return 'you';
        if (path.endsWith('/feed/history')) return 'history';
        if (path.endsWith('/feed/subscriptions')) return 'subscriptions';
        if (path.includes('/live')) return 'live'; // Para videos en vivo, raros casos o si es enlace directo como https://www.youtube.com/@NASA/live ya que Youtube usa /watch igual para lives.

        const channelPaths = [
            '/@',           // Canal personalizado (nuevo)	    /@/NombreCanal	    URL personalizada (nuevo)
            '/channel',     // Canal ID                         /channel/UCxxxx	    Identificador √∫nico interno
            '/c',           // Nombre personalizado (antiguo)	/c/NombreCanal	    URL personalizada (deprecated pero activa)
            '/user',        // Usuario cl√°sico (muy antiguo)	/user/Nombre	    Viejas cuentas de usuario pre-2014
            '/UC'           // Directo por ID (casos raros)	    /UCxxxx	            Directo por ID (casos raros)
        ];
        if (channelPaths.some(prefix => path.startsWith(prefix))) return 'channel';

        return 'unknown';
    }

    // ------------------------------------------
    // MARK: üì∫ Get Video Element
    // ------------------------------------------

    // Helper para encontrar el <video> actual
    /*  function getActiveVideoElement() {
         let video =
             // Shorts principales
             document.querySelector('ytd-reel-video-renderer #short-video-container ytd-player div.html5-video-container video') ||
             // Shorts alternativos (feed o layouts distintos)
             document.querySelector('ytd-reel-video-renderer video.reel-video-player-element, ytd-shorts video.html5-main-video') ||
             // Videos regulares y shorts
             document.querySelector('#movie_player video.html5-main-video, .html5-video-player video.html5-main-video') ||
             // Videos regulares y shorts, sin falsos positivos ya que existen dos <video> en el DOM
             document.querySelector('video:not(video-preview-container[data-no-fullscreen])') ||
             // Fallback gen√©rico, puede dar falsos positivos regresando uno inactivo
             document.querySelector('video');
         return video;
     } */




    /* async function getActiveVideoElement() {
        const selectors = [
            // Shorts principales y alternativos
            'ytd-reel-video-renderer #short-video-container ytd-player div.html5-video-container video',
            'ytd-reel-video-renderer video.reel-video-player-element',
            'ytd-shorts video.html5-main-video',
            '#shorts-player video',
            // Videos regulares
            '#movie_player video.html5-main-video',
            '.html5-video-player video.html5-main-video',
            // Videos gen√©ricos evitando previsualizaciones
            'video:not(video-preview-container[data-no-fullscreen])',
            'video'
        ];

        await new Promise(resolve => setTimeout(resolve, 100));

        const candidates = selectors.flatMap(selector => {
            const elements = Array.from(document.querySelectorAll(selector));
            log(`Selector "${selector}": ${elements.length} elementos`);
            return elements;
        });

        log(`Total de candidatos: ${candidates.length}`);

        const visibleVideos = candidates.filter(video => {
            if (!video) return false;

            const rect = video.getBoundingClientRect();
            const isVisible = rect.width > 100 && rect.height > 100;
            const hasSource = video.src || video.currentSrc;

            log(`Video: ${video.src?.substring(0, 50)}... | Visible: ${isVisible} | Tama√±o: ${rect.width}x${rect.height}`);

            return isVisible && hasSource;
        });

        log(`Videos visibles: ${visibleVideos.length}`);

        if (visibleVideos.length === 0) return null;

        // L√≥gica de selecci√≥n...
        return visibleVideos[0];
    } */

    async function getActiveVideoElement() {
        const selectors = [
            // === SHORTS ===
            'ytd-reel-video-renderer #short-video-container ytd-player div.html5-video-container video',
            'ytd-reel-video-renderer video.reel-video-player-element',
            'ytd-shorts video.html5-main-video',
            '#shorts-player video',

            // === VIDEOS REGULARES (en p√°gina de reproducci√≥n) ===
            '#movie_player video.html5-main-video',
            '.html5-video-player video.html5-main-video',

            // === MINIPLAYER FLOTANTE (Picture-in-Picture / Miniplayer) ===
            // Este es el clave para cuando el usuario vuelve al homepage o cambia a shorts desde video regular reproduciendose
            '#movie_player',
            '.ytp-miniplayer-ui video.html5-main-video',
            '#miniplayer video.html5-main-video',
            'ytd-miniplayer video',
            '.html5-video-container video', // m√°s gen√©rico, pero √∫til

            // === FALLBACKS GEN√âRICOS (evitando previews) ===
            'video:not([data-no-fullscreen])',
            'video'
        ];

        // Peque√±a espera para que el DOM se estabilice
        await new Promise(resolve => setTimeout(resolve, 100));

        const candidates = selectors.flatMap(selector => {
            const elements = Array.from(document.querySelectorAll(selector));
            log(`Selector "${selector}": ${elements.length} elementos`);
            return elements;
        });

        log(`Total de candidatos: ${candidates.length}`);

        const visibleVideos = candidates.filter(video => {
            if (!video) return false;

            const rect = video.getBoundingClientRect();
            const isVisible = rect.width > 50 && rect.height > 50; // m√°s permisivo para miniplayer
            const hasSource = video.src || video.currentSrc || video.querySelector('source');
            const isPlaying = !video.paused;
            const hasDuration = video.duration > 0;

            log(`Video: ${video.currentSrc?.substring(0, 50)}... | Visible: ${isVisible} | Tama√±o: ${rect.width}x${rect.height} | Reproduciendo: ${isPlaying}`);

            return isVisible && hasSource && hasDuration;
        });

        log(`Videos visibles y reproducibles: ${visibleVideos.length}`);

        if (visibleVideos.length === 0) return null;

        // === PRIORIZAR: Miniplayer > Reproductor principal > Shorts > Otros ===
        const miniplayer = visibleVideos.find(v =>
            v.closest('.ytp-miniplayer-ui') ||
            v.closest('#miniplayer') ||
            v.closest('ytd-miniplayer')
        );
        if (miniplayer) {
            log('Miniplayer flotante detectado y seleccionado');
            return miniplayer;
        }

        const mainPlayer = visibleVideos.find(v =>
            v.closest('#movie_player') ||
            v.closest('.html5-video-player')
        );
        if (mainPlayer) {
            log('Reproductor principal detectado');
            return mainPlayer;
        }

        const shortsPlayer = visibleVideos.find(v =>
            v.closest('ytd-reel-video-renderer') ||
            v.closest('ytd-shorts') ||
            v.closest('#shorts-player')
        );
        if (shortsPlayer) {
            log('Shorts detectado');
            return shortsPlayer;
        }

        // √öltimo recurso
        log('Usando primer video visible como fallback');
        return visibleVideos[0];
    }




    // ------------------------------------------
    // MARK: üì∫ Get Container
    // ------------------------------------------

    // Helper para encontrar el <container> actual
    function getActiveContainer() {
        return (
            // Shorts
            document.querySelector('ytd-reel-video-renderer') || // √önico en DOM
            document.querySelector('#reel-video-renderer') || // √önico en DOM (es id de item ytd-reel-video-renderer)
            document.querySelector('ytd-shorts') || // √önico en DOM
            document.querySelector('#shorts-container') || // √önico en DOM
            // Video normal
            document.querySelector('#player-container-inner #player-container #movie_player') || // √önico en DOM
            document.querySelector('#movie_player') || // √önico en DOM
            document.querySelector('.html5-video-player:not(#inline-preview-player)') || // M√°s de uno en DOM, excluye variante
            document.querySelector('video:not([data-no-fullscreen])') // M√°s de uno en DOM, excluye variante
        );
    }


    // ------------------------------------------
    // MARK: üì∫ Get Title
    // ------------------------------------------

    function getVideoTittle(player) {
        // Buscar t√≠tulo en meta tags
        const metaSelectors = [
            'meta[name="title"]',
            'meta[itemprop="name"]',
            'meta[property="og:title"]',
            'meta[name="twitter:title"]',
            'link[rel="alternate"][type="application/json+oembed"]'
        ];
        for (const sel of metaSelectors) {
            const el = document.querySelector(sel);
            const t = el?.content || el?.title;
            log('getVideoTittle', `T√≠tulo encontrado en meta tag: ${t}`);
            if (t) return t;
        }

        // Fallback a JSON incrustado
        const title = window.ytInitialPlayerResponse?.videoDetails?.title;
        log('getVideoTittle', `T√≠tulo encontrado en JSON incrustado: ${title}`);
        if (title != null) return title;

        /* 
        player.getVideoData() = {
                "video_id": "iy4mXZN1Zzk",
                "author": "robbiewilliamsvevo",
                "title": "Robbie Williams - Feel",
                "isPlayable": true,
                "errorCode": null,
                "video_quality": "medium",
                "video_quality_features": [],
                "list": "RDiy4mXZN1Zzk", // ID Playlist 
                "backgroundable": false,
                "eventId": "Q-AHae30KbiZ4dUPnbDByQk",
                "cpn": "m6WhMHqg6WQd25ET",
                "isLive": false,
                "isWindowedLive": false,
                "isManifestless": false,
                "allowLiveDvr": false,
                "isListed": true,
                "isMultiChannelAudio": false,
                "hasProgressBarBoundaries": false,
                "isPremiere": false,
                "itct": "CAAQu2kiEwitooPuxtSQAxW4TLgEHR1YMJk=",
                "playerResponseCpn": "",
                "progressBarStartPositionUtcTimeMillis": null,
                "progressBarEndPositionUtcTimeMillis": null,
                "paidContentOverlayDurationMs": 0
            }
        */

        const videoData = player.getVideoData();
        log('getVideoTittle', `T√≠tulo encontrado en player.getVideoData(): ${videoData?.title}`);
        if (videoData != null) return videoData.title;

        // Fallback al DOM
        const DOMSelectors = [
            'ytd-watch-metadata h1 yt-formatted-string',
            'h1.ytd-watch-metadata yt-formatted-string',
            '#title h1 yt-formatted-string',
            'h1 yt-formatted-string',
            '#title h1',
            'h1.title'
            //'h2 span.yt-core-attributed-string' // entrega el nombre pero si existe traducci√≥n activa devuelve esa version, No original.
        ];

        for (const sel of DOMSelectors) {
            const el = document.querySelector(sel);
            const t = el?.textContent.trim();
            log('getVideoTittle', `T√≠tulo encontrado en DOM: ${t}`);
            if (t) return t;
        }

        // Fallback al <title> del documento, limpiando "- YouTube"
        const docTitle = document.title.replace(/ - YouTube$/, '');
        log('getVideoTittle', `T√≠tulo encontrado en <title>: ${docTitle}`);
        return docTitle || t('unknown');
    }


    // ------------------------------------------
    // MARK: üì∫ Get Thumbnail
    // ------------------------------------------

    function getVideoThumbnail(vid) {
        // Desde DOM
        /* 
        <link rel="image_src" href="https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&amp;rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA">
        <meta property="og:image" content="https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&amp;rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA">
        <meta name="twitter:image" content="https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&amp;rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA">
        <link itemprop="thumbnailUrl" href="https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&amp;rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA">
        <link itemprop="url" href="https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&amp;rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA">
        */
        const selectors = [
            'link[rel="image_src"]',
            'meta[property="og:image"]',
            'meta[name="twitter:image"]',
            'link[itemprop="thumbnailUrl"]',
            'link[itemprop="url"]'
        ];

        for (const sel of selectors) {
            const el = document.querySelector(sel);
            const url = el?.content || el?.href;
            if (url) return cleanThumbnailUrl(url);
        }

        // Desde el div de YouTube player
        /*
        <div class="ytp-cued-thumbnail-overlay-image" style="background-image: url(&quot;https://i.ytimg.com/vi_webp/${vid}/maxresdefault.webp&quot;);"></div>
        */
        const thumbDiv = document.querySelector('.ytp-cued-thumbnail-overlay-image');
        if (thumbDiv) {
            const style = thumbDiv.style.backgroundImage;
            const match = style.match(/url\((['"]?)(.*?)\1\)/);
            if (match) return match[2];
        }

        // Desde JSON incrustado
        /* 
        "microformat":{"playerMicroformatRenderer":{"thumbnail":{"thumbnails":[{"url":"https://i.ytimg.com/vi/${vid}/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=\u0026rs=AOn4CLBug6b83Q3GnLn_dzMjPVf_3phVNA","width":405,"height":720}],
        */
        try {

            const url = window.ytInitialPlayerResponse?.microformat?.playerMicroformatRenderer?.thumbnail?.thumbnails?.[0]?.url;

            if (url != null && vid && url?.includes(vid)) {
                return cleanThumbnailUrl(url);
            }
        } catch (err) {
            warn('Error al obtener thumbnail desde JSON:', err);
        }

        // Fallback final
        return `https://i.ytimg.com/vi/${vid}/maxresdefault.jpg`;
    }

    // Limpia par√°metros innecesarios de la URL
    function cleanThumbnailUrl(url) {
        const match = url.match(/^(https:\/\/i\.ytimg\.com\/vi\/[A-Za-z0-9_-]+\/[^?]+)/);
        return match ? match[1] : url;
    }

    // ------------------------------------------
    // MARK: üì∫ Get Video Info
    // ------------------------------------------

    // Cache por video
    const viewCountCache = new Map();

    async function getVideoInfo(player, videoId) {
        const now = Date.now();

        // T√≠tulo y autor por defecto
        let title = getVideoTittle(player);
        let author =
            // Short y videos regulares
            player.getVideoData?.()?.author ||
            document.querySelector('link[itemprop="name"]')?.getAttribute('content') ||
            // Solo videos regulares
            document.querySelector('yt-button-shape#subscribe-button-shape button.yt-spec-button-shape-next')?.getAttribute('aria-label')?.replace(/^Subscribe to /, '').replace(/\.$/, '').trim() ||
            document.querySelector('ytd-subscription-notification-toggle-button-renderer-next button.yt-spec-button-shape-next')?.getAttribute('aria-label')?.match(/for (.+)$/)?.[1]?.trim() ||
            t('unknown');

        // Thumbnail por defecto
        let thumb = getVideoThumbnail(videoId);

        // Views
        let viewsNumber;
        const videoDetailsViews = window.ytInitialPlayerResponse?.videoDetails?.viewCount;
        if (videoDetailsViews != null) {
            viewsNumber = Number(videoDetailsViews).toLocaleString();
        } else {
            viewsNumber =
                document.querySelector('.view-count')?.textContent?.match(/[\d.,\s]+/)?.[0].trim() ||
                document.querySelector('view-count-factoid-renderer .ytwFactoidRendererFactoid[role="text"]')?.getAttribute('aria-label')?.match(/[\d.,\s]+/)?.[0].trim() ||
                document.querySelector('ytd-watch-info-text div#tooltip.tp-yt-paper-tooltip')?.textContent?.match(/[\d.,\s]+/)?.[0].trim() ||
                document.querySelector('yt-formatted-string.view-count')?.textContent?.match(/[\d.,\s]+/)?.[0].trim() ||
                t('notAvailable');
        }
        let viewsMsg = `${viewsNumber} ${t('views')}`;


        // Primero intenta obtener la duraci√≥n desde el API del reproductor
        let duration =
            player?.getDuration?.() ?? // 275.421
            document.querySelector('#movie_player')?.getDuration?.() ?? // 275.421
            player?.playerObject?.getDuration?.(); // 275.421
        /* document.querySelector('.ytp-time-duration').textContent || */ // "4:35" -> parseTimeToSeconds -> 275.421 PERO puede perder decimales "3:55" -> parseTimeToSeconds -> 235 cuando debiesen haber sido (en este ejemplo) 235.741
        // document.querySelector('meta[itemprop="duration"]')?.content ||  // "PT4M35S"

        // Si todav√≠a no se obtuvo, probar con el <video> real
        if (!duration || isNaN(duration) || duration === 0) {
            const videoEl = await getActiveVideoElement();
            log('üïï duration getActiveVideoElement', videoEl)
            if (videoEl) {
                // Esperar a que el <video> cargue los metadatos si a√∫n no lo ha hecho
                if (isNaN(videoEl.duration) || videoEl.duration === 0) {
                    await new Promise(resolve => {
                        videoEl.addEventListener('loadedmetadata', resolve, { once: true });
                    });
                }
                log('üïï duration videoEl.duration', videoEl.duration)
                duration = videoEl.duration;
            }
        }

        log('üïï duration player.getDuration', player?.getDuration?.())
        log('üïï duration document.querySelector(#movie_player)?.getDuration?.()', document.querySelector('#movie_player')?.getDuration?.())
        log('üïï duration player.playerObject.getDuration', player?.playerObject?.getDuration?.())

        duration = normalizeSeconds(duration);
        log('üïï duration tras normalizeSeconds =', duration)


        // Autor ID (Channel ID)
        let authorId;
        const videoDetailsChannelID = window.ytInitialPlayerResponse?.videoDetails?.channelId;
        if (videoDetailsChannelID != null) {
            authorId = videoDetailsChannelID;
        } else {
            authorId =
                // Videos regulares
                document.querySelector('#upload-info a.yt-simple-endpoint')?.href?.split('/channel/')[1] ||
                document.querySelector('a.ytp-ce-channel-title.ytp-ce-link')?.href?.split('/channel/')[1] ||
                document.querySelector('#items yt-button-shape a')?.href?.split('/channel/')[1]?.split('/')[0] ||
                document.querySelector('#infocard-channel-button yt-button-shape a')?.href?.split('/channel/')[1]?.split('/')[0] ||
                // Shorts
                document.querySelector('link[rel="canonical"]')?.href?.split('/channel/')[1] || // <link rel="canonical" href="https://www.youtube.com/channel/UCxxxx">
                document.querySelector('meta[property="og:url"]')?.content?.split('/channel/')[1] || // <meta property="og:url" content="https://www.youtube.com/channel/UCxxxx">
                document.querySelector('link[itemprop="url"]')?.href?.split('/channel/')[1] || // <link itemprop="url" href="https://www.youtube.com/channel/UCxxxx">
                t('unknown');
        }

        // Cach√© de views
        const cached = viewCountCache.get(videoId);
        if (!cached || (now - cached.time) > 5000) {
            viewCountCache.set(videoId, { views: viewsNumber, time: now });
        } else {
            viewsNumber = cached.views;
            viewsMsg = `${viewsNumber} ${t('views')}`;
        }

        log('getVideoInfo', 'Info Obtenida:', { title, author, thumb, viewsNumber, savedAt: now, duration, authorId, videoId })
        return { title, author, thumb, viewsNumber, savedAt: now, duration, authorId, videoId };
    }

    // ------------------------------------------
    // MARK: üì∫ Extraer Video ID
    // ------------------------------------------

    /**
    * Extrae o normaliza un video ID de YouTube desde URL, embed o ID directo.
    * Soporta:
    *  - URLs normales: watch?v=ID
    *  - Shorts: /shorts/ID
    *  - Short URLs: youtu.be/ID
    *  - Embeds: /embed/ID
    *  - IDs directos
    * @param {string} input - URL completa o ID de video.
    * @returns {string|null} - Video ID o null si no se pudo determinar.
    */
    function extractOrNormalizeVideoId(input) {
        if (!input || typeof input !== 'string') return null;
        const trimmed = input.trim();

        // Si es solo un ID directo (no URL)
        if (/^[A-Za-z0-9_-]{6,}$/.test(trimmed)) {
            return { type: "video", id: trimmed };
        }

        try {
            const url = new URL(trimmed);

            // --- LISTAS ---
            const listParam = url.searchParams.get("list");
            if (url.pathname.includes("/playlist") && listParam) {
                return { type: "playlist", id: listParam };
            }

            // --- VIDEOS ---
            // 1Ô∏è‚É£ watch?v=ID
            const vParam = url.searchParams.get("v");
            if (vParam) {
                const result = { type: "video", id: vParam };
                if (listParam) result.list = listParam; // video dentro de lista
                return result;
            }

            // 2Ô∏è‚É£ shorts/ID
            const shortsMatch = url.pathname.match(/\/shorts\/([A-Za-z0-9_-]{6,})/);
            if (shortsMatch) return { type: "video", id: shortsMatch[1] };

            // 3Ô∏è‚É£ embed/ID
            const embedMatch = url.pathname.match(/\/embed\/([A-Za-z0-9_-]{6,})/);
            if (embedMatch) return { type: "video", id: embedMatch[1] };

            // 4Ô∏è‚É£ short URL (youtu.be/ID)
            if (url.hostname.includes("youtu.be")) {
                const shortId = url.pathname.slice(1);
                if (/^[A-Za-z0-9_-]{6,}$/.test(shortId)) {
                    const result = { type: "video", id: shortId };
                    if (listParam) result.list = listParam;
                    return result;
                }
            }
        } catch {
            // Si no es URL v√°lida, continuar
        }

        // Si todo falla
        warn("extractOrNormalizeVideoId: no se pudo determinar video_id para", input);
        return null;
    }

    // ------------------------------------------
    // MARK: Actualizar Estado
    // ------------------------------------------

    const updateStatus = (player, videoEl, type, plId) => {
        // Obtener el ID desde URL
        let url = getYouTubePageType() === 'home' && getActiveVideoElement() !== null ? lastUrl : location.href;

        let video_id = extractOrNormalizeVideoId(url)?.id;
        log('updateStatus', `URL del reproductor: ${url} | Video ID Extraido: ${video_id}`)

        if (!video_id) {
            conError('updateStatus', 'No se pudo determinar video_id. Abortando guardado.');
            return;
        }

        const currentTime = videoEl.currentTime;







        getVideoInfo(player, video_id).then(({ duration }) => {
            log('updateStatus', `then duration: ${duration} = ${formatTime(duration)} | current time: ${currentTime} | video_id: ${video_id}`);
            if (!duration || isNaN(currentTime) || currentTime < 1 || !isFinite(duration)) return;

            // aaaaaaaaaaaaaaaaaaaaaa
            // Evitar guardar progreso durante anuncios
            log('updateStatus', 'isAdPlaying player.isPlayingAds', player.isPlayingAds) // este detecta
            log('updateStatus', 'isAdPlaying', isAdPlaying)
            if (!videoEl._cachedPlayerEl) {
                videoEl._cachedPlayerEl = videoEl.closest('#movie_player, .html5-video-player');
            }
            const playerEl = videoEl._cachedPlayerEl;
            const adNow =
                player.isPlayingAds ||

                (playerEl &&
                    !!playerEl.querySelector(
                        '.ytp-ad-player-overlay, .ytp-ad-text, .ytp-ad-image-overlay, .ytp-ad-skip-button-container, .ytp-ad-overlay-container'
                    ));
            log('updateStatus', 'isAdPlaying adNow', adNow)
            if (adNow) return;
            if (isResuming) return;

            const now = Date.now();
            const finishThreshold = Math.min(duration * 0.01, CONFIG.staticFinishSec);
            const isFinished = duration - currentTime < finishThreshold;

            // Buscar progreso previo
            const sourceData = getSavedVideoData(video_id, plId);
            log('updateStatus', `Datos guardados encontrados para ${video_id}:`, sourceData);

            if (sourceData && sourceData.forceResumeTime > 0) {
                if (isFinished) {
                    log('updateStatus', `Video con tiempo fijo ${video_id} completado. Manteniendo tiempo fijo.`);
                    const base = {
                        ...sourceData,
                        isCompleted: true,
                        lastUpdated: now,
                        timestamp: 0,
                    };
                    if (plId) {
                        const playlist = Storage.get(plId);
                        if (playlist?.videos?.[video_id]) {
                            playlist.videos[video_id] = base;
                            Storage.set(plId, playlist);
                        }
                    } else {
                        Storage.set(video_id, base);
                    }
                }
                // No sobreescribir progreso en videos con tiempo fijo
                return;
            }

            // Guardar progreso normal
            const info = getVideoInfo(player, video_id);
            const singleData = {
                timestamp: currentTime,
                lastUpdated: now,
                videoType: type,
                isCompleted: isFinished,
                ...info,
            };

            if (plId) {
                const playlist = Storage.get(plId) || { lastWatchedVideoId: '', videos: {}, title: '' };
                playlist.videos[video_id] = singleData;
                playlist.lastWatchedVideoId = video_id;
                Storage.set(plId, playlist);

                if (!playlist.title) {
                    getPlaylistName(plId).then(name => {
                        const updated = Storage.get(plId);
                        if (updated && !updated.title) {
                            updated.title = name;
                            Storage.set(plId, updated);
                        }
                    });
                }
            } else {
                Storage.set(video_id, singleData);
                log('updateStatus', `Datos guardados para ${video_id}:`, singleData);
            }

            notifySeekOrProgress(currentTime, 'progress');

        });


    };

    // MARK: üì∫ Reanudar reproducci√≥n
    const resumePlayback = async (player, vid, videoEl, savedData, type) => {
        vid = extractOrNormalizeVideoId(vid)?.id;
        if (!savedData || !vid) {
            log('resumePlayback', '‚ö†Ô∏è No se encontr√≥ informaci√≥n para reanudar o video_id inv√°lido.');
            return;
        }

        log('resumePlayback', `üé¨ Reanudando video con player ${player}`);

        const lastTime = savedData.timestamp;
        const forceTime = savedData.forceResumeTime;
        const timeToSeek = forceTime > 0 ? forceTime : lastTime;

        log('resumePlayback', `üé¨ Reanudando video ${vid} en ${timeToSeek}s = ${(timeToSeek / 60).toFixed(2)} minutos`);

        if (!timeToSeek || timeToSeek <= 1) {
            log('resumePlayback', '‚è© No hay tiempo v√°lido para reanudar');
            return;
        }

        const waitForPlayer = () => {
            if (player?.getDuration?.() > 0) {
                applySeek(player, videoEl, timeToSeek, {
                    bypassMinDiff: true,
                    isForced: forceTime > 0,
                    type,
                });
            } else {
                setTimeout(waitForPlayer, 150);
            }
        };
        waitForPlayer();
    };





    // ------------------------------------------
    // MARK: üì¢ Time Display
    // ------------------------------------------

    let timeDisplay;

    // Inicializa la visualizaci√≥n de tiempo en la barra de reproducci√≥n
    function initTimeDisplay() {
        const timeContainer = document.querySelector('.ytp-time-contents');
        log('initTimeDisplay', 'timeContainer encontrado:', timeContainer);
        if (!timeContainer || timeDisplay) return;

        timeDisplay = document.createElement('span');
        Object.assign(timeDisplay.style, {
            display: 'inline-block',
            marginLeft: '10px',
            color: '#0f9d58',
            fontWeight: 'bold'
        });
        timeContainer.appendChild(timeDisplay);

        log('initTimeDisplay', 'Creada visualizaci√≥n de tiempo en la barra de reproducci√≥n');
    }

    /**
    * Actualiza el mensaje en la barra de reproducci√≥n
    * @param {string} message - Mensaje a mostrar en la barra de reproducci√≥n
    */
    function updatePlaybackBarMessage(message) {
        if (!timeDisplay) initTimeDisplay();
        timeDisplay.textContent = message;
    }

    /**
     * Limpia el mensaje de la barra de reproducci√≥n
     */
    function clearPlaybackBarMessage() {
        if (timeDisplay) {
            timeDisplay.textContent = '';
            log('clearPlaybackBarMessage', 'Mensaje de la barra limpiado');
        }
    }

    // ------------------------------------------
    // MARK: üçû Toasts
    // ------------------------------------------

    const toastTimeouts = new WeakMap();

    let toastListenersAdded = false;

    function createToastContainer() {
        let container = document.querySelector('.ypp-toast-container');
        if (!container) {
            container = createElement('div', { className: 'ypp-toast-container' });
            document.body.appendChild(container);
            log('createToastContainer', 'Contenedor de toasts creado');
        }

        if (!toastListenersAdded) {
            const updateVisibility = () => {
                container.style.display = document.fullscreenElement ? 'none' : 'flex';
            };
            document.addEventListener('fullscreenchange', updateVisibility);
            window.addEventListener('yt-navigate-finish', updateVisibility);
            updateVisibility();
            toastListenersAdded = true;
        }

        return container;
    }

    /**
    * Desvanece y elimina un toast despu√©s de un tiempo.
    * @param {HTMLElement} toast - Elemento toast a eliminar.
    * @param {number} duration - Tiempo en ms antes de iniciar el fade out.
    */
    function fadeAndRemoveToast(toast, duration) {
        // Limpiar timeout previo si existe
        if (toastTimeouts.has(toast)) {
            clearTimeout(toastTimeouts.get(toast));
            toastTimeouts.delete(toast);
        }

        const timeoutId = setTimeout(() => {
            toast.style.opacity = '0';

            const onTransitionEnd = () => {
                toast.remove();
                toast.removeEventListener('transitionend', onTransitionEnd);
            };

            toast.addEventListener('transitionend', onTransitionEnd);
            toastTimeouts.delete(toast);
        }, duration);

        toastTimeouts.set(toast, timeoutId);
    }

    /**
    * Muestra un toast flotante.
    * @param {string} message - Texto del toast.
    * @param {number} [duration=2500] - Duraci√≥n en ms del toast temporal.
    * @param {Object} [options={}] - Opciones:
    *   - persistent: boolean (reutiliza un toast √∫nico)
    *   - keep: boolean (no se auto elimina)
    *   - action: { label: string, callback: function }
    */
    function showFloatingToast(message, duration = 2500, options = {}) {
        const container = createToastContainer();
        let toast;

        if (options.persistent) {
            toast = container.querySelector('.ypp-toast.persistent');
            if (!toast) {
                toast = createElement('div', { className: 'ypp-toast persistent' });
                container.appendChild(toast);
            }
            // Resetear contenido y estilo
            setInnerHTML(toast, '');
            toast.style.opacity = '1';
        } else {
            toast = createElement('div', { className: 'ypp-toast' });
            if (options.action) toast.classList.add('has-action');
            container.appendChild(toast);
            // Inicializar opacity 0 antes de animar
            toast.style.opacity = '0';
            requestAnimationFrame(() => (toast.style.opacity = '1'));
        }

        // Contenido
        const messageSpan = createElement('span', { text: message });
        toast.appendChild(messageSpan);

        if (options.action) {
            const actionBtn = createElement('button', {
                className: 'ypp-toast-action',
                text: options.action.label,
                onClickEvent: () => {
                    if (typeof options.action.callback === 'function') {
                        options.action.callback();
                    }
                    fadeAndRemoveToast(toast, 0);
                },
                atribute: { 'aria-label': options.action.label, type: 'button' }
            });
            toast.appendChild(actionBtn);
        }

        if (!options.keep && !options.persistent) fadeAndRemoveToast(toast, duration);

        log('showFloatingToast', 'Toast mostrado', { message, options });
    }

    // ------------------------------------------
    // MARK: üõ† Create Modal
    // ------------------------------------------

    function createModal(title = '', content = '') {
        const closeModal = () => {
            overlay.remove();
            document.body.style.overflow = '';
        };
        const overlay = createElement('div', {
            className: 'ypp-modalOverlay',
            atribute: { 'aria-modal': 'true', role: 'dialog' },
            onClickEvent: (e) => {
                if (e.target === overlay) closeModal();
            }
        });
        const modal = createElement('div', { className: 'ypp-modalBox' });
        const header = createElement('div', { className: 'ypp-modalHeader' });
        const titleEl = createElement('h3', { className: 'ypp-modalTitle', text: title });
        const closeBtn = createElement('button', {
            className: 'ypp-btn',
            text: '‚úñ',
            atribute: { 'aria-label': t('close'), title: t('close'), type: 'button' },
            onClickEvent: closeModal
        });
        header.appendChild(titleEl);
        header.appendChild(closeBtn);
        const body = createElement('div', { className: 'ypp-modalBody' });
        if (typeof content === 'string') {
            setInnerHTML(body, content.replace(/\u200B/g, ''));
        } else {
            body.appendChild(content);
        }
        modal.appendChild(header);
        modal.appendChild(body);
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        document.body.style.overflow = 'hidden';
        return { host: overlay, content: modal, close: closeModal };
    }

    // ------------------------------------------
    // MARK: üì¢ Notify Seek or Progress
    // ------------------------------------------

    let cachedSettings = null;

    /**
    * Notifica al usuario sobre el progreso guardado o la posici√≥n de seek (reanudaci√≥n)
    * @param {number} time - Tiempo en segundos
    * @param {string} context - 'seek' o 'progress'
    * @param {object} options - Opciones adicionales
    *      @param {boolean} options.isForced - Indica si el seek fue forzado
    */
    function notifySeekOrProgress(time, context = 'progress', options = {}) {
        log('notifySeekOrProgress', 'Llamado con:', { time, context, options });
        if (!cachedSettings) {
            Settings.get().then((settings) => {
                cachedSettings = settings;
            })
                .catch((error) => {
                    conError('notifySeekOrProgress', 'Error al cargar configuraci√≥n para notificaciones (usaran defaults):', error);
                    cachedSettings = CONFIG.defaultSettings;
                });
            log('notifySeekOrProgress', 'Cargando configuraci√≥n para notificaciones...');
            return;
        }

        if (cachedSettings.showNotifications === false || cachedSettings.alertStyle === 'hidden') {
            log('notifySeekOrProgress', 'Notificaciones deshabilitadas o estilo oculto, no se muestra mensaje');
            return;
        }

        // Bloquear notificaci√≥n de progreso si hay tiempo fijo
        if (context === 'progress') {
            const videoId = /* player.getVideoData()?.video_id ||*/ extractOrNormalizeVideoId(location.href)?.id;
            log('notifySeekOrProgress', 'Video ID:', videoId)
            if (videoId) {
                const videoData = getSavedVideoData(videoId);
                if (videoData?.forceResumeTime > 0) {
                    log('notifySeekOrProgress', 'Video con tiempo fijo, omitiendo notificaci√≥n de progreso.');
                    return;
                }
            }
        }

        const { isForced = false/* , videoType = 'normal' */ } = options;
        const timeStr = formatTime(normalizeSeconds((time)));

        let icon = '';
        let text = '';

        // Preparar los textos seg√∫n el contexto
        if (context === 'seek') {
            icon = isForced ? '‚è±Ô∏èüìå ' : '‚èØ';
            text = `${t(isForced ? 'alwaysStartFrom' : 'resumedAt')}: ${timeStr}`;
        } else {
            icon = 'üíæ';
            text = `${t('progressSaved')}: ${timeStr}`;
        }

        // Aplicar estilo seg√∫n alertStyle
        let message = '';
        switch (cachedSettings.alertStyle) {
            case 'iconOnly':
                message = `${icon} ${timeStr}`;
                break;
            case 'textOnly':
                message = text;
                break;
            case 'iconText':
            default:
                message = `${icon} ${text}`;
                break;
        }

        // Mostrar en toast o en barra de reproducci√≥n
        log('notifySeekOrProgress', 'Mostrando notificaci√≥n en tipo de p√°gina:', currentPageType);
        if (currentPageType === 'short') {
            showFloatingToast(message, 2500, { persistent: true, keep: true });
        } else if (currentPageType === 'watch' || currentPageType === 'embed') {
            updatePlaybackBarMessage(message);
        } else {
            warn('notifySeekOrProgress', 'Tipo de p√°gina no soportado:', currentPageType);
        }
    }

    // ------------------------------------------
    // MARK: üîß Playlist Name Cache
    // ------------------------------------------

    const playlistNameCache = new Map();

    async function getPlaylistName(playlistId) {
        if (playlistNameCache.has(playlistId)) {
            return playlistNameCache.get(playlistId);
        }

        const url = new URL(location.href);
        const currentPlaylistId = url.searchParams.get('list');

        if (currentPlaylistId === playlistId) {
            const playlistTitleElement = document.querySelector(
                'ytd-playlist-panel-renderer #title span#text, ' +
                '#header .ytd-playlist-header-renderer h1 yt-formatted-string, ' +
                'ytd-browse[page-subtype="playlist"] ytd-playlist-header-renderer #title'
            );

            if (playlistTitleElement && playlistTitleElement.textContent) {
                const name = playlistTitleElement.textContent.trim();
                if (name) {
                    playlistNameCache.set(playlistId, name);
                    return name;
                }
            }
        }
        return new Promise((resolve) => {
            GM_xmlhttpRequest({
                method: 'GET',
                url: `https://www.youtube.com/oembed?url=https://www.youtube.com/playlist?list=${playlistId}&format=json`,
                onload: function (response) {
                    try {
                        const data = JSON.parse(response.responseText);
                        const name = data.title || playlistId;
                        playlistNameCache.set(playlistId, name);
                        resolve(name);
                    } catch (e) {
                        conError('youtube.com/oembed', 'Error parsing playlist info:', e);
                        playlistNameCache.set(playlistId, playlistId);
                        resolve(playlistId);
                    }
                },
                onerror: function () {
                    conError('youtube.com/oembed', 'Error fetching playlist info');
                    playlistNameCache.set(playlistId, playlistId);
                    resolve(playlistId);
                }
            });
        });
    }





    // ------------------------------------------
    // MARK: ‚ñ∂ Process Video
    // ------------------------------------------

    let isPlayerSeeking = false; // Para mensaje persistente
    let currentVideoEl = null;
    let lastPlaylistId = null;
    let lastUrl = ''; // Rastrear la √∫ltima URL procesada
    let lastSaveTime = 0; // Para controlar la frecuencia de guardado
    let lastResumeId = null;
    let currentlyProcessingVideoId = null;
    let currentTimeUpdateHandler = null; // Referencia al manejador actual para limpieza correcta


    const processVideo = async (playerToProcess, videoEl) => {
        log('processVideo', `Llegando a processVideo con player: ${typeof playerToProcess} | ¬øpermite getDuration?: ${playerToProcess.getDuration?.() !== "no, no es una funci√≥n"}`);
        log('processVideo', `Llegando a processVideo con videoEl: ${videoEl.tagName} | src: ${videoEl.src} | attributes: ${Array.from(videoEl.attributes).map(attr => attr.name)}`);
        log('processVideo', `isNavigating: ${isNavigating}`);
        log('processVideo', `isResuming: ${isResuming}`);

        if (isNavigating && getActiveVideoElement() === null) {
            log('processVideo', `isNavigating: ${isNavigating}`);
            log('processVideo', `getActiveVideoElement(): ${getActiveVideoElement()}`);
            log('processVideo', 'Navegaci√≥n en curso y no se encontr√≥ elemento de video, omitiendo procesamiento de video.');
            return;
        }

        let player = playerToProcess;

        // Asegurar que los elementos existen
        if (!player || !videoEl) {
            // Intentar obtenerlos autom√°ticamente si no se proporcionaron
            videoEl = getActiveVideoElement();
            player = /* player || */ window.ytplayer || window.yt || {};
            log('processVideo', `player no proporcionado: ${player} | videoEl no proporcionado: ${videoEl}`);
            log('processVideo', `player no proporcionado window.ytplayer: ${window.ytplayer}`);
            log('processVideo', `player no proporcionado window.yt: ${window.yt}`);

            if (!videoEl) {
                warn('processVideo', 'No se encontr√≥ videoEl. Abortando.');
                return;
            }
        }

        let videoData = extractOrNormalizeVideoId(window.location.href);
        let videoIdDetected = videoData?.id;


        if (getYouTubePageType() === 'home' && getActiveVideoElement() !== null) {
            videoData = extractOrNormalizeVideoId(lastUrl);
            log('processVideo', `URL del reproductor pasado: ${lastUrl}`);
            log('processVideo', `Video ID del reproductor normalizado: ${videoData}`);
            videoIdDetected = videoData?.id;
        }


        let plId = videoData?.list;

        log('processVideo', `URL del reproductor: ${window.location.href} | Video ID del reproductor: ${videoIdDetected}`);

        if (!videoIdDetected) {
            conError('processVideo', 'üö® No se pudo determinar el video_id del reproductor ni de la URL.');
            return;
        }

        // Evitar reprocesar el mismo video
        if (currentlyProcessingVideoId === videoIdDetected) {
            log('processVideo', `El video ${videoIdDetected} ya est√° siendo procesado. Ignorando.`);
            return;
        }
        currentlyProcessingVideoId = videoIdDetected;

        try {
            // Detecci√≥n del tipo de video
            const type = getYouTubePageType()/* isShort ? 'short' : (player.getDuration?.() || 0) === 0 ? 'live' : 'regular' */;
            log('processVideo', `üéá Tipo de video detectado: ${type}`);

            // Verificar si el tipo de video actual est√° deshabilitado en la configuraci√≥n
            const typeToSetting = {
                watch: 'saveRegularVideos',
                shorts: 'saveShorts',
                live: 'saveLiveStreams'
            };

            // Si el tipo de video actual est√° deshabilitado en la configuraci√≥n, sale de la funci√≥n
            if (!cachedSettings[typeToSetting[type]] && !(getYouTubePageType() === 'home' && getActiveVideoElement() !== null)) {
                // Loguea un mensaje indicando que este tipo de video no se debe procesar
                log('processVideo', `üõë Tipo "${type}" no est√° habilitado para guardado, omitiendo.`);
                log('processVideo', `Es home con un video activo? ${!(getYouTubePageType() === 'home' && getActiveVideoElement() !== null)}`);

                // Sale de la funci√≥n, evitando que el video se procese
                return;
            }

            // Buscar progreso previo
            let savedData = getSavedVideoData(videoIdDetected, plId);
            if (!savedData && plId) savedData = getSavedVideoData(videoIdDetected, null);
            log('processVideo', `Datos guardados:`, savedData);

            // L√≥gica de reanudaci√≥n
            if (savedData && videoIdDetected !== lastResumeId) {
                const shouldResume =
                    savedData.forceResumeTime > 0 ||
                    (savedData.timestamp > 10 && !savedData.isCompleted);

                if (shouldResume) {
                    isResuming = true;
                    log('processVideo', `Reanudando ${videoIdDetected} (${type})...`);
                    callResumeWithDelay(type, () => {
                        resumePlayback(player, videoIdDetected, videoEl, savedData, Boolean(plId), plId, lastPlaylistId, type);
                    });
                    lastResumeId = videoIdDetected;
                } else {
                    isResuming = false;
                }
            }

            // Handler para guardar progreso
            const handler = () => {
                try {
                    if (isNavigating) return;

                    // Validar que a√∫n exista un video v√°lido
                    if (!videoIdDetected) {
                        conError('handler', 'No se encontr√≥ videoIdDetected al intentar guardar progreso.');
                        return;
                    }

                    const currentVid = videoIdDetected;
                    log('handler de processVideo', `llego este player: ${player} | JSON.stringify(player): ${JSON.stringify(player)}`);



                    // Verificar si cambi√≥ de video durante la ejecuci√≥n
                    if (currentVid !== videoIdDetected) {
                        warn('handler', 'El ID del video cambi√≥ durante la ejecuci√≥n. Abortando guardado.');
                        return;
                    }

                    if (isPlayerSeeking) {
                        isPlayerSeeking = false;
                        clearPlaybackBarMessage();
                    }

                    const now = Date.now();
                    const minInterval = (cachedSettings.minSecondsBetweenSaves || 1) * 1000;

                    if (now - lastSaveTime >= minInterval) {
                        log('processVideo', `üíæ Guardando progreso con updateStatus para ${videoIdDetected} (${type})...`);
                        updateStatus(player, videoEl, type, plId);
                        lastSaveTime = now;
                    }
                } catch (err) {
                    conError('handler', `Error en el handler de guardado para ${videoIdDetected}: ${err.message}`);
                }
            };

            // Antes de agregar el nuevo handler, elimina el anterior si exist√≠a
            if (currentVideoEl && currentTimeUpdateHandler) {
                try {
                    currentVideoEl.removeEventListener('timeupdate', currentTimeUpdateHandler);
                    log('processVideo', 'üßπ Handler anterior removido correctamente.');
                } catch (err) {
                    warn('processVideo', `No se pudo remover el handler anterior: ${err.message}`);
                }
            }
            // Adjuntar el nuevo handler
            currentTimeUpdateHandler = handler;
            currentVideoEl = videoEl;
            videoEl.addEventListener('timeupdate', handler);

            /*  lastUrl = window.location.href; */
            lastPlaylistId = plId;
        } catch (error) {
            conError('processVideo', `Error al procesar el video ${videoIdDetected}:`, error);
        } finally {
            setTimeout(() => (currentlyProcessingVideoId = null), 100);
        }
    };

    // Reprocesar Shorts al cambiar de video
    /*  document.addEventListener('yt-navigate-finish', () => {
         const player = window.ytplayer || window.yt || {};
         const videoEl = getActiveVideoElement();
         if (videoEl) {
             log('yt-navigate-finish', 'Evento yt-navigate-finish ‚Üí procesando nuevo video.'); // detecta cambios de shorts al hacer scroll
 
             log('yt-navigate-finish', `üü£ getduracion player: ${player.getDuration()} | videoEl: ${videoEl.getDuration()}`);
             processVideo(player, videoEl);
         }
     }); */

    // ------------------------------------------
    // MARK: ‚èØ Seek
    // ------------------------------------------

    const applySeek = async (player, videoEl, time, options = {}) => {
        const { bypassMinDiff = false, isForced = false, type = 'normal' } = options;
        const TIMEOUT_MS = 5000; // Timeout m√°ximo para el seek
        const NEAR_THRESHOLD = 0.5; // Consideramos seek completado si estamos a menos de 0.5s

        if (!player && !videoEl) {
            warn('applySeek', 'No se proporcion√≥ player ni videoEl. Abortando.');
            return;
        }

        // Normalizar tiempo
        if (typeof time !== 'number') {
            if (typeof time === 'string') time = parseTimeToSeconds(time.trim());
            else {
                warn('applySeek', 'Tiempo inv√°lido:', time);
                return;
            }
        }

        log('applySeek', `Seek hacia ${time}s | Forzado: ${isForced} | BypassMinDiff: ${bypassMinDiff} | Tipo: ${type}`);

        // Verificar si el seek es necesario
        try {
            const current = videoEl?.currentTime ?? player?.getCurrentTime?.() ?? 0;
            const diff = Math.abs(current - time);

            if (!bypassMinDiff && diff <= CONFIG.minSeekDiff) {
                log('applySeek', `Diferencia m√≠nima (${diff}s). Omitiendo seek.`);
                return;
            }
        } catch (e) {
            warn('applySeek', 'Error al obtener tiempo actual:', e);
        }

        // Ejecutar el seek
        try {
            if (player?.seekTo) {
                log('applySeek', `Usando player.seekTo(${time}, true)`);
                player.seekTo(time, true);
            } else if (videoEl) {
                log('applySeek', `Asignando videoEl.currentTime = ${time}`);
                videoEl.currentTime = time;
            }
        } catch (e) {
            conError('applySeek', 'Error al ejecutar seek:', e);
            return;
        }

        // Esperar confirmaci√≥n del seek con respaldo m√∫ltiple y timeout
        await new Promise(resolve => {
            let seekCompleted = false;

            const completeSeek = () => {
                if (!seekCompleted) {
                    seekCompleted = true;
                    log('applySeek', 'Seek completado.');
                    cleanup();
                    resolve();
                }
            };

            const cleanup = () => {
                clearInterval(checkInterval);
                clearTimeout(timeoutId);
                videoEl?.removeEventListener('seeked', onSeeked);
                videoEl?.removeEventListener('timeupdate', onTimeUpdate);
            };

            const onSeeked = () => {
                log('applySeek', 'Evento "seeked" detectado.');
                completeSeek();
            };

            const onTimeUpdate = () => {
                try {
                    const currentTime = videoEl?.currentTime ?? player?.getCurrentTime?.();
                    if (Math.abs(currentTime - time) <= NEAR_THRESHOLD) {
                        log('applySeek', `Seek detectado por timeupdate. Diferencia: ${Math.abs(currentTime - time)}s`);
                        completeSeek();
                    }
                } catch (e) {
                    // ignorar errores de lectura
                }
            };

            // Intervalo de verificaci√≥n como respaldo
            const checkInterval = setInterval(() => {
                try {
                    const currentTime = videoEl?.currentTime ?? player?.getCurrentTime?.();
                    if (Math.abs(currentTime - time) <= NEAR_THRESHOLD) {
                        log('applySeek', `Seek detectado por intervalo. Diferencia: ${Math.abs(currentTime - time)}s`);
                        completeSeek();
                    }
                } catch (e) {
                    // ignorar
                }
            }, 200);

            // Timeout final
            const timeoutId = setTimeout(() => {
                warn('applySeek', `Timeout de ${TIMEOUT_MS}ms alcanzado. Verificando estado final...`);
                const currentTime = videoEl?.currentTime ?? player?.getCurrentTime?.();
                const diff = Math.abs(currentTime - time);
                if (diff <= 1.0) {
                    log('applySeek', `Seek probablemente completado. Diferencia final: ${diff}s`);
                } else {
                    warn('applySeek', `Seek incompleto. Diferencia final: ${diff}s`);
                }
                completeSeek();
            }, TIMEOUT_MS);

            // Listeners de eventos
            videoEl?.addEventListener('seeked', onSeeked, { once: true });
            videoEl?.addEventListener('timeupdate', onTimeUpdate);
        });

        // Notificaci√≥n final

        notifySeekOrProgress(time, 'seek', { isForced });

        log('applySeek', 'applySeek finalizado.');
    };

    // ------------------------------------------
    // MARK: üìÇ Sort UI
    // ------------------------------------------

    function createSortSelector(currentValue, onChange) {
        const wrapper = document.createElement('div');
        const label = createElement('label', { className: 'ypp-label', text: `${t('sortBy')} :`, atribute: { for: 'sort-selector' } });
        const select = createElement('select', {
            className: 'ypp-input', id: 'sort-selector', html: `
        <option value="recent" ${currentValue === 'recent' ? 'selected' : ''}>üìÖ ${t('mostRecent')}</option>
        <option value="oldest" ${currentValue === 'oldest' ? 'selected' : ''}>üìÜ ${t('oldest')}</option>
        <option value="title" ${currentValue === 'title' ? 'selected' : ''}>üî§ ${t('titleAZ')}</option>`
        });
        select.onchange = () => onChange(select.value);
        label.appendChild(select);
        wrapper.appendChild(label);
        return wrapper;
    }

    // ------------------------------------------
    // MARK: üìÇ Filters UI
    // ------------------------------------------

    function createFilterSelector(currentValue, onChange) {
        const wrapper = document.createElement('div');
        const label = createElement('label', { className: 'ypp-label', text: `${t('filterByType')} :`, atribute: { for: 'filter-selector' } });
        const select = createElement('select', {
            className: 'ypp-input', id: 'filter-selector', html: `
        <option value="all" ${currentValue === 'all' ? 'selected' : ''}>üîé ${t('all')}</option>
        <option value="regular" ${currentValue === 'regular' ? 'selected' : ''}>‚ñ∂Ô∏è ${t('videos')}</option>
        <option value="short" ${currentValue === 'short' ? 'selected' : ''}>üì± ${t('shorts')}</option>
        <option value="live" ${currentValue === 'live' ? 'selected' : ''}>üî¥ ${t('liveStreams')}</option>
        <option value="playlist" ${currentValue === 'playlist' ? 'selected' : ''}>üìÅ ${t('playlist')}</option>
        <option value="completed" ${currentValue === 'completed' ? 'selected' : ''}>‚úÖ ${t('completedVideos')}</option>`
        });
        select.onchange = () => onChange(select.value);
        label.appendChild(select);
        wrapper.appendChild(label);
        return wrapper;
    }

    function createSearchInput(currentValue, onChange) {
        const wrapper = createElement('div');
        const input = createElement('input', {
            className: 'ypp-input',
            id: 'search-input',
            atribute: {
                'aria-label': t('searchByTitleOrAuthor'),
                title: t('searchByTitleOrAuthor'),
                placeholder: `üîç ${t('searchByTitleOrAuthor')}`,
                type: 'text'
            }
        });
        input.value = currentValue;
        input.addEventListener('input', () => onChange(input.value.trim()));
        wrapper.appendChild(input);
        return wrapper;
    }

    async function saveFilters(newValues) {
        const currentRaw = await GM_getValue(CONFIG.userFiltersKey, '{}');
        const current = JSON.parse(currentRaw);
        const updated = { ...current, ...newValues };
        await GM_setValue(CONFIG.userFiltersKey, JSON.stringify(updated));
    }

    async function getSavedFilters() {
        const raw = await GM_getValue(CONFIG.userFiltersKey, '{}');
        try {
            const saved = raw ? JSON.parse(raw) : {};
            const merged = { ...CONFIG.defaultFilters, ...saved };
            return merged;
        } catch (e) {
            conError('getSavedFilters', 'Error parsing filtros guardados:', e);
            return { ...CONFIG.defaultFilters };
        }
    }

    // ------------------------------------------
    // MARK: üìÇ Video List UI
    // ------------------------------------------

    let videosOverlay = null;
    let videosContainer = null;
    let listContainer = null;
    let currentOrderBy, currentFilterBy, currentSearchQuery;

    function updateVideoList() {
        const keys = Storage.keys().filter(k => !k.startsWith('userSettings'));
        setInnerHTML(listContainer, ''); // Limpiar contenido previo

        let allItems = [];
        keys.forEach(key => {
            const data = Storage.get(key);
            log('updateVideoList', `Data: ${JSON.stringify(data)}`)
            /* 
                {
                "timestamp": 42.0,
                "lastUpdated": 1761712984212,
                "videoType": "music",
                "isCompleted": false,
                "title": "Rick Astley - Never Gonna Give You Up (Official Music Video)",
                "author": "Rick Astley",
                "thumb": "https://i.ytimg.com/vi/dQw4w9WgXcQ/hqdefault.jpg",
                "views": "1,543,210,987 views",
                "savedAt": 1761712984212,
                "duration": 213.0
                }
            */


            if (!data) return;

            if (data.videos) { // Es una playlist
                const playlistTitle = data.title || key;
                const lastWatchedVideoId = data.lastWatchedVideoId || null;
                Object.entries(data.videos).forEach(([videoId, info]) => {
                    allItems.push({
                        type: 'playlist-video',
                        videoId,
                        info,
                        playlistKey: key,
                        playlistTitle,
                        lastWatchedVideoId
                    });
                });
            } else { // Es un video individual
                allItems.push({
                    type: 'regular-video',
                    videoId: key,
                    info: data,
                    playlistKey: null
                });
            }
        });

        let filteredItems = allItems.filter(item => {
            if (currentFilterBy === 'completed') return item.info.isCompleted === true;
            if (currentFilterBy === 'playlist') return item.type === 'playlist-video';
            if (currentFilterBy === 'all') return true;
            return item.info.videoType === currentFilterBy;
        }).filter(item => {
            if (!currentSearchQuery) return true;
            const query = currentSearchQuery.toLowerCase();
            return (item.info.title || '').toLowerCase().includes(query) ||
                (item.info.author || '').toLowerCase().includes(query) ||
                (item.playlistTitle || '').toLowerCase().includes(query);
        });

        const getSortValue = (item) => {
            if (currentOrderBy === 'title') return (item.info.title || item.videoId).toLowerCase();
            if (currentOrderBy === 'oldest') return item.info.savedAt || 0;
            return -(item.info.savedAt || 0);
        };
        filteredItems.sort((a, b) => {
            const valA = getSortValue(a);
            const valB = getSortValue(b);
            if (typeof valA === 'string') return valA.localeCompare(valB);
            return valA - valB;
        });

        let lastRenderedPlaylistKey = null;
        filteredItems.forEach(item => {
            if (item.type === 'playlist-video') {
                if (item.playlistKey !== lastRenderedPlaylistKey) {
                    // Si hay un √∫ltimo video visto, enlazar a ese video + playlist (para mixes de YT)
                    // Si no, enlazar a la playlist completa
                    const playlistUrl = item.lastWatchedVideoId
                        ? `https://www.youtube.com/watch?v=${item.lastWatchedVideoId}&list=${item.playlistKey}`
                        : `https://www.youtube.com/playlist?list=${item.playlistKey}`;

                    const h3 = createElement('a', {
                        className: 'ypp-playlistTitle',
                        text: `üìÅ ${t('playlistPrefix')}: ${item.playlistTitle}`,
                        atribute: {
                            href: playlistUrl,
                            target: '_blank',
                            rel: 'noopener noreferrer'
                        }
                    });
                    listContainer.appendChild(h3);
                    lastRenderedPlaylistKey = item.playlistKey;
                }
                listContainer.appendChild(createVideoEntry(item.videoId, item.info, item.playlistKey));
            } else {
                listContainer.appendChild(createVideoEntry(item.videoId, item.info, null));
            }
        });

        if (filteredItems.length === 0) {
            const p = createElement('p', { className: 'ypp-emptyMsg', text: t('noSavedVideos') });
            listContainer.appendChild(p);
        }
    }

    function closeModalVideos() {
        if (videosOverlay) {
            videosOverlay.remove();
            videosOverlay = null;
        }
        if (videosContainer) {
            videosContainer.remove();
            videosContainer = null;
        }
        if (listContainer) {
            listContainer.remove();
            listContainer = null;
        }
        document.body.style.overflow = '';
    }

    // ------------------------------------------
    // MARK: üîò Floating Button
    // ------------------------------------------

    const createFloatingButton = async () => {
        const settings = await Settings.get();

        if (!settings.showFloatingButtons) return;

        const wrapper = createElement('div', { className: 'ypp-floatingBtnContainer' });
        const btnConfig = createElement('div', { className: 'ypp-btn', text: `‚öôÔ∏è ${t('youtubePlaybackPlox')}`, onClickEvent: showSettingsUI });
        wrapper.appendChild(btnConfig);
        document.body.appendChild(wrapper);

        const updateVisibility = () => {
            const isFullscreen = !!document.fullscreenElement;
            wrapper.style.display = isFullscreen ? 'none' : 'flex';
        };
        document.addEventListener('fullscreenchange', updateVisibility);
        window.addEventListener('yt-navigate-finish', updateVisibility);
        updateVisibility();
    };

    // ------------------------------------------
    // MARK: üìÇ Show Saved Videos List
    // ------------------------------------------

    async function showSavedVideosList() {
        // Siempre cerrar el modal existente para asegurar un estado limpio
        closeModalVideos();

        // Cargar filtros guardados para asegurar sincronizaci√≥n
        const saved = await getSavedFilters();

        // Usar los filtros pasados como par√°metro o los guardados
        currentOrderBy = saved.orderBy ?? CONFIG.defaultFilters.orderBy;
        currentFilterBy = saved.filterBy ?? CONFIG.defaultFilters.filterBy;
        currentSearchQuery = saved.searchQuery ?? CONFIG.defaultFilters.searchQuery;

        // Crear elementos del modal
        videosOverlay = createElement('div', { className: 'ypp-overlay' });
        videosContainer = createElement('div', { className: 'ypp-container' });
        listContainer = createElement('div', { id: 'video-list-container' });

        const header = createElement('div', { className: 'ypp-header' });
        const title = createElement('h2', { text: t('youtubePlaybackPlox') });
        const closeBtn = createElement('button', {
            className: 'ypp-btn',
            text: '‚úñ',
            atribute: { 'aria-label': t('close') },
            onClickEvent: closeModalVideos
        });

        header.appendChild(title);
        header.appendChild(closeBtn);
        videosContainer.appendChild(header);

        const filtersContainer = createElement('div', { className: 'ypp-filters' });
        filtersContainer.appendChild(createSortSelector(currentOrderBy, async (selected) => {
            currentOrderBy = selected;
            await saveFilters({ orderBy: selected });
            updateVideoList();
        }));
        filtersContainer.appendChild(createFilterSelector(currentFilterBy, async (selected) => {
            currentFilterBy = selected;
            await saveFilters({ filterBy: selected });
            updateVideoList();
        }));
        filtersContainer.appendChild(createSearchInput(currentSearchQuery, async (query) => {
            currentSearchQuery = query;
            await saveFilters({ searchQuery: query });
            updateVideoList();
        }));
        videosContainer.appendChild(filtersContainer);

        videosContainer.appendChild(listContainer);

        const footer = createElement('div', { className: 'ypp-footer' });
        const exportDataToFile = () => {
            const exportData = {};
            const keys = Storage.keys().filter(k => !k.startsWith('userSettings'));
            keys.forEach(k => {
                const data = Storage.get(k);
                if (data) exportData[k] = data;
            });
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'youtube-playback-plox-backup.json';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            showFloatingToast(`üì§ ${t('dataExported')}`);
        };
        const importDataFromFile = () => {
            let inputFile = document.getElementById('ypp-import-file');
            if (!inputFile) {
                inputFile = createElement('input', {
                    id: 'ypp-import-file',
                    atribute: { type: 'file' },
                    props: { accept: 'application/json' }
                });
                inputFile.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const text = await file.text();
                        const importedData = JSON.parse(text);
                        if (typeof importedData !== 'object' || importedData === null) {
                            throw new Error('Formato no v√°lido');
                        }
                        let count = 0;
                        for (const [key, value] of Object.entries(importedData)) {
                            Storage.set(key, value);
                            count++;
                        }
                        showFloatingToast(`üì• ${t('itemsImported', { count })}`);
                        closeModalVideos();
                        showSavedVideosList();
                    } catch (err) {
                        conError('importDataFromFile', 'Error al importar datos:', err);
                        showFloatingToast(`‚ö†Ô∏è ${t('importError')}`);
                    } finally {
                        inputFile.value = '';
                    }
                });
                document.body.appendChild(inputFile);
            }
            inputFile.click();
        };
        const clearAllData = () => {
            if (!confirm(t('clearAllConfirm'))) {
                return;
            }

            // Guardar todos los datos para deshacer
            const keys = Storage.keys().filter(k => !k.startsWith('userSettings'));
            const backup = {};
            keys.forEach(k => {
                const data = Storage.get(k);
                if (data) backup[k] = data;
            });

            // Eliminar todos los datos
            keys.forEach(k => Storage.del(k));

            // Actualizar la UI
            updateVideoList();

            // Mostrar toast con opci√≥n de deshacer
            const undoAction = () => {
                // Restaurar todos los datos
                Object.entries(backup).forEach(([key, value]) => {
                    Storage.set(key, value);
                });
                updateVideoList();
                showFloatingToast(`‚úÖ ${t('retryCompleted')}`);
            };

            showFloatingToast(`üóëÔ∏è ${t('allItemsCleared')}`, 10000, {
                action: {
                    label: t('undoClearAll'),
                    callback: undoAction
                }
            });
        };

        const btnExport = createElement('button', { className: 'ypp-btn', text: `üì§ ${t('export')}`, onClickEvent: exportDataToFile });
        const btnImport = createElement('button', { className: 'ypp-btn', text: `üì• ${t('import')}`, onClickEvent: importDataFromFile });
        const btnClearAll = createElement('button', { className: 'ypp-btn ypp-btn-danger', text: `üóëÔ∏è ${t('clearAll')}`, onClickEvent: clearAllData });
        footer.appendChild(btnExport);
        footer.appendChild(btnImport);
        footer.appendChild(btnClearAll);
        videosContainer.appendChild(footer);

        videosOverlay.addEventListener('click', closeModalVideos);
        document.body.appendChild(videosOverlay);
        document.body.appendChild(videosContainer);

        // Actualizar la lista de videos con los filtros actuales
        updateVideoList();
    }

    // ------------------------------------------
    // MARK: üìÇ Video Entry
    // ------------------------------------------

    function createVideoEntry(videoId, info, playlistKey = null) {
        const isCompleted = info.isCompleted || false;
        const videoTime = formatTime(normalizeSeconds(info.timestamp));
        const duration = normalizeSeconds(info.duration);
        const watched = normalizeSeconds(info.timestamp);
        const remaining = Math.max(duration - watched, 0);
        const percent = duration ? Math.min(100, Math.round((watched / duration) * 100)) : null;
        const wrapper = createElement('div', { className: `ypp-videoWrapper ${playlistKey ? 'playlist-item' : ''}` });
        const thumb = createElement('img', {
            className: 'ypp-thumb',
            atribute: {
                title: info.title || videoId,
                loading: 'lazy',
                alt: info.title || 'Miniatura',
                src: info.thumb || getVideoThumbnail(videoId)
            },
            props: { draggable: false }
        });
        wrapper.appendChild(thumb);
        const infoDiv = createElement('div', { className: 'ypp-infoDiv' });
        const titleLink = createElement('a', {
            className: 'ypp-titleLink', text: info.title || videoId,
            atribute: {
                title: info.title || videoId,
                href: `https://www.youtube.com/watch?v=${videoId}${playlistKey ? '&list=' + playlistKey : ''}`
            },
            props: { target: '_blank', rel: 'noopener noreferrer' }
        });
        const author = createElement('div', { className: 'ypp-author', text: info.author || t('unknown') });
        const views = createElement('div', { className: 'ypp-views', text: info.views || t('notAvailable') });

        // Determinar texto del timestamp (puede mostrar ambos estados)
        let timestampText = '';
        let timestampClass = '';

        if (info.forceResumeTime > 0) {
            // Video con tiempo fijo
            const fixedTimeStr = `‚è±Ô∏è ${t('alwaysStartFrom')}: ${formatTime(normalizeSeconds((info.forceResumeTime)))} ${t('locked')}`;
            timestampClass = 'forced';

            if (isCompleted) {
                // Tiempo fijo + completado
                timestampText = `${fixedTimeStr} ‚úÖ`;
                timestampClass += ' completed';
            } else {
                // Solo tiempo fijo
                timestampText = fixedTimeStr;
            }
        } else {
            // Video normal (sin tiempo fijo)
            if (isCompleted) {
                timestampText = `‚úÖ ${t('completed')}`;
                timestampClass = 'completed';
            } else {
                timestampText = `${t('progress')} ${videoTime}`;
            }
        }

        const timestamp = createElement('div', { className: `ypp-timestamp ${timestampClass}`, text: timestampText });

        infoDiv.appendChild(titleLink);
        infoDiv.appendChild(author);
        infoDiv.appendChild(views);
        infoDiv.appendChild(timestamp);
        if (percent !== null && !isCompleted) {
            const progressInfo = createElement('div', { className: 'ypp-progressInfo', text: `üìä ${percent}% ${t('percentWatched')} (${formatTime(normalizeSeconds((remaining)))} ${t('remaining')})` });
            infoDiv.appendChild(progressInfo);
        }
        wrapper.appendChild(infoDiv);

        const buttonContainer = createElement('div', { className: 'ypp-containerButtonsTime' });

        const btnForceTime = createElement('button', {
            className: 'ypp-btn ypp-btn-small',
            text: '‚è±Ô∏è',
            atribute: { title: info.forceResumeTime ? t('changeOrRemoveStartTime', { time: formatTime(normalizeSeconds((info.forceResumeTime))) }) : t('setStartTime') },
            onClickEvent: () => {
                const promptText = info.forceResumeTime
                    ? `${t('enterStartTimeOrEmpty')}:`
                    : `${t('enterStartTime')}:`;
                const timeStr = prompt(promptText, info.forceResumeTime ? formatTime(normalizeSeconds((info.forceResumeTime))) : '');

                if (timeStr === null) { // Usuario cancel√≥
                    return;
                }

                const timeSec = parseTimeToSeconds(timeStr);

                if (playlistKey) {
                    const playlist = Storage.get(playlistKey);
                    if (playlist?.videos?.[videoId]) {
                        if (timeSec > 0) {
                            playlist.videos[videoId].forceResumeTime = timeSec;
                            showFloatingToast(`‚úÖ ${t('startTimeSet')} ${formatTime(normalizeSeconds((timeSec)))}`);
                        } else {
                            delete playlist.videos[videoId].forceResumeTime;
                            showFloatingToast(`üîì ${t('fixedTimeRemoved')}`);
                        }
                        Storage.set(playlistKey, playlist);
                    }
                } else {
                    const data = Storage.get(videoId);
                    if (data) {
                        if (timeSec > 0) {
                            data.forceResumeTime = timeSec;
                            showFloatingToast(`‚úÖ ${t('startTimeSet')} ${formatTime(normalizeSeconds((timeSec)))}`);
                        } else {
                            delete data.forceResumeTime;
                            showFloatingToast(`üîì ${t('fixedTimeRemoved')}`);
                        }
                        Storage.set(videoId, data);
                    }
                }
                updateVideoList();
            }
        });
        buttonContainer.appendChild(btnForceTime);

        const btnDelete = createElement('button', {
            className: 'ypp-btn ypp-btn-delete ypp-btn-small',
            atribute: { title: t('deleteEntry') },
            text: 'üóëÔ∏è',
            onClickEvent: () => {
                const title = info.title || videoId;
                const itemData = { videoId, info, playlistKey };

                const performDelete = () => {
                    if (playlistKey) {
                        const playlist = Storage.get(playlistKey);
                        if (playlist?.videos?.[videoId]) {
                            delete playlist.videos[videoId];
                            Object.keys(playlist.videos).length
                                ? Storage.set(playlistKey, playlist)
                                : Storage.del(playlistKey);
                        }
                    } else {
                        Storage.del(videoId);
                    }
                    updateVideoList();
                };

                const undoDelete = () => {
                    if (playlistKey) {
                        const playlist = Storage.get(playlistKey) || { lastWatchedVideoId: '', videos: {}, title: '' };
                        playlist.videos[videoId] = itemData.info;
                        Storage.set(playlistKey, playlist);
                    } else {
                        Storage.set(videoId, itemData.info);
                    }
                    updateVideoList();
                };

                performDelete();
                showFloatingToast(`üóëÔ∏è "${title}" ${t('itemDeleted')}`, 5000, {
                    action: {
                        label: t('undo'),
                        callback: undoDelete
                    }
                });
            }
        });
        buttonContainer.appendChild(btnDelete);
        wrapper.appendChild(buttonContainer);

        return wrapper;
    }

    // ------------------------------------------
    // MARK: ‚öôÔ∏è Settings UI
    // ------------------------------------------

    async function showSettingsUI() {
        if (document.querySelector('.settings-modal')) return;
        closeModalVideos();
        const settings = await Settings.get();
        const content = createElement('div', { className: 'ypp-settingsContent' });

        // Selector de idioma
        const languageGroup = createElement('div');
        const languageLabel = createElement('label', {
            className: 'ypp-label',
            text: `${t('language')}:`,
            atribute: { for: 'language-selector' }
        });

        // Crear el selector con banderas
        const languageSelect = createElement('select', {
            className: 'ypp-input ypp-language-selector',
            id: 'language-selector',
            html: (() => {
                const langs = Object.keys(LANGUAGE_FLAGS);

                // Mover el idioma actual al principio
                const currentLang = settings.language || defaultSettings.language;
                langs.sort((a, b) => (a === currentLang ? -1 : b === currentLang ? 1 : 0));

                return langs.map(lang => {
                    const { emoji, name } = LANGUAGE_FLAGS[lang];
                    const selected = settings.language === lang ? 'selected' : '';
                    return `<option value="${lang}" ${selected}>${emoji || 'üåê'} ${name || lang.toUpperCase()}</option>`;
                }).join('');
            })()
        });



        languageLabel.appendChild(languageSelect);
        languageGroup.appendChild(languageLabel);
        content.appendChild(languageGroup);

        // Selector de estilo de alerta
        const alertStyleGroup = createElement('div');
        const alertStyleLabel = createElement('label', {
            className: 'ypp-label',
            text: `${t('alertStyle')}:`,
            atribute: { for: 'alert-style-selector' }
        });

        const alertStyleSelect = createElement('select', {
            className: 'ypp-input',
            id: 'alert-style-selector',
            html: `
                <option value="iconText" ${settings.alertStyle === 'iconText' ? 'selected' : ''}>${t('alertIconText')}</option>
                <option value="iconOnly" ${settings.alertStyle === 'iconOnly' ? 'selected' : ''}>${t('alertIconOnly')}</option>
                <option value="textOnly" ${settings.alertStyle === 'textOnly' ? 'selected' : ''}>${t('alertTextOnly')}</option>
                <option value="hidden" ${settings.alertStyle === 'hidden' ? 'selected' : ''}>${t('alertHidden')}</option>
            `
        });
        alertStyleLabel.appendChild(alertStyleSelect);
        alertStyleGroup.appendChild(alertStyleLabel);
        content.appendChild(alertStyleGroup);

        const activationGroup = createElement('div');
        const activationLabel = createElement('div', { text: `${t('enableSavingFor')}:`, style: 'font-weight: bold; margin-bottom: 8px;' });
        activationGroup.appendChild(activationLabel);

        const types = [
            { key: 'saveRegularVideos', label: `‚ñ∂Ô∏è ${t('regularVideos')}` },
            { key: 'saveShorts', label: `üì± ${t('shorts')}` },
            { key: 'saveLiveStreams', label: `üî¥ ${t('liveStreams')}` }
        ];

        types.forEach(type => {
            const group = createElement('div');
            const label = createElement('label', { className: 'ypp-label', text: type.label, atribute: { for: type.key } });
            const toggle = createElement('input', {
                id: type.key,
                atribute: { type: 'checkbox' },
                props: { checked: settings[type.key] }
            });
            label.appendChild(toggle);
            group.appendChild(label);
            activationGroup.appendChild(group);
        });
        content.appendChild(activationGroup);

        const notifGroup = createElement('div');
        const notifLabel = createElement('label', {
            className: 'ypp-label', text: t('showNotifications'), atribute: { for: 'toggleNotif' },
        });
        const toggleNotif = createElement('input', {
            id: 'toggleNotif',
            atribute: { title: t('showNotifications'), for: 'toggleNotif', type: 'checkbox' },
            props: { checked: settings.showNotifications }
        });
        notifLabel.appendChild(toggleNotif);
        notifGroup.appendChild(notifLabel);
        content.appendChild(notifGroup);

        const intervalGroup = document.createElement('div');
        const intervalLabel = createElement('label', {
            className: 'ypp-label',
            text: `${t('minSecondsBetweenSaves')}: `,
            atribute: { for: 'interval' }
        });
        const intervalInput = createElement('input', {
            className: 'ypp-input ypp-input-small',
            id: 'interval',
            atribute: { title: 'Segundos', min: '1', type: 'number' },
            props: { value: settings.minSecondsBetweenSaves }
        });
        intervalLabel.appendChild(intervalInput);
        intervalGroup.appendChild(intervalLabel);
        content.appendChild(intervalGroup);

        const buttonsGroup = document.createElement('div');
        const buttonsLabel = createElement('label', {
            className: 'ypp-label',
            atribute: { title: t('showFloatingButton'), for: 'toggleButtons' },
            text: ` ${t('showFloatingButton')}`
        });
        const toggleButtons = createElement('input', {
            id: 'toggleButtons',
            atribute: { title: t('showFloatingButton'), type: 'checkbox' },
            props: { checked: settings.showFloatingButtons }
        });
        buttonsLabel.appendChild(toggleButtons);
        buttonsGroup.appendChild(buttonsLabel);
        content.appendChild(buttonsGroup);

        const buttonGroup = createElement('div', { className: 'ypp-btnGroup' });
        const saveBtn = createElement('button', {
            className: 'ypp-btn ypp-save-button',
            id: 'saveBtn',
            text: t('save'),
            onClickEvent: async () => {
                const newSettings = {
                    showNotifications: toggleNotif.checked,
                    minSecondsBetweenSaves: Math.max(1, parseInt(intervalInput.value, 10)),
                    showFloatingButtons: toggleButtons.checked,
                    saveRegularVideos: document.getElementById('saveRegularVideos').checked,
                    saveShorts: document.getElementById('saveShorts').checked,
                    saveLiveStreams: document.getElementById('saveLiveStreams').checked,
                    language: languageSelect.value,
                    alertStyle: alertStyleSelect.value,
                };
                await Settings.set(newSettings);
                await setLanguage(languageSelect.value);
                showFloatingToast(`‚úÖ ${t('configurationSaved')}`);
                location.reload();
            }
        });
        const viewBtn = createElement('button', {
            className: 'ypp-btn ypp-btn-outlined',
            id: 'viewSavedBtn',
            text: `üìº ${t('savedVideos')}`,
            onClickEvent: () => {
                host.remove();
                showSavedVideosList();
            }
        });
        buttonGroup.appendChild(viewBtn);
        buttonGroup.appendChild(saveBtn);
        content.appendChild(buttonGroup);
        const { host } = createModal(`‚öôÔ∏è ${t('settings')}`, content);
        host.classList.add('settings-modal');
    }

    // ------------------------------------------
    // MARK: ‚öôÔ∏è Menu Commands
    // ------------------------------------------

    // Funci√≥n para registrar los comandos del men√∫ con traducciones
    function registerMenuCommands() {
        GM_registerMenuCommand(`‚öôÔ∏è ${t('settings')}`, showSettingsUI);
        /* GM_registerMenuCommand(`üìã ${t('savedVideos')}`, showSavedVideosList); */
        GM_registerMenuCommand(`üìö ${t('viewAllHistory')}`, async () => {
            // Cerrar modal si est√° abierto para forzar recreaci√≥n
            closeModalVideos();
            // Guardar filtros y esperar a que se complete
            await saveFilters({ filterBy: 'all', searchQuery: '' });
            // Establecer filtro global y mostrar lista
            currentFilterBy = 'all';
            showSavedVideosList();
        });
        GM_registerMenuCommand(`‚úÖ ${t('viewCompletedVideos')}`, async () => {
            closeModalVideos();
            await saveFilters({ filterBy: 'completed' });
            currentFilterBy = 'completed';
            showSavedVideosList();
        });
    }

    // ------------------------------------------
    // MARK: üì¢ Ad Monitor
    // ------------------------------------------

    let isAdPlaying = false;
    let globalAdPlaying = false; // Si necesitas esta variable global

    /*  function createAdMonitor({ onAdStart, onAdEnd } = {}) {
         const target = getActiveContainer();
 
         // Selectores de anuncios
         const adSelectors = [
             '.ytp-ad-player-overlay',
             '.ytp-ad-text',
             '.ytp-ad-image-overlay',
             '.ytp-ad-skip-button-container',
             '.ytp-ad-overlay-container'
         ].join(',');
 
         let observer = null;
         let debounceTimer = null;
         let currentVideoEl = target.querySelector('video');
 
         const getVideoEl = () => {
             const video = target.querySelector('video');
             if (video && video !== currentVideoEl) currentVideoEl = video;
             return currentVideoEl;
         };
 
         const isAd = () => !!target.querySelector(adSelectors);
         const isNormalControlsPresent = () => (
             !!target.querySelector('.ytp-chrome-bottom') &&
             !target.querySelector(adSelectors)
         );
 
         const checkState = () => {
             const videoEl = getVideoEl();
             if (!videoEl) return;
 
             const adNow = isAd();
             const normalNow = isNormalControlsPresent();
 
             // Cambio de estado de anuncio
             if (adNow !== isAdPlaying) {
                 isAdPlaying = adNow;
                 if (isAdPlaying) {
                     log('adMonitor', '‚èπ Anuncio iniciado.');
                     onAdStart?.();
                 } else {
                     log('adMonitor', '‚úÖ Anuncio finalizado.');
                     onAdEnd?.();
                 }
             }
 
             // Video listo sin anuncios
             if (!adNow && normalNow && !isAdPlaying && videoEl.readyState > 2) {
                 if (!observer._hasCalledOnEnd) {
                     observer._hasCalledOnEnd = true;
                     log('adMonitor', 'üü¢ Video listo sin anuncios; reanudando.');
                     onAdEnd?.();
                 }
             }
         };
 
         const debouncedCheck = () => {
             if (debounceTimer) return;
             debounceTimer = setTimeout(() => {
                 debounceTimer = null;
                 checkState();
             }, 50);
         };
 
         const start = () => {
             stop();
             log('adMonitor', 'Iniciando monitoreo de anuncios.');
 
             // Estado inicial
             isAdPlaying = isAd();
             if (isAdPlaying) {
                 onAdStart?.();
             } else {
                 // Si no hay anuncios pero video listo
                 const videoEl = getVideoEl();
                 if (videoEl?.readyState > 2) {
                     setTimeout(() => onAdEnd?.(), 50);
                 }
             }
 
             observer = new MutationObserver(debouncedCheck);
             observer.observe(target, {
                 attributes: true,
                 attributeFilter: ['class'],
                 childList: true,
                 subtree: true // ahora observa cambios profundos para detectar reemplazo de video
             });
         };
 
         const stop = () => {
             if (debounceTimer) {
                 clearTimeout(debounceTimer);
                 debounceTimer = null;
             }
             if (observer) {
                 observer.disconnect();
                 observer = null;
                 log('adMonitor', 'Monitoreo de anuncios detenido.');
             }
         };
 
         const getStatus = () => isAdPlaying;
 
         return { start, stop, getStatus };
     } */

    function createAdMonitor({ onAdStart, onAdEnd } = {}) {
        // Estado LOCAL a esta instancia
        let isAdPlaying = false;
        let observer = null;
        let debounceTimer = null;
        let currentVideoEl = null;

        const getVideoEl = () => {
            const target = getActiveContainer();
            if (!target) return null;

            const video = target.querySelector('video');
            if (video && video !== currentVideoEl) {
                currentVideoEl = video;
            }
            return currentVideoEl;
        };

        // Selectores m√°s completos para anuncios de YouTube
        const adSelectors = [
            '.ytp-ad-player-overlay',
            '.ytp-ad-text',
            '.ytp-ad-image-overlay',
            '.ytp-ad-skip-button-container',
            '.ytp-ad-overlay-container',
            '.ytp-ad-module',
            '.ytp-ad-progress-list',
            '.ad-showing', // Clase importante cuando hay anuncio
            '.ad-interrupting' // Para anuncios que interrumpen
        ].join(',');

        // M√©todos mejorados de detecci√≥n
        const isAd = () => {
            const target = getActiveContainer();
            if (!target) return false;

            // 1. Verificar elementos DOM de anuncios
            const hasAdElements = !!target.querySelector(adSelectors);

            // 2. Verificar clase "ad-showing" en el reproductor
            const player = target.querySelector('#movie_player, .html5-video-player');
            const hasAdClass = player && player.classList.contains('ad-showing');

            // 3. Verificar si el video actual es un anuncio
            const video = getVideoEl();
            const isAdVideo = video && (
                video.duration <= 60 || // Anuncios son cortos
                video.src.includes('/ad/') || // URL de anuncio
                video.currentSrc.includes('/ad/')
            );

            return hasAdElements || hasAdClass || isAdVideo;
        };

        const isNormalVideo = () => {
            const target = getActiveContainer();
            if (!target) return false;

            const video = getVideoEl();
            return video &&
                video.duration > 60 && // Videos normales son largos
                !video.src.includes('/ad/') &&
                !!target.querySelector('.ytp-chrome-bottom');
        };

        const checkState = () => {
            const videoEl = getVideoEl();
            if (!videoEl) return;

            const adNow = isAd();
            const videoReady = videoEl.readyState >= 2;

            // Solo actuar si el estado cambi√≥
            if (adNow !== isAdPlaying) {
                isAdPlaying = adNow;

                if (isAdPlaying) {
                    console.log('üî¥ Anuncio detectado, ejecutando onAdStart');
                    onAdStart?.();
                } else {
                    console.log('üü¢ Anuncio terminado, ejecutando onAdEnd');
                    onAdEnd?.();
                }
            }

            // Si no hay anuncio y el video est√° listo, asegurar onAdEnd
            if (!adNow && videoReady && !isAdPlaying) {
                console.log('üü¢ Video normal listo');
                onAdEnd?.();
            }
        };

        const debouncedCheck = () => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(checkState, 100);
        };

        const start = () => {
            stop();
            console.log('üéØ Iniciando monitor de anuncios');

            // Configurar observer
            const target = getActiveContainer();
            if (!target) {
                console.error('‚ùå No se pudo encontrar el contenedor objetivo');
                return;
            }

            observer = new MutationObserver(debouncedCheck);
            observer.observe(target, {
                attributes: true,
                attributeFilter: ['class', 'src'],
                childList: true,
                subtree: true
            });

            // Tambi√©n escuchar eventos del video
            const videoEl = getVideoEl();
            if (videoEl) {
                videoEl.addEventListener('loadstart', debouncedCheck);
                videoEl.addEventListener('canplay', debouncedCheck);
                videoEl.addEventListener('playing', debouncedCheck);
                videoEl.addEventListener('pause', debouncedCheck);
            }

            // Verificaci√≥n inicial
            checkState();
        };

        const stop = () => {
            if (debounceTimer) {
                clearTimeout(debounceTimer);
                debounceTimer = null;
            }
            if (observer) {
                observer.disconnect();
                observer = null;
            }

            // Remover event listeners del video
            const videoEl = getVideoEl();
            if (videoEl) {
                videoEl.removeEventListener('loadstart', debouncedCheck);
                videoEl.removeEventListener('canplay', debouncedCheck);
                videoEl.removeEventListener('playing', debouncedCheck);
                videoEl.removeEventListener('pause', debouncedCheck);
            }

            console.log('‚èπ Monitor de anuncios detenido');
        };

        const getStatus = () => isAdPlaying;

        return { start, stop, getStatus };
    }

    // ------------------------------------------
    // MARK: üé• Observer Regular Player
    // ------------------------------------------

    /*  function observePlayer() {
         // Si ya estamos en Shorts, no continuar (ser√° manejado por observeShorts)
         if (location.pathname.startsWith('/shorts/')) {
             log('observePlayer', 'P√°gina de Shorts detectada, deteniendo observaci√≥n del reproductor regular.');
             return;
         }
 
         // Verificar si estamos en una p√°gina de video
         const isVideoPage = () => {
             // Verificar si la URL contiene un par√°metro 'v' (ID de video)
             const urlParams = new URLSearchParams(location.search);
             const hasVideoId = urlParams.has('v');
 
             // Verificar si estamos en una p√°gina de video
             const isWatchPage = pageTypeListener === 'watch';
 
 
 
 
             // Tambi√©n verificar si estamos en una p√°gina de embed
             const isEmbedPage = location.pathname.startsWith('/embed/');
 
             // Verificar si hay un reproductor de video en la p√°gina
             const hasPlayer = document.querySelector('#movie_player, .html5-video-player, .html5-video-container');
 
             return (hasVideoId && (isWatchPage || isEmbedPage)) || (hasPlayer && hasVideoId);
         };
 
         if (!isVideoPage()) {
             log('observePlayer', 'No estamos en una p√°gina de video v√°lida. Saliendo del observador.');
             return;
         }
 
         stopChecking(); // Limpiar cualquier intervalo existente
         let adMonitor = null;
         let attempts = 0;
         const maxAttempts = 30;
         const checkDelay = 500;
         const selectors = ['#movie_player', '.html5-video-player', '.html5-video-container'];
 
         const findPlayer = () => {
             attempts++;
             log('observePlayer', `Intento ${attempts} de encontrar el reproductor de video.`);
 
             if (!isVideoPage()) {
                 log('observePlayer', 'Ya no estamos en una p√°gina de video v√°lida, deteniendo observaci√≥n.');
                 stopChecking();
                 return false;
             }
 
             for (const selector of selectors) {
                 const container = document.querySelector(selector);
                 if (!container) continue;
                 const videoEl = container.querySelector('video');
                 if (!videoEl || videoEl.offsetWidth < 200) continue;
 
                 const player = getPlayerInstance(container);
                 if (player && typeof player.getVideoData === 'function' && player.getVideoData()?.video_id) {
                     handleFoundPlayer(container, player, videoEl);
                     observer.disconnect();
                     stopChecking();
                     return true;
                 }
             }
 
             if (attempts >= 12) tryFallback();
 
             if (attempts >= maxAttempts) {
                 log('observePlayer', 'M√°ximo de intentos alcanzado sin encontrar el reproductor.');
                 stopChecking();
                 observer.disconnect();
             }
             return false;
         };
 
         const getPlayerInstance = (container) => {
             if (window.yt?.player?.Application?.instances_?.length) {
                 return window.yt.player.Application.instances_.slice(-1)[0];
             }
             return container.player_ || container;
         };
 
         log('observePlayer', 'Intentando encontrar el reproductor de video... player:', player)
 
         const handleFoundPlayer = (container, player, videoEl) => {
             log('handleFoundPlayer', '‚úÖ Reproductor encontrado');
 
             if (!regularPlayerInitialized) {
                 log('init', 'Reproductor regular inicializado.');
                 regularPlayerInitialized = true;
             }
 
             if (adMonitor) adMonitor.stop();
 
             adMonitor = createAdMonitor(container, {
                 onAdStart: () => {
                     log('‚è∏ Anuncio detectado, pausando acciones hasta que finalice.');
                     isAdPlaying = true;
                 },
                 onAdEnd: () => {
                     log('‚ñ∂Ô∏è Monitor de anuncios finalizado, reanudando.');
                     isAdPlaying = false;
                     processVideoAfterAd(player, videoEl, container);
                 }
             });
 
             adMonitor.start();
         };
 
         const tryFallback = () => {
             const videos = document.querySelectorAll('video');
             for (const videoEl of videos) {
                 if (videoEl.offsetWidth < 200) continue;
                 if (videoEl.src?.includes('youtube.com') || videoEl.src?.includes('googlevideo.com')) {
                     log('tryFallback', 'Video encontrado mediante fallback.');
                     let container = videoEl.closest('#movie_player, .html5-video-player, .ytd-player') || videoEl.parentElement;
                     if (container) {
                         const player = getPlayerInstance(container);
                         handleFoundPlayer(container, player, videoEl);
                         return true;
                     }
                 }
             }
             return false;
         };
 
         const processVideoAfterAd = (player, videoEl, container) => {
             setTimeout(() => {
                 if (typeof player.getVideoData === 'function') {
                     log('processVideoAfterAd', '‚úÖ Reproductor encontrado');
                     log('processVideoAfterAd', 'Enviando a processVideo player:', player);
                     log('processVideoAfterAd', 'Enviando a processVideo videoEl:', videoEl);
                     processVideo(player, videoEl);
                 } else {
                     log('processVideoAfterAd', '‚ùå Reproductor no encontrado, intentando obtener el reproductor alternativo de YouTube.');
                     tryAlternativePlayer(container, videoEl);
                 }
             }, 150);
         };
 
         const tryAlternativePlayer = (container, videoEl) => {
             log('observePlayer', 'Intentando obtener el reproductor alternativo de YouTube.');
             const ytPlayer = window.yt?.player?.getPlayerByElement?.(videoEl);
             log('observePlayer', 'Obteniendo el reproductor alternativo de YouTube con ytPlayer:', ytPlayer)
             if (ytPlayer?.getVideoData) {
                 log('observePlayer', '‚úÖ Reproductor encontrado');
                 log('observePlayer', 'Enviando a processVideo player:', ytPlayer);
                 log('observePlayer', 'Enviando a processVideo videoEl:', videoEl);
                 processVideo(ytPlayer, videoEl);
             } else {
                 const simplifiedPlayer = {
                     getVideoData: () => ({
                         video_id: new URL(videoEl.src || videoEl.currentSrc).searchParams.get('video_id') || 'unknown'
                     }),
                     getCurrentTime: () => videoEl.currentTime,
                     getDuration: () => videoEl.duration,
                     play: () => videoEl.play(),
                     pause: () => videoEl.pause()
                 };
                 log('observePlayer', 'Enviando a processVideo simplifiedPlayer:', simplifiedPlayer);
                 log('observePlayer', 'Enviando a processVideo videoEl:', videoEl);
                 processVideo(simplifiedPlayer, videoEl);
             }
         };
 
         // Esperar un poco antes de empezar la b√∫squeda (clave para Shorts -> Watch)
         const observer = new MutationObserver(() => findPlayer());
         setTimeout(() => {
             observer.observe(document.body, { childList: true, subtree: true });
             playerCheckInterval = setInterval(findPlayer, checkDelay);
             log('observePlayer', '‚è≥ Observando el DOM para detectar el reproductor...');
         }, 400);
     } */


    function observePlayer() {
        // Si estamos en Shorts, no continuar (ser√° manejado por otra funci√≥n)
        if (location.pathname.startsWith('/shorts/')) {
            log('observePlayer', 'P√°gina de Shorts detectada, deteniendo observaci√≥n del reproductor regular.');
            return;
        }

        stopChecking(); // Limpiar cualquier intervalo previo
        let adMonitor = null;
        let attempts = 0;
        const maxAttempts = 30;
        const checkDelay = 500;

        const findPlayer = () => {
            attempts++;

            const videoEl = getActiveVideoElement();
            if (!videoEl) {
                log('observePlayer', `Intento ${attempts}: no se encontr√≥ video activo.`);
                if (attempts >= maxAttempts) stopChecking();
                return false;
            }

            let player = window.yt?.player?.getPlayerByElement?.(videoEl) || videoEl.player_ || {
                getVideoData: () => ({
                    video_id: new URL(videoEl.src || videoEl.currentSrc).searchParams.get('v') || 'unknown'
                }),
                getCurrentTime: () => videoEl.currentTime,
                getDuration: () => videoEl.duration,
                play: () => videoEl.play(),
                pause: () => videoEl.pause()
            };

            log('observePlayer', `‚úÖ Reproductor encontrado | videoEl:`, videoEl);

            // Inicializaci√≥n solo una vez
            if (!regularPlayerInitialized) {
                log('init', 'Reproductor regular inicializado.');
                regularPlayerInitialized = true;
            }

            // Monitor de anuncios
            if (adMonitor) adMonitor.stop();
            adMonitor = createAdMonitor(videoEl.closest('#movie_player, .html5-video-player') || videoEl, {
                onAdStart: () => {
                    log('‚è∏ Anuncio detectado, pausando acciones.');
                    isAdPlaying = true;
                },
                onAdEnd: () => {
                    log('‚ñ∂Ô∏è Monitor de anuncios finalizado, reanudando.');
                    isAdPlaying = false;
                    processVideo(player, videoEl);
                }
            });
            adMonitor.start();

            // No llamar processVideo aqu√≠ - el monitor lo llamar√° v√≠a onAdEnd cuando no haya anuncios
            return true;
        };

        // Observador del DOM para detectar cambios en el video
        const observer = new MutationObserver(() => findPlayer());
        setTimeout(() => {
            observer.observe(document.body, { childList: true, subtree: true });
            playerCheckInterval = setInterval(findPlayer, checkDelay);
            log('observePlayer', '‚è≥ Observando el DOM para detectar el reproductor...');
        }, 400);
    }



    // ------------------------------------------
    // MARK: üì± Shorts Observer
    // ------------------------------------------

    // Funci√≥n para observar cambios en los shorts (VERSI√ìN OPTIMIZADA)
    function observeShorts() {
        // Solo ejecutar en Shorts
        if (!location.pathname.startsWith('/shorts/')) {
            log('observeShorts', 'No estamos en una p√°gina de Shorts. Saliendo del observador.');
            return;
        }

        let playerShorts = null;


        playerShorts = getActiveVideoElement();

        stopChecking(); // Limpiar cualquier intervalo existente

        let adMonitor = null;
        let attempts = 0;
        const maxAttempts = 30;
        const checkDelay = 500;

        /* const findShortsPlayer = () => {
            attempts++;
            log('observeShorts', `Intento ${attempts} de encontrar el reproductor de Shorts.`);

            // Salir si dejamos de estar en Shorts
            if (!location.pathname.startsWith('/shorts/')) {
                log('observeShorts', 'Ya no estamos en Shorts, deteniendo observaci√≥n.');
                stopChecking();
                return false;
            }

            const container = document.querySelector('ytd-shorts-player, .html5-video-player, video');
            if (container) {
                const videoEl = container.tagName === 'VIDEO' ? container : container.querySelector('video');
                if (videoEl && videoEl.offsetWidth >= 200) {
                    handleFoundShorts(container, videoEl);
                    observer.disconnect();
                    stopChecking();
                    return true;
                }
            }

            // Fallback despu√©s de varios intentos
            if (attempts >= 12) tryFallback();

            // M√°ximo de intentos
            if (attempts >= maxAttempts) {
                log('observeShorts', 'M√°ximo de intentos alcanzado sin encontrar Shorts.');
                stopChecking();
                observer.disconnect();
            }

            return false;
        }; */

        const processShortsVideo = (videoEl, container) => {
            setTimeout(() => {
                const simplifiedPlayer = {
                    getVideoData: () => ({
                        video_id: new URL(videoEl.src || videoEl.currentSrc, location.origin).searchParams.get('v') || 'unknown'
                    }),
                    getCurrentTime: () => videoEl.currentTime,
                    getDuration: () => videoEl.duration,
                    play: () => videoEl.play(),
                    pause: () => videoEl.pause()
                };
                processVideo(simplifiedPlayer, videoEl);
            }, 150);
        };

        const handleFoundShorts = (container, videoEl) => {
            log('handleFoundShorts', '‚úÖ Reproductor de Shorts encontrado');

            if (adMonitor) adMonitor.stop();

            adMonitor = createAdMonitor(container, {
                onAdStart: () => {
                    log('‚è∏ Anuncio detectado en Shorts, pausando acciones.');
                    isAdPlaying = true;
                },
                onAdEnd: () => {
                    log('‚ñ∂Ô∏è Monitor de anuncios en Shorts finalizado, reanudando.');
                    isAdPlaying = false;
                    processShortsVideo(videoEl, container);
                }
            });

            adMonitor.start();
            // No llamar processShortsVideo aqu√≠ - el monitor lo llamar√° v√≠a onAdEnd cuando no haya anuncios
        };

        // Observador del DOM + polling
        /*  const observer = new MutationObserver(() => findShortsPlayer());
         setTimeout(() => {
             observer.observe(document.body, { childList: true, subtree: true });
             playerCheckInterval = setInterval(findShortsPlayer, checkDelay);
             log('observeShorts', '‚è≥ Observando el DOM de Shorts...');
         }, 400); */
    }


    // ------------------------------------------
    // MARK: üñê handleNavigation
    // ------------------------------------------

    /*
    [handleNavigation] activeVideoElement: [object HTMLVideoElement] 
    [handleNavigation] activePlayer: undefined 
    [handleNavigation] YTHelper.player: [object Object] 
    Uncaught (in promise) TypeError: YTHelper.player.isPlayingAds is not a function
    */

    const handleNavigation = () => {
        if (isAdPlaying) {
            log('handleNavigation', '‚ùå Anuncio en curso, saltando navegaci√≥n.');
            return;
        }
        const currentUrl = location.href;
        if (currentUrl === lastUrl || isNavigating) return;

        isNavigating = true;
        log('handleNavigation', `Navegando a: ${currentUrl} desde ${lastUrl}`);

        // Cancelar cualquier navegaci√≥n pendiente
        if (navigationDebounceTimeout) clearTimeout(navigationDebounceTimeout);

        // Programar nueva limpieza
        navigationDebounceTimeout = setTimeout(async () => {
            cleanupAll();

            currentPageType = getYouTubePageType();
            log('handleNavigation', `Tipo de p√°gina: ${currentPageType}`);

            // Inicializar el observador correspondiente seg√∫n el tipo de p√°gina
            if (currentPageType === 'shorts') {
                log('handleNavigation', 'Inicializando observador de Shorts...');
                // Para Shorts, dar un poco de tiempo antes de inicializar
                setTimeout(() => {
                    observeShorts();
                }, 300);
            } else if (currentPageType === 'watch' || currentPageType === 'embed') {
                log('handleNavigation', 'Inicializando observador de reproductor regular...');
                observePlayer();
            } else if (currentPageType === 'home' && getActiveVideoElement() !== null) {
                log('handleNavigation', 'Homepage con video activo en miniplayer...');
                // Para homepage con miniplayer, usar observePlayer
                observePlayer();
            } else {
                log('handleNavigation', `Tipo de p√°gina no soportado o sin video: ${currentPageType}`);
            }

            isNavigating = false;
            lastUrl = currentUrl;


        }, 100);
    };

    // ------------------------------------------
    // MARK: üßπ cleanupAll
    // ------------------------------------------

    // Funci√≥n para limpiar todos los observadores y estados
    const cleanupAll = () => {
        log('cleanupAll', 'Iniciando limpieza de observadores, intervalos y estados');

        // Limpiar timers/intervals
        const timers = [
            { ref: playerCheckInterval, fn: clearInterval, name: 'playerCheckInterval' },
            { ref: navigationTimeout, fn: clearTimeout, name: 'navigationTimeout' },
            { ref: navigationDebounceTimeout, fn: clearTimeout, name: 'navigationDebounceTimeout' }
        ];

        timers.forEach(({ ref, fn, name }) => {
            if (ref) {
                fn(ref);
                log('cleanupAll', `${name} limpiado`);
            }
        });

        playerCheckInterval = null;
        navigationTimeout = null;
        navigationDebounceTimeout = null;

        // Resetear estados
        isAdPlaying = false;
        regularPlayerInitialized = false;
        currentlyProcessingVideoId = null;
        lastPlaylistId = null;
        isResuming = false;
        lastResumeId = null;



        log('cleanupAll', 'Estados internos reseteados');

        // Limpiar eventos del video
        if (currentVideoEl) {
            if (currentTimeUpdateHandler) {
                currentVideoEl.removeEventListener('timeupdate', currentTimeUpdateHandler);
                currentTimeUpdateHandler = null;
            }
            delete currentVideoEl._cachedPlayerEl;
            currentVideoEl = null;
            log('cleanupAll', 'Eventos del video eliminados');
        }

        clearPlaybackBarMessage();

        const container = document.querySelector('.ypp-toast-container');
        if (container?.hasChildNodes()) {
            const toasts = container.querySelectorAll('.ypp-toast');
            let removed = 0;

            toasts.forEach(toast => {
                if (/[‚èØ‚è±Ô∏èüìåüíæ]/.test(toast.textContent)) {
                    toast.remove();
                    removed++;
                }
            });

            if (removed > 0) log('cleanupAll', `${removed} toasts removidos`);
        }
        log('cleanupAll', 'Limpieza completa realizada');
    };

    // ------------------------------------------
    // MARK: üöÄ Init
    // ------------------------------------------

    // ------------------ showInitRetryToast ------------------
    function showInitRetryToast(failedModules, observerTasks) {
        if (!failedModules?.length) return;

        const names = failedModules.map(f => f.name).join(', ');
        const tooltip = failedModules
            .map(f => `${f.name}: ${f.reason?.message || t('unknownError')}`)
            .join('\n');

        showFloatingToast(
            t('modulesFailed', { count: failedModules.length, names }),
            0, // duraci√≥n 0 = persistente
            {
                keep: true,
                title: tooltip,
                action: {
                    label: t('retryNow'),
                    callback: async () => {
                        log('init', `üîÅ ${t('modulesFailed', { count: failedModules.length, names })}`);

                        for (const fail of failedModules) {
                            const task = observerTasks.find(o => o.name === fail.name);
                            if (!task) continue;

                            try {
                                await task.fn();
                                log('init', `‚úÖ ${fail.name} reintentado correctamente`);
                            } catch (err) {
                                conError('init', `‚ùå ${fail.name} fall√≥ nuevamente:`, err);
                            }
                        }

                        showFloatingToast(t('retryCompleted'), 5000);
                    }
                }
            }
        );
    }

    // ------------------ Debounce helper ------------------
    const debounce = (fn, delay) => {
        let timer;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => fn(...args), delay);
        };
    };

    // ------------------ Retry helper ------------------
    const retry = async (fn, retries = 3, delay = 1000, name = 'funci√≥n') => {
        for (let i = 0; i < retries; i++) {
            try {
                if (i > 0) log('init', `Reintentando ${name} (intento ${i + 1}/${retries})...`);
                return await fn();
            } catch (error) {
                warn('init', `Error en ${name} intento ${i + 1}:`, error);
                if (i < retries - 1) await new Promise(res => setTimeout(res, delay));
            }
        }
        throw new Error(`${name} fall√≥ tras ${retries} intentos`);
    };

    // ------------------ Inicializaci√≥n ------------------
    const init = async () => {
        log('init', 'üöÄ Iniciando script...');

        // --- 0Ô∏è‚É£ Inicializar YouTube Helper API ---
        YTHelper = await waitForHelper();
        log('init', '‚úÖ YouTube Helper listo:', YTHelper);




        // --- 1Ô∏è‚É£ Cargar traducciones ---
        try {
            const { LANGUAGE_FLAGS: loadedFlags, TRANSLATIONS: loadedTranslations } = await loadTranslations();

            if (loadedTranslations && Object.keys(loadedTranslations).length > 3) {
                LANGUAGE_FLAGS = loadedFlags;
                TRANSLATIONS = loadedTranslations;
                log('init', '‚úÖ Traducciones externas cargadas correctamente');
            } else {
                warn('init', '‚ö†Ô∏è Traducciones externas incompletas, usando fallback');
                LANGUAGE_FLAGS = FALLBACK_FLAGS;
                TRANSLATIONS = FALLBACK_TRANSLATIONS;
            }
        } catch (error) {
            conError('init', '‚ùå Error al cargar traducciones:', error);
            LANGUAGE_FLAGS = FALLBACK_FLAGS;
            TRANSLATIONS = FALLBACK_TRANSLATIONS;
        }

        // --- 2Ô∏è‚É£ Cargar configuraci√≥n y establecer idioma ---
        try {
            cachedSettings = await Settings.get();
            log('init', 'Settings cargados:', cachedSettings);

            let langToUse;

            if (cachedSettings.language && TRANSLATIONS[cachedSettings.language] && cachedSettings.language !== CONFIG.defaultSettings.language) {
                // Idioma guardado por el usuario y v√°lido
                langToUse = cachedSettings.language;
                log('init', `Idioma guardado v√°lido: ${langToUse}`);
            } else {
                // Primera carga o idioma no configurado, usar navegador si existe
                const browserLang = detectBrowserLanguage();
                langToUse = TRANSLATIONS[browserLang] ? browserLang : CONFIG.defaultSettings.language;
                log('init', `Idioma detectado o fallback: ${langToUse}`);
            }

            await setLanguage(langToUse);
            log('init', `üåê Idioma configurado: ${langToUse}`);

            // Guardar preferencia si era primera carga
            if (!cachedSettings.language || cachedSettings.language === CONFIG.defaultSettings.language) {
                cachedSettings.language = langToUse;
                await Settings.set(cachedSettings);
                log('init', `Idioma guardado en settings: ${langToUse}`);
            }
        } catch (error) {
            conError('init', '‚ùå Error al cargar settings o establecer idioma:', error);
        }

        // --- 3Ô∏è‚É£ Normalizar almacenamiento ---
        try {
            if (typeof normalizeYouTubeStorageKeys === 'function') {
                normalizeYouTubeStorageKeys();
                log('init', 'üßπ Storage normalizado correctamente.');
            } else {
                warn('init', '‚ö†Ô∏è normalizeYouTubeStorageKeys no definida a√∫n.');
            }
        } catch (err) {
            conError('init', '‚ùå Error al normalizar Storage:', err);
        }

        // --- 4Ô∏è‚É£ Registrar comandos e inyectar estilos ---
        try {
            registerMenuCommands();
            injectStyles();
        } catch (error) {
            conError('init', '‚ùå Error al registrar men√∫ o inyectar estilos:', error);
        }

        // --- 5Ô∏è‚É£ Inicializar observadores con reintento ---
        /*   const observerTasks = [
              /*  { name: 'observeShorts', fn: observeShorts },
               { name: 'observePlayer', fn: observePlayer }, *
              { name: 'createFloatingButton', fn: createFloatingButton }
          ];
  
          const results = await Promise.allSettled(
              observerTasks.map(o => retry(o.fn, 3, 1500, o.name))
          );
  
          const failed = results.filter(r => r.status === 'rejected');
          const succeeded = results.filter(r => r.status === 'fulfilled');
  
          if (failed.length > 0) {
              conError('init', `Fallaron ${failed.length} de ${results.length} inicializaciones`, failed);
  
              // Mostrar el toast interactivo con tooltip de errores
              showInitRetryToast(failed, observerTasks);
          }
  
          log('init', `üèÅ Inicializaci√≥n completada: ${succeeded.length} exitosas, ${failed.length} fallidas`, {
              succeeded: succeeded.map(s => s.name),
              failed: failed.map(f => ({ name: f.name, reason: f.reason?.message || f.reason }))
          }); */

        // --- 6Ô∏è‚É£ Eventos de navegaci√≥n con debounce ---
        const debouncedNavigation = debounce(handleNavigation, 50);
        window.addEventListener('yt-navigate-finish', debouncedNavigation);
        window.addEventListener('popstate', debouncedNavigation);

        // --- 7Ô∏è‚É£ Limpieza antes de descargar la p√°gina ---
        window.addEventListener('beforeunload', cleanupAll);

        createFloatingButton();

        log('init', '‚ú® Script completamente inicializado');

        // --- 8Ô∏è‚É£ Inicializar la p√°gina actual ---
        // Llamar a handleNavigation para inicializar el observador correspondiente
        setTimeout(() => {
            handleNavigation();
        }, 500);
    };

    init();


})();